<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>TETRIS ‚Äî Cinematic Edition</title>
  <style>
    /* Reset and base */
    html, body { height: 100%; margin: 0; padding: 0; }
    * { box-sizing: border-box; }

    /* Theme variables */
    :root {
      --bg1: #0e132f;
      --bg2: #14213d;
      --bg3: #1f2a57;
      --bg-speed: 16s;

      --accent1: #a855f7;
      --accent2: #06b6d4;

      --board-glow: rgba(168, 85, 247, 0.26);
      --board-inset: rgba(0, 0, 0, 0.5);

      --ghost-border: rgba(255, 255, 255, 0.36);
      --ghost-bg: rgba(255, 255, 255, 0.12);

      --reactive-brightness: 1;
      --reactive-hue: 0deg;
      --reactive-sat: 105%;
      --reactive-blur: 0px;

      --ui-scale: 1;
      --title-glow: rgba(168, 85, 247, 0.5);

      --comfort-brightness-cap: 1.3;
      --comfort-duration: 360ms;
    }

    /* Background */
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background:
        radial-gradient(60% 60% at 20% 20%, rgba(255,255,255,0.03), transparent 60%),
        linear-gradient(135deg, var(--bg1) 0%, var(--bg2) 50%, var(--bg3) 100%);
      background-size: 400% 400%;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      overflow: hidden;
      filter: brightness(var(--reactive-brightness)) saturate(var(--reactive-sat)) hue-rotate(var(--reactive-hue));
      animation: bgShift var(--bg-speed) ease infinite;
    }
    @keyframes bgShift {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    /* Soft sparkle overlay */
    .bg-sparkle {
      position: fixed; inset: 0; pointer-events: none; z-index: 0;
      background:
        radial-gradient(1200px 800px at 10% 20%, rgba(255,255,255,0.03), transparent 60%),
        radial-gradient(1000px 900px at 90% 30%, rgba(255,255,255,0.04), transparent 65%),
        radial-gradient(900px 700px at 50% 80%, rgba(255,255,255,0.02), transparent 70%);
      mix-blend-mode: screen;
      animation: sparkleMove 22s linear infinite;
      opacity: 0.35;
    }
    @keyframes sparkleMove {
      0% { transform: translate(0,0); }
      50% { transform: translate(24px,-16px); }
      100% { transform: translate(0,0); }
    }

    /* Ripple on clears */
    .bg-ripple {
      position: fixed; inset: 0; pointer-events: none; z-index: 1;
      background: radial-gradient(circle, rgba(255,255,255,0.22) 0%, transparent 70%);
      opacity: 0;
    }
    .bg-ripple.active { animation: rippleExpand 0.7s ease-out forwards; }
    @keyframes rippleExpand {
      0% { opacity: 0.5; transform: scale(0); }
      50% { opacity: 0.25; transform: scale(1.7); }
      100% { opacity: 0; transform: scale(2.4); }
    }

    /* End-game backdrop */
    .end-game-bg {
      position: fixed; inset: 0; pointer-events: none; z-index: 999;
      background: radial-gradient(circle, rgba(255,0,0,0) 0%, rgba(0,0,0,0) 100%);
      opacity: 0;
    }
    .end-game-bg.active { animation: endFade 2.0s ease-in forwards; }
    @keyframes endFade {
      0% { opacity: 0; background: radial-gradient(circle, rgba(255,0,0,0) 0%, rgba(0,0,0,0) 100%); }
      50% { opacity: 0.7; background: radial-gradient(circle, rgba(255,0,0,0.45) 0%, rgba(0,0,0,0.8) 100%); }
      100% { opacity: 1; background: radial-gradient(circle, rgba(255,0,0,0.75) 0%, rgba(0,0,0,1) 100%); }
    }

    /* UI buttons */
    .update-log-btn, .settings-btn {
      position: fixed;
      top: 20px;
      padding: 10px 20px;
      border-radius: 10px;
      font-weight: bold;
      font-size: 0.9rem;
      color: white;
      cursor: pointer;
      transition: all 0.25s ease;
      z-index: 1000;
      border: none;
    }
    .update-log-btn {
      left: 20px;
      background: rgba(168, 85, 247, 0.85);
      border: 2px solid rgba(168, 85, 247, 0.5);
      box-shadow: 0 4px 15px rgba(168, 85, 247, 0.3);
      backdrop-filter: blur(8px);
    }
    .settings-btn {
      right: 20px;
      background: rgba(6, 182, 212, 0.85);
      border: 2px solid rgba(6, 182, 212, 0.5);
      box-shadow: 0 4px 15px rgba(6, 182, 212, 0.3);
      backdrop-filter: blur(8px);
    }
    .update-log-btn:hover, .settings-btn:hover { transform: translateY(-2px); }

    /* Modals */
    .modal {
      position: fixed; inset: 0;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(5px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }
    .modal.show { display: flex; }
    .modal-content {
      background: linear-gradient(135deg, #0e132f 0%, #1a1a2e 100%);
      border: 3px solid rgba(168, 85, 247, 0.5);
      border-radius: 20px;
      padding: 24px;
      width: 92%;
      max-width: 560px;
      box-shadow: 0 10px 40px rgba(168, 85, 247, 0.5);
      animation: slideIn 0.3s ease;
    }
    .modal-content h2 { color: #a855f7; margin-bottom: 10px; font-size: 1.6rem; }
    .modal-content .close { margin-top: 16px; width: 100%; padding: 10px 20px; border-radius: 8px; border: none; color: white; font-weight: bold; cursor: pointer; background: linear-gradient(45deg, var(--accent1), var(--accent2)); }

    .modal-settings .modal-content { border-color: rgba(6,182,212,0.5); max-width: 420px; }
    .modal-settings .modal-content h2 { color: #06b6d4; }
    .modal-settings label { display: block; margin: 10px 0; font-size: 0.95rem; }
    .modal-settings select, .modal-settings input[type="checkbox"], .modal-settings input[type="range"] { margin-left: 8px; vertical-align: middle; }

    @keyframes slideIn { from { transform: translateY(-30px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

    /* Game layout */
    .game-container {
      display: flex;
      gap: 20px;
      padding: 20px;
      position: relative;
      transform: scale(var(--ui-scale));
      transition: transform 200ms ease;
      z-index: 10;
      margin-top: 40px;
    }

    .side-panel {
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      border: 2px solid rgba(168, 85, 247, 0.3);
      border-radius: 15px;
      padding: 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      min-width: 160px;
    }

    .main-panel { display: flex; flex-direction: column; align-items: center; gap: 15px; }

    .title {
      font-size: 3rem;
      font-weight: bold;
      text-align: center;
      background: linear-gradient(45deg, var(--accent1), var(--accent2));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      filter: drop-shadow(0 0 24px var(--title-glow));
      animation: pulse 2s infinite;
      letter-spacing: 4px;
      user-select: none;
    }

    .stats { display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; }
    .stat-box {
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      padding: 10px 20px;
      border-radius: 10px;
      text-align: center;
      min-width: 110px;
      border: 2px solid rgba(168, 85, 247, 0.2);
    }
    .stat-label { font-size: 0.75rem; opacity: 0.75; margin-bottom: 5px; }
    .stat-value { font-size: 1.5rem; font-weight: bold; }

    #gameBoard {
      position: relative;
      background: #0a0a0a;
      border: 3px solid;
      border-image: linear-gradient(45deg, var(--accent1), var(--accent2)) 1;
      box-shadow: 0 0 40px var(--board-glow), inset 0 0 60px var(--board-inset);
      transition: transform 0.05s;
      display: grid;
      gap: 1px;
      padding: 2px;
      width: calc(30px * 10 + 2px * 2 + 1px * 9);
      height: calc(30px * 20 + 2px * 2 + 1px * 19);
    }
    #gameBoard.shake { animation: shake 0.12s; }

    .cell {
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 2px;
      background: #0a0a0a;
      width: 30px;
      height: 30px;
    }

    .panel-title { font-size: 0.875rem; font-weight: bold; text-align: center; margin-bottom: 10px; opacity: 0.85; user-select: none; }

    .preview-box {
      background: rgba(255, 255, 255, 0.03);
      padding: 10px;
      border-radius: 8px;
      min-height: 80px;
      display: flex; align-items: center; justify-content: center;
    }
    .next-preview { opacity: 0.6; margin-bottom: 10px; min-height: 60px; }

    .controls {
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      padding: 15px;
      border-radius: 10px;
      margin-top: 15px;
      text-align: center;
      font-size: 0.75rem;
      border: 1px solid rgba(168, 85, 247, 0.2);
      max-width: 440px;
      user-select: none;
    }
    .controls-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 10px; }

    .btn, .play-again-btn {
      background: linear-gradient(45deg, var(--accent1), var(--accent2));
      border: none;
      color: white;
      padding: 12px 32px;
      border-radius: 8px;
      font-size: 1.1rem;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.25s ease;
      box-shadow: 0 4px 15px rgba(168, 85, 247, 0.4);
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .btn:hover, .play-again-btn:hover { transform: translateY(-2px) scale(1.04); }

    /* Overlay messages */
    .overlay-message {
      position: absolute; top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      font-weight: bold; pointer-events: none; z-index: 100;
      text-align: center; white-space: nowrap;
    }
    .combo-text { font-size: 3.0rem; color: #ffff00; text-shadow: 0 0 16px #ffff00, 0 0 30px #ffff00; animation: comboPopIn 0.6s cubic-bezier(0.68,-0.55,0.265,1.55); }
    .action-text { font-size: 2.2rem; color: #ff00ff; text-shadow: 0 0 22px #ff00ff; animation: actionPopIn 0.8s cubic-bezier(0.68,-0.55,0.265,1.55); }
    .perfect-clear { font-size: 2rem; color: #00f0f0; text-shadow: 0 0 28px #00f0f0; animation: perfectClearAnim 2s ease-out; }
    .paused { font-size: 2rem; color: #ffff00; text-shadow: 0 0 10px #ffff00; animation: pulse 1.5s infinite; }

    .game-over { text-align: center; animation: fadeIn 0.5s; }
    .game-over-title { font-size: 2.5rem; color: #ff0000; text-shadow: 0 0 18px #ff0000; animation: pulse 1s infinite; margin-bottom: 20px; }

    canvas { position: absolute; top: 0; left: 0; pointer-events: none; }

    /* Animations */
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
    @keyframes shake { 0%, 100% { transform: translate(0, 0); } 25% { transform: translate(-2px, 2px); } 50% { transform: translate(2px, -2px); } 75% { transform: translate(-2px, -2px); } }
    @keyframes comboPopIn { 0% { transform: translate(-50%, -50%) scale(0) rotate(-180deg); opacity: 0; } 50% { transform: translate(-50%, -50%) scale(1.22) rotate(10deg); } 100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); opacity: 1; } }
    @keyframes actionPopIn { 0% { transform: translate(-50%, -50%) scale(0); opacity: 0; } 60% { transform: translate(-50%, -50%) scale(1.12); opacity: 1; } 100% { transform: translate(-50%, -50%) scale(1); } }
    @keyframes perfectClearAnim { 0% { transform: translate(-50%, -50%) scale(0); opacity: 0; } 30% { transform: translate(-50%, -50%) scale(1.38); opacity: 1; } 70% { transform: translate(-50%, -50%) scale(1.16); opacity: 1; } 100% { transform: translate(-50%, -50%) scale(1); opacity: 0; } }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }

    /* Line clear animation */
    @keyframes clearLineCell {
      0%   { opacity: 1; transform: scale(1); box-shadow: 0 0 10px var(--cell-color); filter: brightness(1); }
      25%  { opacity: 1; transform: scale(1.14); box-shadow: 0 0 22px #fff, 0 0 38px var(--cell-color); filter: brightness(1.22) saturate(1.35); }
      50%  { opacity: 1; transform: scale(1.06); box-shadow: 0 0 28px var(--cell-color), inset 0 0 16px #fff; filter: hue-rotate(90deg) brightness(1.25); }
      75%  { opacity: 0.75; transform: scale(0.84); box-shadow: 0 0 22px #ff00ff; }
      100% { opacity: 0; transform: scale(0.6); box-shadow: none; filter: brightness(0.4); }
    }
    .clearing { animation: clearLineCell 0.62s ease-out forwards; }
  </style>
</head>
<body>
  <div class="bg-sparkle"></div>
  <div class="bg-ripple" id="bgRipple"></div>
  <div class="end-game-bg" id="endGameBg"></div>

  <button class="update-log-btn" onclick="toggleUpdateLog()">üìã Update Log</button>
  <button class="settings-btn" onclick="toggleSettings()">‚öôÔ∏è Settings</button>

  <div class="modal" id="updateLogModal">
    <div class="modal-content">
      <h2>Update log</h2>
      <p style="opacity:.85;margin-bottom:10px;">Version 3.4.0 ‚Äî Fixed themes + enhanced visuals</p>
      <ul style="list-style:none;padding:0;">
        <li style="padding:6px 0;">‚Ä¢ Fixed theme switching to actually work</li>
        <li style="padding:6px 0;">‚Ä¢ Enhanced all 5 themes with better colors</li>
        <li style="padding:6px 0;">‚Ä¢ Removed random text appearing on screen</li>
        <li style="padding:6px 0;">‚Ä¢ Improved visual polish and animations</li>
      </ul>
      <button class="close" onclick="toggleUpdateLog()">Close</button>
    </div>
  </div>

  <div class="modal modal-settings" id="settingsModal">
    <div class="modal-content">
      <h2>Settings</h2>
      <label>
        Theme:
        <select id="themeSelect">
          <option value="cosmic">Cosmic Purple</option>
          <option value="aurora">Aurora Teal</option>
          <option value="cyberpunk">Cyberpunk Neon</option>
          <option value="retro">Retro Sunset</option>
          <option value="jungle">Jungle Green</option>
        </select>
      </label>
      <label>
        Comfort mode:
        <input type="checkbox" id="comfortToggle" checked />
      </label>
      <label>
        Particles:
        <input type="range" id="particlesSlider" min="0" max="100" value="70" />
      </label>
      <button class="close" onclick="toggleSettings()">Close</button>
    </div>
  </div>

  <div class="game-container" id="gameContainer">
    <div class="side-panel" id="holdPanel">
      <div class="panel-title">HOLD (C)</div>
      <div class="preview-box" id="holdBox"></div>
    </div>

    <div class="main-panel">
      <div class="title" id="title">TETRIS</div>

      <div class="stats">
        <div class="stat-box" style="border: 2px solid rgba(0, 240, 240, 0.3);">
          <div class="stat-label">SCORE</div>
          <div class="stat-value" id="score" style="color: #00f0f0; text-shadow: 0 0 10px #00f0f0;">0</div>
        </div>
        <div class="stat-box" style="border: 2px solid rgba(0, 240, 0, 0.3);">
          <div class="stat-label">LEVEL</div>
          <div class="stat-value" id="level" style="color: #00f000;">1</div>
        </div>
        <div class="stat-box" style="border: 2px solid rgba(240, 240, 0, 0.3);">
          <div class="stat-label">LINES</div>
          <div class="stat-value" id="lines" style="color: #f0f000;">0</div>
        </div>
      </div>

      <div style="position: relative;">
        <div id="gameBoard"></div>
        <canvas id="particleCanvas" width="306" height="606"></canvas>
        <div id="overlayMessages"></div>
      </div>

      <div id="gameOverScreen" style="display: none;"></div>

      <button class="play-again-btn" onclick="location.reload()">üîÑ Play Again</button>

      <div class="controls">
        <div style="font-weight: bold; margin-bottom: 10px; color: #a855f7;">CONTROLS</div>
        <div class="controls-grid">
          <div>‚Üê ‚Üí Move</div>
          <div>‚Üë Rotate</div>
          <div>‚Üì Soft Drop</div>
          <div>SPACE Hard Drop</div>
          <div>C Hold</div>
          <div>P Pause</div>
        </div>
      </div>
    </div>

    <div class="side-panel">
      <div class="panel-title">NEXT</div>
      <div id="nextPieces"></div>
    </div>
  </div>

  <script>
    function toggleUpdateLog() {
      document.getElementById('updateLogModal').classList.toggle('show');
    }
    function toggleSettings() {
      document.getElementById('settingsModal').classList.toggle('show');
    }

    const BOARD_WIDTH = 10;
    const BOARD_HEIGHT = 20;
    const CELL_SIZE = 30;
    const DAS_DELAY = 170;
    const DAS_INTERVAL = 50;

    const SHAPES = {
      I: [[1,1,1,1]],
      O: [[1,1],[1,1]],
      T: [[0,1,0],[1,1,1]],
      S: [[0,1,1],[1,1,0]],
      Z: [[1,1,0],[0,1,1]],
      J: [[1,0,0],[1,1,1]],
      L: [[0,0,1],[1,1,1]]
    };

    const COLORS = {
      I: '#00f0f0',
      O: '#f0f000',
      T: '#a000f0',
      S: '#00f000',
      Z: '#f00000',
      J: '#0000f0',
      L: '#f0a000'
    };

    const THEMES = {
      cosmic: { 
        bg1: '#0e132f', 
        bg2: '#14213d', 
        bg3: '#1f2a57', 
        accent1: '#a855f7', 
        accent2: '#06b6d4',
        glow: 'rgba(168, 85, 247, 0.5)'
      },
      aurora: { 
        bg1: '#041b2d', 
        bg2: '#0a3a5a', 
        bg3: '#0f5d7e', 
        accent1: '#22d3ee', 
        accent2: '#8b5cf6',
        glow: 'rgba(34, 211, 238, 0.6)'
      },
      cyberpunk: { 
        bg1: '#120015', 
        bg2: '#2d0033', 
        bg3: '#4a0058', 
        accent1: '#ff00ff', 
        accent2: '#00ffc8',
        glow: 'rgba(255, 0, 255, 0.7)'
      },
      retro: { 
        bg1: '#2a1f1a', 
        bg2: '#4b3a2c', 
        bg3: '#6b5541', 
        accent1: '#ff9500', 
        accent2: '#ff1f7d',
        glow: 'rgba(255, 149, 0, 0.6)'
      },
      jungle: { 
        bg1: '#0b1f12', 
        bg2: '#163f26', 
        bg3: '#1f7a3d', 
        accent1: '#49f77b', 
        accent2: '#1af7d6',
        glow: 'rgba(73, 247, 123, 0.6)'
      }
    };

    function applyTheme(name) {
      const t = THEMES[name] || THEMES.cosmic;
      const root = document.documentElement;
      root.style.setProperty('--bg1', t.bg1);
      root.style.setProperty('--bg2', t.bg2);
      root.style.setProperty('--bg3', t.bg3);
      root.style.setProperty('--accent1', t.accent1);
      root.style.setProperty('--accent2', t.accent2);
      root.style.setProperty('--title-glow', t.glow);
      root.style.setProperty('--board-glow', t.glow.replace('0.6', '0.26'));
    }

    class TetrisGame {
      constructor() {
        this.board = Array(BOARD_HEIGHT).fill().map(() => Array(BOARD_WIDTH).fill(0));
        this.currentPiece = null;
        this.currentPos = { x: 0, y: 0 };
        this.heldPiece = null;
        this.canHold = true;

        this.score = 0;
        this.level = 1;
        this.lines = 0;

        this.gameOver = false;
        this.isPaused = false;

        this.nextPieces = [];
        this.clearingLines = [];
        this.ghostPos = null;
        this.particles = [];
        this.comboCount = 0;

        this.fallSpeed = 500;
        this.lastFallTime = Date.now();
        this.dropLock = false;

        this.keysPressed = {};
        this.dasTimers = {};
        this.dasIntervals = {};

        this.comfortMode = true;
        this.particlesIntensity = 70;

        this.initGame();
        this.setupControls();
        this.setupSettingsBindings();
        this.gameLoop();
      }

      initGame() {
        applyTheme('cosmic');
        this.nextPieces = [this.getRandomPiece(), this.getRandomPiece(), this.getRandomPiece()];
        this.spawnPiece();
        this.setupParticleCanvas();
        this.updateDisplay();
        this.updateReactiveBackground(true);
      }

      setupSettingsBindings() {
        const themeSelect = document.getElementById('themeSelect');
        const comfortToggle = document.getElementById('comfortToggle');
        const particlesSlider = document.getElementById('particlesSlider');

        themeSelect.addEventListener('change', () => {
          applyTheme(themeSelect.value);
          this.updateReactiveBackground(true);
        });
        comfortToggle.addEventListener('change', () => { this.comfortMode = comfortToggle.checked; });
        particlesSlider.addEventListener('input', () => { this.particlesIntensity = parseInt(particlesSlider.value, 10); });
      }

      setupParticleCanvas() {
        const canvas = document.getElementById('particleCanvas');
        canvas.width = BOARD_WIDTH * CELL_SIZE + 6;
        canvas.height = BOARD_HEIGHT * CELL_SIZE + 6;
        this.particleCtx = canvas.getContext('2d');
      }

      getRandomPiece() {
        const types = Object.keys(SHAPES);
        const type = types[Math.floor(Math.random() * types.length)];
        return { type, shape: JSON.parse(JSON.stringify(SHAPES[type])) };
      }

      spawnPiece(piece = null) {
        const newPiece = piece || this.nextPieces.shift();
        if (!piece) this.nextPieces.push(this.getRandomPiece());
        const x = Math.floor(BOARD_WIDTH / 2) - Math.floor(newPiece.shape[0].length / 2);
        this.currentPiece = newPiece;
        this.currentPos = { x, y: 0 };
        this.canHold = true;
        this.calculateGhost();

        if (this.checkCollision(this.currentPiece, this.currentPos)) {
          this.gameOver = true;
          this.showGameOver();
        }
        this.render();
      }

      checkCollision(piece, pos) {
        for (let y = 0; y < piece.shape.length; y++) {
          for (let x = 0; x < piece.shape[y].length; x++) {
            if (piece.shape[y][x]) {
              const newX = pos.x + x;
              const newY = pos.y + y;
              if (newX < 0 || newX >= BOARD_WIDTH || newY >= BOARD_HEIGHT) return true;
              if (newY >= 0 && this.board[newY][newX]) return true;
            }
          }
        }
        return false;
      }

      movePiece(dx, dy) {
        if (!this.currentPiece || this.gameOver || this.isPaused || this.clearingLines.length > 0 || this.dropLock) return false;
        const newPos = { x: this.currentPos.x + dx, y: this.currentPos.y + dy };
        if (!this.checkCollision(this.currentPiece, newPos)) {
          this.currentPos = newPos;
          this.calculateGhost();
          this.render();
          return true;
        }
        return false;
      }

      rotatePiece() {
        if (!this.currentPiece || this.gameOver || this.isPaused || this.clearingLines.length > 0 || this.dropLock) return;
        const rotated = this.currentPiece.shape[0].map((_, i) =>
          this.currentPiece.shape.map(row => row[i]).reverse()
        );
        const rotatedPiece = { ...this.currentPiece, shape: rotated };

        const kicks = [
          { x: 0, y: 0 }, { x: -1, y: 0 }, { x: 1, y: 0 },
          { x: 0, y: -1 }, { x: -1, y: -1 }, { x: 1, y: -1 },
          { x: -2, y: 0 }, { x: 2, y: 0 }
        ];

        for (let kick of kicks) {
          const testPos = { x: this.currentPos.x + kick.x, y: this.currentPos.y + kick.y };
          if (!this.checkCollision(rotatedPiece, testPos)) {
            this.currentPiece = rotatedPiece;
            this.currentPos = testPos;
            this.calculateGhost();
            this.render();
            return;
          }
        }
      }

      calculateGhost() {
        if (!this.currentPiece) { this.ghostPos = null; return; }
        let ghostY = this.currentPos.y;
        while (!this.checkCollision(this.currentPiece, { x: this.currentPos.x, y: ghostY + 1 })) ghostY++;
        this.ghostPos = ghostY;
      }

      hardDrop() {
        if (!this.currentPiece || this.gameOver || this.isPaused || this.clearingLines.length > 0 || this.dropLock) return;
        this.dropLock = true;
        let newY = this.currentPos.y;
        while (!this.checkCollision(this.currentPiece, { x: this.currentPos.x, y: newY + 1 })) newY++;

        const dropDistance = newY - this.currentPos.y;
        this.currentPos.y = newY;

        for (let y = 0; y < this.currentPiece.shape.length; y++) {
          for (let x = 0; x < this.currentPiece.shape[y].length; x++) {
            if (this.currentPiece.shape[y][x]) {
              const intensityFactor = this.particlesIntensity / 100;
              this.createParticles(this.currentPos.x + x, this.currentPos.y + y, COLORS[this.currentPiece.type], Math.round(16 * intensityFactor));
            }
          }
        }

        this.shakeBoard();
        this.lockPiece();

        const points = dropDistance * 2;
        this.score += points;
        this.updateDisplay();
      }

      lockPiece() {
        for (let y = 0; y < this.currentPiece.shape.length; y++) {
          for (let x = 0; x < this.currentPiece.shape[y].length; x++) {
            if (this.currentPiece.shape[y][x]) {
              const boardY = this.currentPos.y + y;
              if (boardY >= 0) {
                this.board[boardY][this.currentPos.x + x] = this.currentPiece.type;
              }
            }
          }
        }
        this.clearLines();
      }

      clearLines() {
        const linesToClear = [];
        this.board.forEach((row, y) => { if (row.every(cell => cell !== 0)) linesToClear.push(y); });

        if (linesToClear.length > 0) {
          this.clearingLines = linesToClear;
          const boardEl = document.getElementById('gameBoard');
          const cells = boardEl.children;

          linesToClear.forEach((lineY) => {
            for (let x = 0; x < BOARD_WIDTH; x++) {
              const idx = lineY * BOARD_WIDTH + x;
              const cellEl = cells[idx];
              const type = this.board[lineY][x];
              const color = COLORS[type] || '#ffffff';
              if (cellEl) {
                cellEl.style.setProperty('--cell-color', color);
                cellEl.classList.add('clearing');
              }
              const intensityFactor = this.particlesIntensity / 100;
              this.createParticles(x, lineY, color, Math.round(14 * intensityFactor));
            }
          });

          const ripple = document.getElementById('bgRipple');
          ripple.classList.add('active');
          setTimeout(() => ripple.classList.remove('active'), 700);

          this.shakeBoard();
          this.flashBackground(linesToClear.length === 4 ? 'tetris' : 'clear', linesToClear.length);

          setTimeout(() => {
            this.board = this.board.filter((_, y) => !linesToClear.includes(y));
            while (this.board.length < BOARD_HEIGHT) this.board.unshift(Array(BOARD_WIDTH).fill(0));

            const points = linesToClear.length === 1 ? 100 :
                           linesToClear.length === 2 ? 300 :
                           linesToClear.length === 3 ? 500 : 800;
            this.score += points * this.level;
            this.lines += linesToClear.length;
            this.level = Math.floor(this.lines / 10) + 1;
            this.fallSpeed = Math.max(100, 500 - (this.level - 1) * 40);

            if (this.board.every(row => row.every(cell => cell === 0))) {
              this.showMessage('‚òÖ PERFECT CLEAR ‚òÖ', 'perfect-clear', 2000);
              this.score += 1000;
              this.flashBackground('perfect', 5);
            }

            let actionText = '';
            if (linesToClear.length === 4) actionText = 'TETRIS!';
            else if (linesToClear.length === 3) actionText = 'TRIPLE!';
            else if (linesToClear.length === 2) actionText = 'DOUBLE!';
            if (actionText) this.showMessage(actionText, 'action-text', 1500);

            this.comboCount++;
            if (this.comboCount > 1) {
              this.showMessage(`${this.comboCount}x COMBO!`, 'combo-text', 1000);
            }

            this.clearingLines = [];
            this.updateDisplay();
            this.dropLock = false;
            this.spawnPiece();
            this.render();
            this.updateReactiveBackground();
          }, 430);
        } else {
          this.comboCount = 0;
          this.dropLock = false;
          this.spawnPiece();
        }
      }

      holdPiece() {
        if (!this.canHold || !this.currentPiece || this.gameOver || this.isPaused || this.clearingLines.length > 0 || this.dropLock) return;
        this.canHold = false;

        if (this.heldPiece) {
          const temp = this.currentPiece;
          this.spawnPiece(this.heldPiece);
          this.heldPiece = temp;
        } else {
          this.heldPiece = this.currentPiece;
          this.spawnPiece();
        }
        this.renderHold();
      }

      createParticles(x, y, color, count) {
        for (let i = 0; i < count; i++) {
          this.particles.push({
            x: x * CELL_SIZE + CELL_SIZE / 2 + 2,
            y: y * CELL_SIZE + CELL_SIZE / 2 + 2,
            vx: (Math.random() - 0.5) * 10,
            vy: (Math.random() - 0.5) * 10 - 3.2,
            color,
            life: 1,
            size: Math.random() * 3 + 2
          });
        }
      }

      updateParticles() {
        const ctx = this.particleCtx;
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

        this.particles = this.particles.filter(p => {
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.38;
          p.vx *= 0.988;
          p.life -= 0.015;

          if (p.life > 0) {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.shadowBlur = 10;
            ctx.shadowColor = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
            ctx.fill();
            return true;
          }
          return false;
        });

        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
      }

      shakeBoard() {
        const board = document.getElementById('gameBoard');
        board.classList.add('shake');
        setTimeout(() => board.classList.remove('shake'), 100);
      }

      showMessage(text, className, duration) {
        const container = document.getElementById('overlayMessages');
        const msg = document.createElement('div');
        msg.className = `overlay-message ${className}`;
        msg.textContent = text;
        container.appendChild(msg);
        setTimeout(() => { msg.remove(); }, duration);
      }

      showGameOver() {
        const screen = document.getElementById('gameOverScreen');
        screen.style.display = 'block';
        screen.innerHTML = `
          <div class="game-over">
            <div class="game-over-title">GAME OVER</div>
            <div style="font-size: 1.5rem; margin-bottom: 20px;">
              Final Score: <span style="color: #00f0f0; font-weight: bold;">${this.score}</span>
            </div>
            <button class="btn" onclick="location.reload()">Play Again</button>
          </div>
        `;
        const endBg = document.getElementById('endGameBg');
        endBg.classList.add('active');
        const gameContainer = document.getElementById('gameContainer');
        gameContainer.animate(
          [
            { transform: 'scale(1)', filter: 'none' },
            { transform: 'scale(0.95)', filter: 'blur(0.6px)' },
            { transform: 'scale(0.92) rotate(0.6deg)', filter: 'blur(1px)' }
          ],
          { duration: 500, easing: 'ease-in', fill: 'forwards' }
        );
        for (let y = 0; y < BOARD_HEIGHT; y++) {
          for (let x = 0; x < BOARD_WIDTH; x++) {
            if (this.board[y][x]) {
              const color = COLORS[this.board[y][x]];
              const intensityFactor = this.particlesIntensity / 100;
              this.createParticles(x, y, color, Math.round(8 * intensityFactor));
            }
          }
        }
        this.flashBackground('gameover', 3);
      }

      setupControls() {
        document.addEventListener('keydown', (e) => {
          if (this.gameOver) return;
          if (['ArrowLeft', 'ArrowRight', 'ArrowDown', 'ArrowUp', ' ', 'c', 'C', 'p', 'P'].includes(e.key)) e.preventDefault();

          if (!this.keysPressed[e.key]) {
            this.keysPressed[e.key] = true;

            switch(e.key) {
              case 'ArrowUp': this.rotatePiece(); break;
              case ' ': this.hardDrop(); break;
              case 'c': case 'C': this.holdPiece(); break;
              case 'p': case 'P':
                this.isPaused = !this.isPaused;
                if (this.isPaused) {
                  this.showMessage('‚è∏ PAUSED', 'paused', 999999);
                } else {
                  document.getElementById('overlayMessages').innerHTML = '';
                  this.lastFallTime = Date.now();
                }
                break;
            }

            if (['ArrowLeft', 'ArrowRight', 'ArrowDown'].includes(e.key)) {
              this.handleMovement(e.key);
              this.dasTimers[e.key] = setTimeout(() => {
                this.dasIntervals[e.key] = setInterval(() => { this.handleMovement(e.key); }, DAS_INTERVAL);
              }, DAS_DELAY);
            }
          }
        });

        document.addEventListener('keyup', (e) => {
          this.keysPressed[e.key] = false;
          if (this.dasTimers[e.key]) { clearTimeout(this.dasTimers[e.key]); delete this.dasTimers[e.key]; }
          if (this.dasIntervals[e.key]) { clearInterval(this.dasIntervals[e.key]); delete this.dasIntervals[e.key]; }
        });
      }

      handleMovement(key) {
        switch(key) {
          case 'ArrowLeft': this.movePiece(-1, 0); break;
          case 'ArrowRight': this.movePiece(1, 0); break;
          case 'ArrowDown':
            if (this.movePiece(0, 1)) this.lastFallTime = Date.now();
            break;
        }
      }

      gameLoop() {
        const now = Date.now();
        if (!this.gameOver && !this.isPaused && !this.dropLock && now - this.lastFallTime > this.fallSpeed) {
          if (!this.movePiece(0, 1)) this.lockPiece();
          this.lastFallTime = now;
        }
        this.updateParticles();
        requestAnimationFrame(() => this.gameLoop());
      }

      render() {
        const board = document.getElementById('gameBoard');
        board.innerHTML = '';
        board.style.gridTemplateColumns = `repeat(${BOARD_WIDTH}, ${CELL_SIZE}px)`;

        for (let y = 0; y < BOARD_HEIGHT; y++) {
          for (let x = 0; x < BOARD_WIDTH; x++) {
            const cell = document.createElement('div');
            cell.className = 'cell';

            let isCurrentPiece = false;
            let isGhost = false;
            let pieceColor = null;

            if (this.currentPiece) {
              for (let py = 0; py < this.currentPiece.shape.length; py++) {
                for (let px = 0; px < this.currentPiece.shape[py].length; px++) {
                  if (this.currentPiece.shape[py][px]) {
                    if (this.currentPos.x + px === x && this.currentPos.y + py === y) {
                      isCurrentPiece = true;
                      pieceColor = COLORS[this.currentPiece.type];
                    }
                    if (this.ghostPos !== null && this.currentPos.x + px === x && this.ghostPos + py === y) {
                      isGhost = true;
                    }
                  }
                }
              }
            }

            if (isCurrentPiece) {
              cell.style.backgroundColor = pieceColor;
              cell.style.boxShadow = `0 0 12px ${pieceColor}, inset 0 0 8px ${pieceColor}40`;
            } else if (isGhost && !this.board[y][x]) {
              cell.style.backgroundColor = 'var(--ghost-bg)';
              cell.style.border = `2px dashed var(--ghost-border)`;
            } else if (this.board[y][x]) {
              const color = COLORS[this.board[y][x]];
              cell.style.backgroundColor = color;
              cell.style.boxShadow = `0 0 6px ${color}40`;
            } else {
              cell.style.backgroundColor = '#0a0a0a';
            }

            if (this.clearingLines.includes(y) && this.board[y][x]) {
              const type = this.board[y][x];
              const color = COLORS[type];
              cell.style.setProperty('--cell-color', color);
              cell.classList.add('clearing');
            }

            board.appendChild(cell);
          }
        }

        this.renderHold();
        this.renderNext();
      }

      renderHold() {
        const holdBox = document.getElementById('holdBox');
        holdBox.innerHTML = '';
        if (this.heldPiece) {
          const preview = this.createPiecePreview(this.heldPiece, 20);
          holdBox.appendChild(preview);
        }
      }

      renderNext() {
        const container = document.getElementById('nextPieces');
        container.innerHTML = '';
        this.nextPieces.slice(0, 3).forEach((piece, i) => {
          const box = document.createElement('div');
          box.className = 'preview-box next-preview';
          box.style.opacity = (1 - (i * 0.25)).toString();
          box.style.transform = 'scale(' + (1 - (i * 0.1)) + ')';
          const preview = this.createPiecePreview(piece, 20);
          box.appendChild(preview);
          container.appendChild(box);
        });
      }

      createPiecePreview(piece, size) {
        const container = document.createElement('div');
        container.style.display = 'inline-block';
        piece.shape.forEach(function(row) {
          const rowDiv = document.createElement('div');
          rowDiv.style.display = 'flex';
          row.forEach(function(cell) {
            const cellDiv = document.createElement('div');
            cellDiv.style.width = size + 'px';
            cellDiv.style.height = size + 'px';
            cellDiv.style.border = cell ? '1px solid rgba(255,255,255,0.3)' : 'none';
            cellDiv.style.backgroundColor = cell ? COLORS[piece.type] : 'transparent';
            cellDiv.style.borderRadius = '2px';
            if (cell) cellDiv.style.boxShadow = '0 0 ' + (size/4) + 'px ' + COLORS[piece.type] + '40';
            rowDiv.appendChild(cellDiv);
          });
          container.appendChild(rowDiv);
        });
        return container;
      }

      updateDisplay() {
        document.getElementById('score').textContent = this.score;
        document.getElementById('level').textContent = this.level;
        document.getElementById('lines').textContent = this.lines;

        const scoreEl = document.getElementById('score').parentElement;
        const levelEl = document.getElementById('level').parentElement;
        const linesEl = document.getElementById('lines').parentElement;

        scoreEl.animate([{ transform: 'scale(1)' }, { transform: 'scale(1.04)' }, { transform: 'scale(1)' }], { duration: 170 });
        levelEl.animate([{ transform: 'scale(1)' }, { transform: 'scale(1.02)' }, { transform: 'scale(1)' }], { duration: 170 });
        linesEl.animate([{ transform: 'scale(1)' }, { transform: 'scale(1.02)' }, { transform: 'scale(1)' }], { duration: 170 });
      }

      updateReactiveBackground(initial = false) {
        const root = document.documentElement;
        const speed = Math.max(7.5, 16 - (this.level - 1) * 1.1);
        root.style.setProperty('--bg-speed', `${speed}s`);

        const accent1 = getComputedStyle(root).getPropertyValue('--accent1').trim();
        const accent2 = getComputedStyle(root).getPropertyValue('--accent2').trim();

        const intensity = Math.min(1, 0.055 * (this.level - 1));
        const bg1 = this.mixColor(getComputedStyle(root).getPropertyValue('--bg1').trim(), accent1, intensity);
        const bg2 = this.mixColor(getComputedStyle(root).getPropertyValue('--bg2').trim(), accent2, intensity * 0.7);
        const bg3 = this.mixColor(getComputedStyle(root).getPropertyValue('--bg3').trim(), accent1, intensity * 0.5);
        
        root.style.setProperty('--bg1', bg1);
        root.style.setProperty('--bg2', bg2);
        root.style.setProperty('--bg3', bg3);

        if (initial) {
          root.style.setProperty('--reactive-brightness', '1');
          root.style.setProperty('--reactive-sat', '105%');
          root.style.setProperty('--reactive-hue', '0deg');
        }
      }

      flashBackground(type, magnitude = 1) {
        const root = document.documentElement;
        const originalSpeed = getComputedStyle(root).getPropertyValue('--bg-speed').trim();
        const originalGlow = getComputedStyle(root).getPropertyValue('--board-glow').trim();

        let boostB = 1.18;
        let boostS = 112;
        let hue = 0;
        let blur = '0px';
        let speedBoost = 0.7;
        let glow = originalGlow;
        let uiScale = 1;

        switch (type) {
          case 'clear':   boostB = 1.22; boostS = 115; hue = 18;  blur = '0.8px'; speedBoost = 0.6; glow = 'rgba(255,255,255,0.6)'; uiScale = 1.012; break;
          case 'tetris':  boostB = 1.26; boostS = 118; hue = 42;  blur = '1.2px'; speedBoost = 0.5; glow = 'rgba(255,0,255,0.7)'; uiScale = 1.018; break;
          case 'perfect': boostB = 1.28; boostS = 120; hue = 120; blur = '1.4px'; speedBoost = 0.48; glow = 'rgba(0,240,240,0.8)'; uiScale = 1.02;  break;
          case 'gameover':boostB = 1.24; boostS = 108; hue = -22; blur = '1px';   speedBoost = 0.65; glow = 'rgba(255,0,0,0.7)'; uiScale = 0.985; break;
          default: return;
        }

        if (this.comfortMode) {
          const cap = parseFloat(getComputedStyle(root).getPropertyValue('--comfort-brightness-cap')) || 1.3;
          boostB = Math.min(boostB, cap);
        }

        root.style.setProperty('--reactive-brightness', boostB.toString());
        root.style.setProperty('--reactive-sat', `${boostS}%`);
        root.style.setProperty('--reactive-hue', `${hue}deg`);
        root.style.setProperty('--reactive-blur', blur);

        const newSpeed = `calc(${originalSpeed} * ${speedBoost})`;
        root.style.setProperty('--bg-speed', newSpeed);
        root.style.setProperty('--board-glow', glow);
        root.style.setProperty('--ui-scale', uiScale.toString());

        const duration = parseFloat(getComputedStyle(root).getPropertyValue('--comfort-duration')) || 360;

        setTimeout(() => {
          root.style.setProperty('--reactive-brightness', '1');
          root.style.setProperty('--reactive-sat', '105%');
          root.style.setProperty('--reactive-hue', '0deg');
          root.style.setProperty('--reactive-blur', '0px');
          root.style.setProperty('--bg-speed', originalSpeed);
          root.style.setProperty('--board-glow', originalGlow);
          root.style.setProperty('--ui-scale', '1');
        }, duration);
      }

      mixColor(color1, color2, t) {
        const a = this.parseColor(color1);
        const b = this.parseColor(color2);
        const r = Math.round(a.r + (b.r - a.r) * t);
        const g = Math.round(a.g + (b.g - a.g) * t);
        const b2 = Math.round(a.b + (b.b - a.b) * t);
        return `rgb(${r}, ${g}, ${b2})`;
      }

      parseColor(color) {
        if (color.startsWith('#')) {
          const h = color.replace('#', '');
          const bigint = parseInt(h, 16);
          if (h.length === 6) {
            return { r: (bigint >> 16) & 255, g: (bigint >> 8) & 255, b: bigint & 255 };
          }
          const r = parseInt(h[0] + h[0], 16);
          const g = parseInt(h[1] + h[1], 16);
          const b = parseInt(h[2] + h[2], 16);
          return { r, g, b };
        } else if (color.startsWith('rgb')) {
          const match = color.match(/\d+/g);
          return { r: parseInt(match[0]), g: parseInt(match[1]), b: parseInt(match[2]) };
        }
        return { r: 0, g: 0, b: 0 };
      }
    }

    window.addEventListener('DOMContentLoaded', () => {
      window.game = new TetrisGame();
      document.getElementById('updateLogModal').addEventListener('click', (e) => { if (e.target.id === 'updateLogModal') toggleUpdateLog(); });
      document.getElementById('settingsModal').addEventListener('click', (e) => { if (e.target.id === 'settingsModal') toggleSettings(); });
    });
  </script>
</body>
</html>
