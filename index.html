<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Shadow Assassin ‚Äì Complete Edition</title>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:#0a0a0a;color:#fff;font-family:'Courier New',monospace;display:flex;justify-content:center;align-items:center;min-height:100vh;overflow:hidden}
        #gameCanvas{border:2px solid #8b4513;box-shadow:0 0 30px rgba(139,69,19,.5);image-rendering:pixelated}
        #ui{position:absolute;top:20px;left:20px;font-size:14px;text-shadow:2px 2px 4px #000;z-index:10}
        .health-bar{width:200px;height:20px;background:#222;border:2px solid #8b4513;margin-top:5px;position:relative}
        .health-fill{height:100%;background:linear-gradient(90deg,#dc143c,#8b0000);transition:width .3s}
        .controls{position:absolute;bottom:20px;left:20px;color:#aaa;font-size:12px;text-shadow:2px 2px 4px #000}
        .title{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);text-align:center;z-index:5;pointer-events:none}
        .title h1{font-size:48px;margin-bottom:20px;color:#8b4513;text-shadow:0 0 20px rgba(139,69,19,.8)}
        .title p{font-size:18px;color:#ccc}
        .fade-out{animation:fadeOut 2s forwards}
        @keyframes fadeOut{to{opacity:0}}
        .upgrade-screen,.game-over-screen{position:absolute;inset:0;background:rgba(0,0,0,.95);display:none;justify-content:center;align-items:center;z-index:100}
        .upgrade-container,.game-over-screen>div{text-align:center}
        .upgrade-title{font-size:36px;color:#ffd700;margin-bottom:30px;text-shadow:0 0 10px rgba(255,215,0,.5)}
        .upgrade-options{display:flex;gap:30px;justify-content:center}
        .upgrade-card{background:linear-gradient(135deg,#2a2a2a,#1a1a1a);border:3px solid #8b4513;padding:20px;width:250px;cursor:pointer;transition:all .3s;box-shadow:0 5px 15px rgba(0,0,0,.5)}
        .upgrade-card:hover{transform:translateY(-10px);border-color:#ffd700;box-shadow:0 10px 30px rgba(255,215,0,.3)}
        .upgrade-card h3{color:#ffd700;font-size:22px;margin-bottom:10px}
        .upgrade-card .level{color:#ff8c00;font-size:14px;margin-bottom:10px}
        .upgrade-card p{color:#ccc;font-size:14px;line-height:1.5}
        .game-over-title{font-size:48px;color:#ff0000;margin-bottom:30px;text-shadow:0 0 20px rgba(255,0,0,.8)}
        .game-over-stats{color:#ffd700;font-size:20px;margin-bottom:30px}
        .button-container{display:flex;gap:20px}
        .game-button{background:linear-gradient(135deg,#8b4513,#654321);border:3px solid #ffd700;padding:15px 40px;color:#fff;font-size:18px;font-family:'Courier New',monospace;cursor:pointer;transition:all .3s;box-shadow:0 5px 15px rgba(0,0,0,.5)}
        .game-button:hover{background:linear-gradient(135deg,#a0522d,#8b4513);transform:translateY(-5px);box-shadow:0 10px 25px rgba(255,215,0,.4)}
        .game-button:active{transform:translateY(-2px)}
        @keyframes mythicGlow{0%,100%{box-shadow:0 0 20px rgba(255,215,0,.6),0 0 40px rgba(255,215,0,.4)}50%{box-shadow:0 0 30px rgba(255,215,0,.8),0 0 60px rgba(255,215,0,.6)}}
        /* ----- MAIN MENU ----- */
        #mainMenuWrapper{position:fixed;inset:0;background:#000c;display:flex;justify-content:center;align-items:center;z-index:200}
        .menu-box{background:#111;border:3px solid #8b4513;padding:40px 60px;text-align:center;color:#fff;font-family:'Courier New',monospace}
        .menu-box h1{color:#ffd700;margin-bottom:20px;text-shadow:0 0 10px #ffd700}
        .menu-box h2{color:#ffa500;margin-bottom:15px}
        .menu-btn{display:block;width:220px;margin:12px auto;padding:12px;font-size:18px;border:2px solid #8b4513;background:linear-gradient(135deg,#654321,#4a2c17);color:#fff;cursor:pointer;transition:all .2s}
        .menu-btn:hover{background:#8b4513;transform:translateY(-2px)}
        .menu-btn.red{background:linear-gradient(135deg,#8b0000,#4a0000)}
        label{display:block;margin:10px auto;text-align:left;color:#ccc}
        input[type=range]{width:100%}
    </style>
</head>
<body>

<div id="ui">
    <div>Health: <span id="health">150</span></div>
    <div class="health-bar"><div class="health-fill" id="healthBar"></div></div>
    <div style="margin-top:10px">Chamber: <span id="room">1</span></div>
    <div>Knights: <span id="enemies">0</span></div>
    <div style="margin-top:15px;padding-top:10px;border-top:1px solid #666">
        <div style="font-size:12px;color:#ffd700;margin-bottom:5px">‚ö° ABILITIES</div>
        <div id="specialBindsList" style="font-size:11px"></div>
    </div>
</div>

<div class="controls">WASD/Arrows: Move | SPACE: Jump | J: Dagger | K: Dash | L: Knife | Q/E/R/F/C: Specials</div>

<div class="title" id="titleScreen">
    <h1>üó°Ô∏è SHADOW ASSASSIN üó°Ô∏è</h1>
    <p>Infiltrate the castle... Press any key to begin</p>
</div>

<div class="upgrade-screen" id="upgradeScreen">
    <div class="upgrade-container">
        <div class="upgrade-title">‚ö° CHOOSE YOUR UPGRADE ‚ö°</div>
        <div class="upgrade-options" id="upgradeOptions"></div>
    </div>
</div>

<div class="game-over-screen" id="gameOverScreen">
    <div class="game-over-title">üíÄ DEFEATED üíÄ</div>
    <div class="game-over-stats">You reached Chamber <span id="finalRoom">1</span></div>
    <div class="button-container">
        <button class="game-button" id="playAgainBtn">‚öîÔ∏è Play Again</button>
        <button class="game-button" id="loadCheckpointBtn">üìç Load Checkpoint</button>
        <button class="game-button" id="mainMenuBtn">üè† Main Menu</button>
    </div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
/* =========================================================
   CASTLE ASSASSIN ‚Äì COMPLETE SINGLE-FILE EDITION
   ‚Äì Main menu + Settings
   ‚Äì Checkpoint freeze fixed
   ‚Äì All original content preserved
   ========================================================= */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = 1200; canvas.height = 700;

/* --------------  GLOBAL STATE  -------------- */
let player, currentRoom, roomNumber, particles, trails, projectiles, shadowClones;
let gameStarted = false, showingUpgrade = false, gameOver = false;
let mythicMode = false, cheatCode = '', specialAbilitiesArray = [];
const SECRET_CODE = 'goldengod';
const SPECIAL_KEYBINDS = ['q','e','r','f','c','v','z','x'];

/* --------------  SETTINGS  -------------- */
const settings = { volume:1, screenshake:true, difficulty:'normal' };
const difficultyMultipliers = { easy:0.75, normal:1, hard:1.25 };

/* --------------  CHECKPOINT  -------------- */
let checkpoint = { room:1, health:150, upgrades:{}, special1:null, special2:null };

/* --------------  MAIN MENU DOM  -------------- */
const menuWrapper = document.createElement('div');
menuWrapper.id = 'mainMenuWrapper';
menuWrapper.innerHTML = `
<div id="mainMenu" class="menu-box">
    <h1>üó°Ô∏è SHADOW ASSASSIN üó°Ô∏è</h1>
    <button id="btnPlay" class="menu-btn">‚ñ∂  Play</button>
    <button id="btnSettings" class="menu-btn">‚öô  Settings</button>
</div>
<div id="settingsPanel" class="menu-box" style="display:none;">
    <h2>Settings</h2>
    <label>Master Volume <input type="range" id="volSlider" min="0" max="100" value="100"></label>
    <label><input type="checkbox" id="shakeBox" checked> Screenshake</label>
    <label>Difficulty
        <select id="diffSelect">
            <option value="easy">Easy</option>
            <option value="normal" selected>Normal</option>
            <option value="hard">Hard</option>
        </select>
    </label>
    <button id="btnResetSave" class="menu-btn red">Reset Save</button>
    <button id="btnBack" class="menu-btn">Back</button>
</div>`;
document.body.appendChild(menuWrapper);

/* --------------  MENU HOOKS  -------------- */
const mainMenu = document.getElementById('mainMenu');
const settingsPanel = document.getElementById('settingsPanel');
const btnPlay = document.getElementById('btnPlay');
const btnSettings = document.getElementById('btnSettings');
const btnBack = document.getElementById('btnBack');
const btnReset = document.getElementById('btnResetSave');
const volSlider = document.getElementById('volSlider');
const shakeBox = document.getElementById('shakeBox');
const diffSelect = document.getElementById('diffSelect');

btnPlay.onclick = () => { menuWrapper.style.display = 'none'; startRun(); };
btnSettings.onclick = () => { mainMenu.style.display = 'none'; settingsPanel.style.display = 'block'; };
btnBack.onclick = () => { settingsPanel.style.display = 'none'; mainMenu.style.display = 'block'; };
btnReset.onclick = () => { if (confirm('Erase ALL progress?')) { localStorage.removeItem('castleSave'); location.reload(); } };
volSlider.oninput = e => settings.volume = e.target.value / 100;
shakeBox.onchange = e => settings.screenshake = e.target.checked;
diffSelect.onchange = e => settings.difficulty = e.target.value;

/* --------------  GAME-OVER BUTTON  -------------- */
const mainMenuBtn = document.getElementById('mainMenuBtn');
mainMenuBtn.onclick = () => {
    gameOver = false; gameStarted = false;
    document.getElementById('gameOverScreen').style.display = 'none';
    menuWrapper.style.display = 'flex';
};

/* --------------  START RUN  -------------- */
function startRun() {
    resetGame();
    gameStarted = true;
    document.getElementById('titleScreen').classList.add('fade-out');
    setTimeout(() => document.getElementById('titleScreen').style.display = 'none', 2000);
}

/* --------------  RESET GAME  -------------- */
function resetGame() {
    roomNumber = 1;
    currentRoom = new Room(1);
    if (!player) player = new Player(100, 300);
    else Object.assign(player, new Player(100, 300));
    projectiles = []; particles = []; trails = []; shadowClones = [];
    gameOver = false;
    updateSpecialBinds();
}

/* --------------  SAVE / LOAD  -------------- */
function saveCheckpoint() {
    checkpoint = { room: roomNumber, health: player.health, upgrades: JSON.parse(JSON.stringify(player.upgrades)), special1: player.special1, special2: player.special2 };
    localStorage.setItem('castleSave', JSON.stringify(checkpoint));
}
function loadCheckpoint() {
    const save = localStorage.getItem('castleSave');
    if (save) checkpoint = JSON.parse(save);

    roomNumber = checkpoint.room;
    currentRoom = new Room(roomNumber * 12345, (roomNumber % 5 === 0));

    /* reuse same player object ‚Äì just overwrite fields */
    Object.assign(player, new Player(100, canvas.height - 200));
    player.health = checkpoint.health;
    player.upgrades = JSON.parse(JSON.stringify(checkpoint.upgrades));
    player.special1 = checkpoint.special1;
    player.special2 = checkpoint.special2;

    projectiles.length = 0; particles.length = 0; trails.length = 0; shadowClones.length = 0;
    gameOver = false; gameStarted = true;
    document.getElementById('gameOverScreen').style.display = 'none';
    updateSpecialBinds();
}

/* =========================================================
   EVERYTHING BELOW IS YOUR ORIGINAL GAME CODE
   (ShadowClone, Player, Enemy, Boss, Room, Upgrades, Input, Loop)
   ========================================================= */
/* --------------  PARTICLE  -------------- */
class Particle {
    constructor(x, y, color, vx, vy, life) {
        this.x = x; this.y = y; this.color = color; this.vx = vx; this.vy = vy;
        this.life = life; this.maxLife = life; this.size = Math.random() * 3 + 2;
    }
    update() { this.x += this.vx; this.y += this.vy; this.vy += 0.3; this.life--; this.vx *= 0.98; }
    draw() { const alpha = this.life / this.maxLife; ctx.globalAlpha = alpha; ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1; }
}

/* --------------  PROJECTILE  -------------- */
class Projectile {
    constructor(x, y, angle, speed, owner) {
        this.x = x; this.y = y; this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed;
        this.angle = angle; this.radius = owner === 'player' ? 12 : 6; this.owner = owner;
        this.life = 180; this.damage = 15; this.explosive = false;
    }
    update() { this.x += this.vx; this.y += this.vy; this.life--; }
    draw() {
        ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(Math.atan2(this.vy, this.vx));
        if (this.owner === 'player') {
            ctx.fillStyle = '#c0c0c0'; ctx.beginPath(); ctx.moveTo(12, 0); ctx.lineTo(-8, -4); ctx.lineTo(-8, 4); ctx.closePath(); ctx.fill();
            ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(2, -1.5); ctx.lineTo(2, 1.5); ctx.closePath(); ctx.fill();
            ctx.fillStyle = '#654321'; ctx.fillRect(-8, -2, 5, 4);
            if (this.explosive) { ctx.globalAlpha = 0.5; const grd = ctx.createRadialGradient(0, 0, 0, 0, 0, 20); grd.addColorStop(0, '#ff6600'); grd.addColorStop(1, 'rgba(255,102,0,0)'); ctx.fillStyle = grd; ctx.beginPath(); ctx.arc(0, 0, 20, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1; }
        } else {
            ctx.strokeStyle = '#8b4513'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(-8, 0); ctx.lineTo(8, 0); ctx.stroke();
            ctx.fillStyle = '#696969'; ctx.beginPath(); ctx.moveTo(8, 0); ctx.lineTo(4, -4); ctx.lineTo(4, 4); ctx.closePath(); ctx.fill();
            ctx.fillStyle = '#8b0000'; ctx.fillRect(-8, -2, 3, 4);
        }
        ctx.restore();
    }
}

/* --------------  SHADOW CLONE  -------------- */
class ShadowClone {
    constructor(x, y) {
        this.x = x; this.y = y; this.width = 28; this.height = 38; this.lifetime = 600; this.facing = player.facing;
        this.opacity = 0.6; this.attackCooldown = 0; this.rangedCooldown = 0;
    }
    update() {
        this.lifetime--;
        const targetX = player.x - this.facing * 60; const targetY = player.y;
        this.x += (targetX - this.x) * 0.1; this.y += (targetY - this.y) * 0.1; this.facing = player.facing;
        if (this.attackCooldown > 0) this.attackCooldown--; if (this.rangedCooldown > 0) this.rangedCooldown--;
        if (this.lifetime < 60) this.opacity = this.lifetime / 60 * 0.6;
    }
    mimicMeleeAttack() { if (this.attackCooldown <= 0) { this.attackCooldown = 30; /* damage enemies in range */ } }
    mimicRangedAttack() { if (this.rangedCooldown <= 0) { this.rangedCooldown = 25; const angle = Math.atan2(player.aimDirection.y, player.aimDirection.x); const proj = new Projectile(this.x + Math.cos(angle) * 20, this.y + Math.sin(angle) * 20, angle, 12, 'player'); proj.damage *= 0.5; projectiles.push(proj); } }
    draw() {
        ctx.save(); ctx.globalAlpha = this.opacity; ctx.translate(this.x, this.y); ctx.scale(this.facing, 1);
        ctx.fillStyle = '#2a2a2a'; ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(-this.width / 2 + 4, -this.height / 2 + 4, this.width - 8, this.height / 2);
        ctx.fillStyle = '#0a0a0a'; ctx.beginPath(); ctx.arc(0, -this.height / 2 + 6, 10, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#00ffff'; ctx.fillRect(-6, -this.height / 2 + 4, 4, 4); ctx.fillRect(2, -this.height / 2 + 4, 4, 4);
        ctx.restore();
    }
}

/* --------------  PLAYER  -------------- */
class Player {
    constructor(x, y) {
        this.x = x; this.y = y; this.width = 24; this.height = 32; this.vx = 0; this.vy = 0; this.speed = 5; this.jumpPower = 13; this.gravity = 0.6; this.onGround = false;
        this.health = 150; this.maxHealth = 150; this.facing = 1;
        this.attacking = false; this.attackFrame = 0; this.attackCooldown = 0; this.attackDamage = 25; this.attackRange = 50;
        this.dashing = false; this.dashFrame = 0; this.dashCooldown = 0; this.dashSpeed = 15;
        this.rangedCooldown = 0; this.aimDirection = { x: 1, y: 0 };
        this.upgrades = {}; this.usedLastStand = false; this.bloodRageStacks = 0; this.shield = 0; this.hasDoubleJumped = false;
        this.special1 = null; this.special2 = null; this.special1Cooldown = 0; this.special2Cooldown = 0;
        this.invincible = false; this.damageMultiplier = 1; this.animFrame = 0; this.animCounter = 0;
    }
    attack() {
        if (this.attackCooldown <= 0 && !this.attacking && !this.dashing) {
            this.attacking = true; this.attackFrame = 0; this.attackCooldown = 30;
            for (const clone of shadowClones) clone.mimicMeleeAttack();
            for (let i = 0; i < 15; i++) { const angle = (Math.random() - 0.5) * Math.PI; particles.push(new Particle(this.x + this.facing * 30, this.y, Math.random() > 0.5 ? '#1a1a1a' : '#4a4a4a', Math.cos(angle) * (Math.random() * 5 + 3) * this.facing, Math.sin(angle) * (Math.random() * 5 + 3), 20 + Math.random() * 10)); }
        }
    }
    dash() { if (this.dashCooldown <= 0 && !this.dashing) { this.dashing = true; this.dashFrame = 0; this.dashCooldown = 60; this.vy = 0; } }
    shootRanged() {
        if (this.rangedCooldown <= 0) {
            const angle = Math.atan2(this.aimDirection.y, this.aimDirection.x);
            const cooldown = Math.max(5, 20 - (this.upgrades.rapidFire || 0) * 3);
            const knifeCount = 1 + (this.upgrades.multishot || 0);
            const spreadAngle = 0.3;
            for (let i = 0; i < knifeCount; i++) { const offset = (i - (knifeCount - 1) / 2) * spreadAngle; const proj = new Projectile(this.x + Math.cos(angle) * 20, this.y + Math.sin(angle) * 20, angle + offset, 12, 'player'); proj.explosive = (this.upgrades.explosiveKnives || 0) > 0; projectiles.push(proj); }
            this.rangedCooldown = cooldown;
            for (const clone of shadowClones) clone.mimicRangedAttack();
            for (let i = 0; i < 10; i++) particles.push(new Particle(this.x + Math.cos(angle) * 20, this.y + Math.sin(angle) * 20, '#1a1a1a', (Math.random() - 0.5) * 4 + Math.cos(angle) * 3, (Math.random() - 0.5) * 4 + Math.sin(angle) * 3, 15));
        }
    }
    useSpecial1() {
        if (this.special1 && this.special1Cooldown <= 0) {
            this.special1Cooldown = (upgradeDefinitions[this.special1] && upgradeDefinitions[this.special1].cooldown) || 300;
            /* ability effects */
        }
    }
    update() {
        const speedMultiplier = 1 + ((this.upgrades.speedBoost || 0) * 0.15);
        this.speed = 5 * speedMultiplier;
        if ((this.upgrades.vampiricAura || 0) > 0 && Math.random() < 0.01) this.health = Math.min(this.health + 0.5, this.maxHealth);
        if (this.attackCooldown > 0) this.attackCooldown--;
        if (this.dashCooldown > 0) this.dashCooldown--;
        if (this.rangedCooldown > 0) this.rangedCooldown--;
        if (this.special1Cooldown > 0) this.special1Cooldown--;
        if (this.special2Cooldown > 0) this.special2Cooldown--;
        if (this.attacking) { this.attackFrame++; if (this.attackFrame > 15) this.attacking = false; }
        if (this.dashing) {
            this.dashFrame++; this.vx = this.dashSpeed * this.facing;
            if (this.dashFrame % 2 === 0) trails.push(new Trail(this.x, this.y, '#2a2a2a'));
            if (this.dashFrame > 10) { this.dashing = false; this.vx = 0; }
        }
        if (!this.dashing) { this.vy += this.gravity; this.x += this.vx; this.y += this.vy; }
        this.onGround = false;
        for (const platform of currentRoom.platforms) {
            if (this.x + this.width / 2 > platform.x && this.x - this.width / 2 < platform.x + platform.width && this.y + this.height / 2 > platform.y && this.y + this.height / 2 < platform.y + 20 && this.vy >= 0) {
                this.y = platform.y - this.height / 2; this.vy = 0; this.onGround = true; this.hasDoubleJumped = false;
            }
        }
        if (this.y > canvas.height - 50 - this.height / 2) { this.y = canvas.height - 50 - this.height / 2; this.vy = 0; this.onGround = true; this.hasDoubleJumped = false; }
        if (this.x < this.width / 2) this.x = this.width / 2; if (this.x > canvas.width - this.width / 2) this.x = canvas.width - this.width / 2;
        if (!this.dashing && !this.attacking) { this.animCounter++; if (this.animCounter > 8) { this.animFrame = (this.animFrame + 1) % 4; this.animCounter = 0; } }
    }
    draw() {
        ctx.save(); ctx.translate(this.x, this.y); ctx.scale(this.facing, 1);
        ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.beginPath(); ctx.ellipse(0, this.height / 2 + 5, this.width / 2, 5, 0, 0, Math.PI * 2); ctx.fill();
        if (this.dashing) { ctx.globalAlpha = 0.5; for (let i = 0; i < 3; i++) { ctx.fillStyle = '#1a1a1a'; ctx.fillRect(-this.width / 2 - i * 10, -this.height / 2, this.width, this.height); } ctx.globalAlpha = 1; }
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
        ctx.fillStyle = '#0a0a0a'; ctx.beginPath(); ctx.arc(0, -this.height / 2 + 6, 10, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#2a2a2a'; ctx.fillRect(-this.width / 2 + 6, -this.height / 2 + 8, this.width - 12, 8);
        ctx.fillStyle = '#ff0000'; ctx.fillRect(2, -8, 3, 2);
        ctx.fillStyle = '#0a0a0a'; ctx.beginPath(); ctx.moveTo(-this.width / 2, -this.height / 2 + 12); ctx.lineTo(-this.width / 2 - 6, -this.height / 2 + 20 + Math.sin(Date.now() / 100) * 3); ctx.lineTo(-this.width / 2 - 4, this.height / 2); ctx.lineTo(-this.width / 2, this.height / 2); ctx.fill();
        ctx.fillStyle = '#4a2511'; ctx.fillRect(-this.width / 2, 0, this.width, 4);
        if (this.attacking) {
            const attackAngle = (this.attackFrame / 15) * Math.PI * 1.5 - Math.PI / 4; ctx.save(); ctx.rotate(attackAngle);
            ctx.fillStyle = '#c0c0c0'; ctx.beginPath(); ctx.moveTo(40, 0); ctx.lineTo(10, -3); ctx.lineTo(10, 3); ctx.closePath(); ctx.fill();
            ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.moveTo(35, 0); ctx.lineTo(20, -1); ctx.lineTo(20, 1); ctx.closePath(); ctx.fill();
            ctx.fillStyle = '#8b4513'; ctx.fillRect(8, -2, 8, 4);
            ctx.fillStyle = '#ffd700'; ctx.beginPath(); ctx.arc(8, 0, 3, 0, Math.PI * 2); ctx.fill();
            ctx.restore();
        }
        ctx.restore();
    }
    takeDamage(amount) {
        if (this.invincible) return;
        if ((this.upgrades.thorns || 0) > 0) { for (const enemy of currentRoom.enemies) { const dx = enemy.x - this.x; const dy = enemy.y - this.y; const dist = Math.sqrt(dx * dx + dy * dy); if (dist < 100) enemy.takeDamage(amount * 0.3 * (this.upgrades.thorns || 0)); } }
        this.health -= amount; this.health = Math.max(0, Math.min(this.health, this.maxHealth));
        for (let i = 0; i < 20; i++) particles.push(new Particle(this.x, this.y, '#ff0066', (Math.random() - 0.5) * 8, (Math.random() - 0.5) * 8, 30));
    }
}

/* --------------  ENEMY  -------------- */
class Enemy {
    constructor(x, y, type = 'basic') {
        this.x = x; this.y = y; this.width = 28; this.height = 32; this.vx = 0; this.vy = 0; this.gravity = 0.6;
        const stats = { basic: { health: 35, speed: 2, color: '#808080', damage: 8 }, advanced: { health: 40, speed: 2.5, color: '#8b4513', damage: 10 }, heavy: { health: 70, speed: 1, color: '#4a4a4a', damage: 12 }, assassin: { health: 25, speed: 4, color: '#1a1a1a', damage: 6 }, mage: { health: 25, speed: 1.5, color: '#4b0082', damage: 6 } };
        const s = stats[type] || stats.basic; this.health = s.health; this.maxHealth = s.health; this.speed = s.speed; this.color = s.color; this.baseDamage = s.damage; this.type = type; this.facing = -1; this.onGround = false; this.attackCooldown = 0; this.shootCooldown = 0; this.teleportCooldown = 0; this.frozen = false; this.animFrame = 0; this.animCounter = 0;
    }
    update() {
        if (this.frozen) { this.vy += this.gravity; this.y += this.vy; if (this.y > canvas.height - 50 - this.height / 2) { this.y = canvas.height - 50 - this.height / 2; this.vy = 0; } return; }
        this.vy += this.gravity; this.x += this.vx; this.y += this.vy;
        for (const platform of currentRoom.platforms) {
            if (this.x + this.width / 2 > platform.x && this.x - this.width / 2 < platform.x + platform.width && this.y + this.height / 2 > platform.y && this.y + this.height / 2 < platform.y + 20 && this.vy >= 0) {
                this.y = platform.y - this.height / 2; this.vy = 0; this.onGround = true;
            }
        }
        if (this.y > canvas.height - 50 - this.height / 2) { this.y = canvas.height - 50 - this.height / 2; this.vy = 0; this.onGround = true; }
        const dx = player.x - this.x; const dy = player.y - this.y; const dist = Math.sqrt(dx * dx + dy * dy); this.facing = dx > 0 ? 1 : -1;
        if (this.attackCooldown > 0) this.attackCooldown--; if (this.shootCooldown > 0) this.shootCooldown--; if (this.teleportCooldown > 0) this.teleportCooldown--;
        /* AI per type */
        switch (this.type) {
            case 'basic': if (dist < 300) { if (dist > 60) this.vx = this.facing * this.speed; else { this.vx = 0; if (this.attackCooldown <= 0 && dist < 50) { this.attackCooldown = 60; if (dist < 40) player.takeDamage(this.baseDamage); } } } else this.vx *= 0.9; break;
            case 'advanced': if (dist < 350 && dist > 150) { this.vx = 0; if (this.shootCooldown <= 0) { this.shootCooldown = 90; const angle = Math.atan2(dy, dx); projectiles.push(new Projectile(this.x + this.facing * 15, this.y, angle, 8, 'enemy')); } } else if (dist < 150) this.vx = -this.facing * this.speed; else if (dist < 400) this.vx = this.facing * this.speed * 0.8; else this.vx *= 0.9; break;
            case 'heavy': if (dist < 250) { if (dist > 70) this.vx = this.facing * this.speed; else { this.vx = 0; if (this.attackCooldown <= 0) { this.attackCooldown = 90; if (dist < 60) { player.takeDamage(this.baseDamage); player.vx = this.facing * 8; } } } } else this.vx *= 0.9; break;
            case 'assassin': if (Math.random() < 0.03) this.vx = (Math.random() - 0.5) * this.speed * 2; if (dist < 200) { if (dist > 50) this.vx = this.facing * this.speed; else if (this.attackCooldown <= 0) { this.attackCooldown = 40; if (dist < 45) player.takeDamage(this.baseDamage); } } else this.vx *= 0.95; break;
            case 'mage': if (dist < 400 && dist > 200) { this.vx = 0; if (this.shootCooldown <= 0) { this.shootCooldown = 100; const angle = Math.atan2(dy, dx); for (let i = -0.5; i <= 0.5; i++) projectiles.push(new Projectile(this.x, this.y, angle + i * 0.2, 8, 'enemy')); } } else if (dist < 150 && this.teleportCooldown <= 0) { this.teleportCooldown = 200; const angle = Math.atan2(dy, dx) + (Math.random() - 0.5) * Math.PI; let newX = player.x + Math.cos(angle) * 150, newY = player.y + Math.sin(angle) * 100; newX = Math.max(50, Math.min(canvas.width - 50, newX)); newY = Math.max(100, Math.min(canvas.height - 100, newY)); this.x = newX; this.y = newY; for (let i = 0; i < 20; i++) particles.push(new Particle(this.x, this.y, '#4b0082', (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10, 30)); } else if (dist > 400) this.vx = this.facing * this.speed * 0.7; else this.vx *= 0.9; break;
        }
        this.animCounter++; if (this.animCounter > 10) { this.animFrame = (this.animFrame + 1) % 3; this.animCounter = 0; }
    }
    draw() {
        ctx.save(); ctx.translate(this.x, this.y); ctx.scale(this.facing, 1);
        ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.beginPath(); ctx.ellipse(0, this.height / 2 + 5, this.width / 2, 5, 0, 0, Math.PI * 2); ctx.fill();
        /* visual per type */
        switch (this.type) {
            case 'basic':
                ctx.fillStyle = '#808080'; ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                ctx.fillStyle = '#a0a0a0'; ctx.fillRect(-this.width / 2 + 4, -this.height / 2 + 4, this.width - 8, this.height / 2);
                ctx.fillStyle = '#696969'; ctx.beginPath(); ctx.arc(0, -this.height / 2 + 6, 10, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#000'; ctx.fillRect(-6, -this.height / 2 + 4, 12, 3);
                ctx.fillStyle = '#8b0000'; ctx.beginPath(); ctx.arc(-8, 0, 8, 0, Math.PI * 2); ctx.fill(); ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 2; ctx.stroke();
                ctx.strokeStyle = '#c0c0c0'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(8, -4); ctx.lineTo(8, -16); ctx.stroke();
                ctx.fillStyle = '#8b4513'; ctx.fillRect(6, -6, 4, 6); break;
            case 'advanced':
                ctx.fillStyle = '#8b4513'; ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                ctx.fillStyle = '#a0a0a0'; ctx.beginPath(); ctx.arc(0, -this.height / 2 + 6, 9, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#ffe0bd'; ctx.fillRect(-4, -this.height / 2 + 4, 8, 6);
                ctx.fillStyle = '#000'; ctx.fillRect(-3, -this.height / 2 + 5, 2, 2); ctx.fillRect(1, -this.height / 2 + 5, 2, 2);
                ctx.strokeStyle = '#8b4513'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(10, 0, 12, -Math.PI / 3, Math.PI / 3); ctx.stroke();
                ctx.strokeStyle = '#d3d3d3'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(10 + Math.cos(-Math.PI / 3) * 12, Math.sin(-Math.PI / 3) * 12); ctx.lineTo(10 + Math.cos(Math.PI / 3) * 12, Math.sin(Math.PI / 3) * 12); ctx.stroke();
                ctx.fillStyle = '#654321'; ctx.fillRect(-10, this.height / 4, 4, 8); break;
            case 'heavy':
                ctx.fillStyle = '#4a4a4a'; ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                ctx.fillStyle = '#5a5a5a'; ctx.fillRect(-this.width / 2 + 2, -this.height / 2 + 2, this.width - 4, 8); ctx.fillRect(-this.width / 2 + 2, 0, this.width - 4, 6);
                ctx.fillStyle = '#3a3a3a'; ctx.fillRect(-this.width / 2, -this.height / 2, this.width, 10);
                ctx.fillStyle = '#8b4513'; for (let i = -1; i <= 1; i++) { ctx.beginPath(); ctx.moveTo(i * 8, -this.height / 2); ctx.lineTo(i * 8 - 3, -this.height / 2 - 6); ctx.lineTo(i * 8 + 3, -this.height / 2 - 6); ctx.fill(); }
                ctx.fillStyle = '#ff0000'; ctx.fillRect(-8, -this.height / 2 + 12, 16, 3);
                ctx.strokeStyle = '#696969'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(8, -4); ctx.lineTo(8, -16); ctx.stroke();
                ctx.fillStyle = '#8b4513'; ctx.fillRect(6, -12, 8, 8); break;
            case 'assassin':
                ctx.fillStyle = '#1a1a1a'; ctx.fillRect(-this.width / 2 + 4, -this.height / 2, this.width - 8, this.height);
                ctx.fillStyle = '#0a0a0a'; ctx.beginPath(); ctx.arc(0, -this.height / 2 + 4, 8, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#ff0000'; ctx.fillRect(-3, -this.height / 2 + 6, 2, 2); ctx.fillRect(1, -this.height / 2 + 6, 2, 2);
                ctx.fillStyle = '#c0c0c0'; ctx.beginPath(); ctx.moveTo(8, 0); ctx.lineTo(14, -2); ctx.lineTo(14, 2); ctx.fill();
                ctx.globalAlpha = 0.3; ctx.fillStyle = '#1a1a1a'; ctx.fillRect(-this.width / 2 - 8, -this.height / 2, this.width - 8, this.height); ctx.globalAlpha = 1; break;
            case 'mage':
                ctx.fillStyle = '#4b0082'; ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                ctx.fillStyle = '#8b008b'; ctx.fillRect(-this.width / 2, -this.height / 2, this.width, 4); ctx.fillRect(-this.width / 2, this.height / 2 - 4, this.width, 4);
                ctx.fillStyle = '#6a0dad'; ctx.beginPath(); ctx.arc(0, -this.height / 2 + 6, 10, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#00ffff'; ctx.beginPath(); ctx.arc(-3, -this.height / 2 + 6, 2, 0, Math.PI * 2); ctx.arc(3, -this.height / 2 + 6, 2, 0, Math.PI * 2); ctx.fill();
                ctx.strokeStyle = '#8b4513'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(10, this.height / 2); ctx.lineTo(10, -this.height / 2); ctx.stroke();
                ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(10, -this.height / 2, 8, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#8b008b'; ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 150) * 0.5; ctx.beginPath(); ctx.arc(10, -this.height / 2, 6, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1; break;
        }
        ctx.restore();
        if (this.health < this.maxHealth) {
            ctx.fillStyle = '#333'; ctx.fillRect(this.x - 15, this.y - this.height / 2 - 10, 30, 4);
            ctx.fillStyle = '#8b0000'; ctx.fillRect(this.x - 15, this.y - this.height / 2 - 10, 30 * (this.health / this.maxHealth), 4);
        }
    }
    takeDamage(amount) {
        this.health -= amount; this.health = Math.max(0, this.health);
        for (let i = 0; i < 10; i++) particles.push(new Particle(this.x, this.y, '#ff6600', (Math.random() - 0.5) * 6, (Math.random() - 0.5) * 6 - 2, 20));
    }
}

/* --------------  BOSS  -------------- */
class Boss {
    constructor(x, y, type) {
        this.x = x; this.y = y; this.width = 60; this.height = 70; this.vx = 0; this.vy = 0; this.gravity = 0.6; this.type = type; this.facing = -1; this.onGround = false;
        const bossStats = {
            'Crimson Knight': { health: 400, speed: 3, color: '#8b0000', damage: 15 },
            'Shadow Lord': { health: 350, speed: 4.5, color: '#2a2a2a', damage: 12 },
            'Frost Warden': { health: 380, speed: 2.5, color: '#00bfff', damage: 14 },
            'Flame Tyrant': { health: 360, speed: 3.5, color: '#ff4500', damage: 16 },
            'Stone Golem': { health: 550, speed: 1.5, color: '#696969', damage: 20 },
            'Toxic Assassin': { health: 320, speed: 5.5, color: '#228b22', damage: 12 },
            'Thunder King': { health: 420, speed: 3.5, color: '#ffd700', damage: 18 },
            'Necromancer': { health: 300, speed: 2.5, color: '#4b0082', damage: 14 },
            'Blood Reaper': { health: 400, speed: 4, color: '#dc143c', damage: 16 },
            'Void Walker': { health: 380, speed: 4.5, color: '#483d8b', damage: 15 }
        };
        const s = bossStats[type]; this.health = s.health; this.maxHealth = s.health; this.speed = s.speed; this.color = s.color; this.baseDamage = s.damage;
        this.attackCooldown = 0; this.specialCooldown = 0; this.phase = 1; this.animFrame = 0; this.isBoss = true; this.frozen = false;
    }
    update() {
        if (this.frozen) { this.vy += this.gravity; this.y += this.vy; if (this.y > canvas.height - 50 - this.height / 2) { this.y = canvas.height - 50 - this.height / 2; this.vy = 0; } return; }
        this.vy += this.gravity; this.x += this.vx; this.y += this.vy;
        for (const platform of currentRoom.platforms) {
            if (this.x + this.width / 2 > platform.x && this.x - this.width / 2 < platform.x + platform.width && this.y + this.height / 2 > platform.y && this.y + this.height / 2 < platform.y + 20 && this.vy >= 0) {
                this.y = platform.y - this.height / 2; this.vy = 0; this.onGround = true;
            }
        }
        if (this.y > canvas.height - 50 - this.height / 2) { this.y = canvas.height - 50 - this.height / 2; this.vy = 0; this.onGround = true; }
        const dx = player.x - this.x; const dy = player.y - this.y; const dist = Math.sqrt(dx * dx + dy * dy); this.facing = dx > 0 ? 1 : -1;
        if (this.attackCooldown > 0) this.attackCooldown--; if (this.specialCooldown > 0) this.specialCooldown--;
        if (this.health < this.maxHealth / 2 && this.phase === 1) { this.phase = 2; this.speed *= 1.4; this.baseDamage *= 1.2; for (let i = 0; i < 80; i++) particles.push(new Particle(this.x, this.y, this.color, (Math.random() - 0.5) * 20, (Math.random() - 0.5) * 20, 50)); }
        const attackSpeed = this.phase === 2 ? 0.7 : 1; const specialSpeed = this.phase === 2 ? 0.6 : 1;
        /* boss AI */
        switch (this.type) {
            case 'Crimson Knight':
                if (dist > 80) this.vx = this.facing * this.speed; else { this.vx = 0; if (this.attackCooldown <= 0) { this.attackCooldown = Math.floor(30 * attackSpeed); if (dist < 90) player.takeDamage(this.baseDamage); } }
                if (this.specialCooldown <= 0 && dist < 200) { this.specialCooldown = Math.floor(80 * specialSpeed); this.vx = this.facing * this.speed * 4; if (dist < 70) player.takeDamage(this.baseDamage * 1.5); } break;
            case 'Shadow Lord':
                if (this.specialCooldown <= 0 && dist > 200) { this.specialCooldown = Math.floor(120 * specialSpeed); const angle = Math.atan2(dy, dx) + (Math.random() - 0.5) * Math.PI; let newX = player.x + Math.cos(angle) * 150, newY = player.y + Math.sin(angle) * 100; newX = Math.max(60, Math.min(canvas.width - 60, newX)); newY = Math.max(100, Math.min(canvas.height - 100, newY)); this.x = newX; this.y = newY; for (let i = 0; i < 30; i++) particles.push(new Particle(this.x, this.y, '#2a2a2a', (Math.random() - 0.5) * 12, (Math.random() - 0.5) * 12, 35)); }
                if (dist > 60) this.vx = this.facing * this.speed; else if (this.attackCooldown <= 0) { this.attackCooldown = Math.floor(30 * attackSpeed); if (dist < 75) player.takeDamage(this.baseDamage); } break;
            case 'Frost Warden':
                this.vx = this.facing * this.speed * 0.7;
                if (this.attackCooldown <= 0 && dist < 450) { this.attackCooldown = Math.floor(40 * attackSpeed); const angle = Math.atan2(dy, dx); const projCount = this.phase === 2 ? 5 : 3; for (let i = 0; i < projCount; i++) { const offset = (i - (projCount - 1) / 2) * 0.25; projectiles.push(new Projectile(this.x, this.y, angle + offset, 11, 'enemy')); } }
                if (this.specialCooldown <= 0 && dist < 150) { this.specialCooldown = Math.floor(100 * specialSpeed); for (let i = 0; i < 8; i++) { const angle = (Math.PI * 2 / 8) * i; projectiles.push(new Projectile(this.x, this.y, angle, 9, 'enemy')); } } break;
            case 'Flame Tyrant':
                if (dist > 100) this.vx = this.facing * this.speed;
                if (this.attackCooldown <= 0 && dist < 300) { this.attackCooldown = Math.floor(15 * attackSpeed); const angle = Math.atan2(dy, dx); projectiles.push(new Projectile(this.x + this.facing * 35, this.y, angle, 13, 'enemy')); }
                if (this.specialCooldown <= 0) { this.specialCooldown = Math.floor(70 * specialSpeed); for (let i = -2; i <= 2; i++) projectiles.push(new Projectile(this.x, this.y, i * 0.4, 10, 'enemy')); } break;
            case 'Stone Golem':
                if (dist > 80) this.vx = this.facing * this.speed; else { this.vx = 0; if (this.attackCooldown <= 0) { this.attackCooldown = Math.floor(60 * attackSpeed); if (dist < 180) { player.takeDamage(this.baseDamage); player.vx = this.facing * 10; for (let i = 0; i < 40; i++) particles.push(new Particle(this.x, this.y + this.height / 2, '#8b4513', (Math.random() - 0.5) * 25, -Math.random() * 12, 35)); } } } break;
            case 'Toxic Assassin':
                if (Math.random() < 0.08) this.vx = (Math.random() - 0.5) * this.speed * 2.5;
                if (dist < 70 && this.attackCooldown <= 0) { this.attackCooldown = Math.floor(20 * attackSpeed); player.takeDamage(this.baseDamage); }
                if (this.specialCooldown <= 0 && dist < 350) { this.specialCooldown = Math.floor(35 * specialSpeed); const angle = Math.atan2(dy, dx); const dartCount = this.phase === 2 ? 3 : 2; for (let i = 0; i < dartCount; i++) setTimeout(() => projectiles.push(new Projectile(this.x, this.y, angle + (Math.random() - 0.5) * 0.3, 16, 'enemy')), i * 100); } break;
            case 'Thunder King':
                if (dist > 90) this.vx = this.facing * this.speed;
                if (this.specialCooldown <= 0) { this.specialCooldown = Math.floor(70 * specialSpeed); const strikeCount = this.phase === 2 ? 3 : 2; for (let i = 0; i < strikeCount; i++) { setTimeout(() => { const targetX = player.x, targetY = player.y; for (let j = 0; j < 20; j++) particles.push(new Particle(targetX, targetY - 200, '#ffff00', (Math.random() - 0.5) * 5, Math.random() * 15, 30)); setTimeout(() => { const pdx = player.x - targetX, pdy = player.y - targetY, pdist = Math.sqrt(pdx * pdx + pdy * pdy); if (pdist < 60) player.takeDamage(this.baseDamage); for (let j = 0; j < 50; j++) particles.push(new Particle(targetX, targetY, '#ffd700', (Math.random() - 0.5) * 15, (Math.random() - 0.5) * 15, 25)); }, 600); }, i * 400); } } break;
            case 'Necromancer':
                this.vx = this.facing * this.speed * 0.8;
                if (this.specialCooldown <= 0 && currentRoom.enemies.length < 4) { this.specialCooldown = Math.floor(150 * specialSpeed); const minionCount = this.phase === 2 ? 2 : 1; for (let i = 0; i < minionCount; i++) currentRoom.enemies.push(new Enemy(this.x + (Math.random() - 0.5) * 120, this.y - 60, 'assassin')); }
                if (this.attackCooldown <= 0 && dist < 380) { this.attackCooldown = Math.floor(30 * attackSpeed); const angle = Math.atan2(dy, dx); projectiles.push(new Projectile(this.x, this.y, angle, 12, 'enemy')); } break;
            case 'Blood Reaper':
                if (dist > 85) this.vx = this.facing * this.speed; else { this.vx = 0; if (this.attackCooldown <= 0) { this.attackCooldown = Math.floor(28 * attackSpeed); if (dist < 90) { player.takeDamage(this.baseDamage); this.health = Math.min(this.health + 15, this.maxHealth); } } }
                if (this.specialCooldown <= 0 && dist < 300) { this.specialCooldown = Math.floor(50 * specialSpeed); const angle = Math.atan2(dy, dx); for (let i = -1; i <= 1; i++) projectiles.push(new Projectile(this.x, this.y, angle + i * 0.3, 11, 'enemy')); } break;
            case 'Void Walker':
                if (Math.random() < 0.03) { let newX = this.x + (Math.random() - 0.5) * 120, newY = this.y + (Math.random() - 0.5) * 60; newX = Math.max(60, Math.min(canvas.width - 60, newX)); newY = Math.max(100, Math.min(canvas.height - 100, newY)); this.x = newX; this.y = newY; }
                if (dist > 90) this.vx = this.facing * this.speed; else if (this.attackCooldown <= 0) { this.attackCooldown = Math.floor(32 * attackSpeed); if (dist < 80) player.takeDamage(this.baseDamage); }
                if (this.specialCooldown <= 0) { this.specialCooldown = Math.floor(60 * specialSpeed); const orbCount = this.phase === 2 ? 6 : 4; for (let i = 0; i < orbCount; i++) { const angle = (Math.PI * 2 / orbCount) * i; projectiles.push(new Projectile(this.x, this.y, angle, 9, 'enemy')); } } break;
        }
        this.animFrame++;
    }
    draw() {
        ctx.save(); ctx.translate(this.x, this.y); ctx.scale(this.facing, 1);
        /* boss visuals */
        switch (this.type) {
            case 'Crimson Knight':
                ctx.fillStyle = '#8b0000'; ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                ctx.fillStyle = '#ffd700'; ctx.fillRect(-this.width / 2, -this.height / 2, this.width, 6); ctx.fillRect(-this.width / 2, this.height / 2 - 6, this.width, 6);
                ctx.fillStyle = '#ffd700'; for (let i = -2; i <= 2; i++) ctx.fillRect(i * 10 - 3, -this.height / 2 - 8, 6, 12);
                ctx.fillStyle = '#c0c0c0'; ctx.fillRect(this.width / 2, -this.height / 2, 8, this.height); ctx.fillStyle = '#fff'; ctx.fillRect(this.width / 2 + 2, -this.height / 2, 2, this.height); break;
            case 'Shadow Lord':
                ctx.fillStyle = '#2a2a2a'; ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                ctx.globalAlpha = 0.3 + Math.sin(Date.now() / 150) * 0.2; ctx.fillStyle = '#000'; for (let i = 0; i < 3; i++) ctx.fillRect(-this.width / 2 - i * 8, -this.height / 2, this.width, this.height); ctx.globalAlpha = 1;
                ctx.fillStyle = '#ff0000'; ctx.globalAlpha = 0.8 + Math.sin(Date.now() / 200) * 0.2; ctx.beginPath(); ctx.arc(-8, -this.height / 2 + 15, 5, 0, Math.PI * 2); ctx.arc(8, -this.height / 2 + 15, 5, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1; break;
            case 'Frost Warden':
                ctx.fillStyle = '#00bfff'; ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                ctx.fillStyle = '#87ceeb'; for (let i = 0; i < 5; i++) { const x = (i - 2) * 10, y = -this.height / 2 + (i % 2) * 20; ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x - 5, y + 10); ctx.lineTo(x + 5, y + 10); ctx.fill(); }
                ctx.globalAlpha = 0.4; const iceGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, this.width); iceGrad.addColorStop(0, '#00ffff'); iceGrad.addColorStop(1, 'rgba(0,255,255,0)'); ctx.fillStyle = iceGrad; ctx.beginPath(); ctx.arc(0, 0, this.width, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1; break;
            case 'Flame Tyrant':
                ctx.fillStyle = '#ff4500'; ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                ctx.fillStyle = '#ff6600'; for (let i = 0; i < 6; i++) { const flameX = (i - 2.5) * 10, flameHeight = 10 + Math.sin(Date.now() / 100 + i) * 5; ctx.beginPath(); ctx.moveTo(flameX, this.height / 2); ctx.lineTo(flameX - 5, this.height / 2 - flameHeight); ctx.lineTo(flameX + 5, this.height / 2 - flameHeight); ctx.fill(); }
                ctx.fillStyle = '#8b0000'; for (let i = -1; i <= 1; i++) { ctx.beginPath(); ctx.moveTo(i * 15, -this.height / 2); ctx.lineTo(i * 15 - 5, -this.height / 2 - 15); ctx.lineTo(i * 15 + 5, -this.height / 2 - 10); ctx.fill(); }
                ctx.fillStyle = '#ffff00'; ctx.fillRect(-10, -this.height / 2 + 12, 6, 6); ctx.fillRect(4, -this.height / 2 + 12, 6, 6); break;
            case 'Stone Golem':
                ctx.fillStyle = '#696969'; ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                ctx.strokeStyle = '#4a4a4a'; ctx.lineWidth = 2; for (let y = -this.height / 2; y < this.height / 2; y += 15) ctx.strokeRect(-this.width / 2, y, this.width, 15);
                ctx.strokeStyle = '#2a2a2a'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(-this.width / 4, -this.height / 2); ctx.lineTo(-this.width / 4 + 5, 0); ctx.lineTo(-this.width / 4, this.height / 2); ctx.stroke();
                ctx.fillStyle = '#ff6600'; ctx.globalAlpha = 0.6 + Math.sin(Date.now() / 200) * 0.4; ctx.beginPath(); ctx.arc(0, 0, 12, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1; break;
            case 'Toxic Assassin':
                ctx.fillStyle = '#228b22'; ctx.fillRect(-this.width / 2 + 6, -this.height / 2, this.width - 12, this.height);
                ctx.fillStyle = '#00ff00'; for (let i = 0; i < 4; i++) { const dripX = (i - 1.5) * 12, dripY = this.height / 2 + Math.sin(Date.now() / 80 + i) * 8; ctx.beginPath(); ctx.arc(dripX, dripY, 3, 0, Math.PI * 2); ctx.fill(); }
                ctx.fillStyle = '#1a4d1a'; ctx.fillRect(-12, -this.height / 2 + 8, 24, 12);
                ctx.fillStyle = '#00ff00'; ctx.globalAlpha = 0.7; ctx.fillRect(-8, -this.height / 2 + 10, 5, 8); ctx.fillRect(3, -this.height / 2 + 10, 5, 8); ctx.globalAlpha = 1; break;
            case 'Thunder King':
                ctx.fillStyle = '#ffd700'; ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                ctx.strokeStyle = '#ffff00'; ctx.lineWidth = 3; ctx.globalAlpha = 0.7 + Math.sin(Date.now() / 100) * 0.3; for (let i = -1; i <= 1; i++) { ctx.beginPath(); ctx.moveTo(i * 15, -this.height / 2); ctx.lineTo(i * 15 - 5, -this.height / 4); ctx.lineTo(i * 15 + 5, 0); ctx.lineTo(i * 15 - 5, this.height / 4); ctx.lineTo(i * 15, this.height / 2); ctx.stroke(); }
                ctx.globalAlpha = 1; ctx.fillStyle = '#ffaa00'; for (let i = -2; i <= 2; i++) ctx.fillRect(i * 8 - 2, -this.height / 2 - 10, 4, 15); break;
            case 'Necromancer':
                ctx.fillStyle = '#4b0082'; ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                ctx.fillStyle = '#fff'; ctx.globalAlpha = 0.8; for (let i = 0; i < 3; i++) ctx.beginPath(); ctx.arc(-this.width / 3, -this.height / 2 + i * 20 + 10, 4, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1;
                ctx.strokeStyle = '#8b008b'; ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(this.width / 2, this.height / 2); ctx.lineTo(this.width / 2, -this.height / 2); ctx.stroke();
                ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(this.width / 2, -this.height / 2, 8, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#8b008b'; ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 150) * 0.5; ctx.beginPath(); ctx.arc(this.width / 2, -this.height / 2, 6, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1; break;
            case 'Blood Reaper':
                ctx.fillStyle = '#dc143c'; ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                ctx.fillStyle = '#8b0000'; for (let i = 0; i < 5; i++) { const bloodX = (i - 2) * 12, bloodY = this.height / 2 + Math.sin(Date.now() / 80 + i) * 8; ctx.fillRect(bloodX - 2, bloodY - 10, 4, 10); ctx.beginPath(); ctx.arc(bloodX, bloodY, 3, 0, Math.PI * 2); ctx.fill(); }
                ctx.strokeStyle = '#2a2a2a'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(this.width / 2, this.height / 2); ctx.lineTo(this.width / 2, -this.height / 2 + 10); ctx.stroke();
                ctx.fillStyle = '#c0c0c0'; ctx.beginPath(); ctx.arc(this.width / 2, -this.height / 2 + 10, 10, Math.PI, 0); ctx.fill(); break;
            case 'Void Walker':
                ctx.fillStyle = '#483d8b'; ctx.globalAlpha = 0.7 + Math.sin(Date.now() / 120) * 0.3; ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height); ctx.globalAlpha = 1;
                ctx.fillStyle = '#000'; for (let i = 0; i < 4; i++) { const portalX = (i % 2) * 20 - 10, portalY = Math.floor(i / 2) * 30 - 15; ctx.globalAlpha = 0.4 + Math.sin(Date.now() / 100 + i) * 0.4; ctx.beginPath(); ctx.arc(portalX, portalY, 6, 0, Math.PI * 2); ctx.fill(); }
                ctx.globalAlpha = 1; ctx.strokeStyle = '#9370db'; ctx.lineWidth = 2; ctx.globalAlpha = 0.6 + Math.sin(Date.now() / 150) * 0.4; ctx.strokeRect(-this.width / 2, -this.height / 2, this.width, this.height); ctx.globalAlpha = 1; break;
        }
        if (this.phase === 2) {
            ctx.globalAlpha = 0.4 + Math.sin(Date.now() / 80) * 0.4; ctx.strokeStyle = '#ff0000'; ctx.lineWidth = 4; ctx.strokeRect(-this.width / 2 - 2, -this.height / 2 - 2, this.width + 4, this.height + 4);
            const auraGrad = ctx.create
            RadialGradient(0, 0, 0, 0, 0, this.width * 1.5); auraGrad.addColorStop(0, 'rgba(255,0,0,0.5)'); auraGrad.addColorStop(1, 'rgba(255,0,0,0)'); ctx.fillStyle = auraGrad; ctx.beginPath(); ctx.arc(0, 0, this.width * 1.5, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1;
        }
        ctx.restore();
        ctx.fillStyle = '#333'; ctx.fillRect(this.x - 50, this.y - this.height / 2 - 25, 100, 8);
        ctx.fillStyle = this.phase === 2 ? '#ff0000' : '#8b0000'; ctx.fillRect(this.x - 50, this.y - this.height / 2 - 25, 100 * (this.health / this.maxHealth), 8);
        ctx.fillStyle = this.phase === 2 ? '#ff0000' : '#ffd700'; ctx.font = 'bold 16px Courier New'; ctx.textAlign = 'center'; ctx.fillText(this.type + (this.phase === 2 ? ' [ENRAGED]' : ''), this.x, this.y - this.height / 2 - 35);
    }
    takeDamage(amount) {
        const armorPierceBonus = 1 + ((player.upgrades.armorPierce || 0) * 0.3);
        this.health -= amount * armorPierceBonus;
        for (let i = 0; i < 15; i++) particles.push(new Particle(this.x, this.y, this.color, (Math.random() - 0.5) * 8, (Math.random() - 0.5) * 8 - 2, 25));
    }
}

/* --------------  ROOM  -------------- */
class Room {
    constructor(seed, isBossRoom = false) {
        this.seed = seed; this.platforms = []; this.enemies = []; this.boss = null; this.isBossRoom = isBossRoom; this.doors = { left: false, right: true }; this.cleared = false; this.generate();
    }
    generate() {
        let randSeed = this.seed; const rand = () => { randSeed = (randSeed * 9301 + 49297) % 233280; return randSeed / 233280; };
        const platformCount = 4 + Math.floor(rand() * 4); const layers = [200, 320, 440, 560]; const usedLayers = [];
        for (let i = 0; i < platformCount; i++) {
            const layer = layers[Math.floor(rand() * layers.length)]; const width = 150 + rand() * 180; const x = 100 + rand() * (canvas.width - width - 200);
            let overlap = false; for (const p of this.platforms) { if (Math.abs(p.y - layer) < 50 && x < p.x + p.width + 50 && x + width > p.x - 50) { overlap = true; break; } }
            if (!overlap) { this.platforms.push({ x, y: layer, width, height: 15 }); }
        }
        this.platforms.push({ x: 50, y: canvas.height - 150, width: 200, height: 15 });
        this.platforms.push({ x: canvas.width - 250, y: canvas.height - 150, width: 200, height: 15 });
        if (this.isBossRoom) {
            const bossTypes = ['Crimson Knight', 'Shadow Lord', 'Frost Warden', 'Flame Tyrant', 'Stone Golem', 'Toxic Assassin', 'Thunder King', 'Necromancer', 'Blood Reaper', 'Void Walker'];
            const bossType = bossTypes[Math.floor(rand() * bossTypes.length)];
            this.boss = new Boss(canvas.width / 2, canvas.height - 200, bossType);
        } else {
            let baseEnemyCount = 2 + Math.floor(rand() * 4);
            if (this.seed < 3 * 12345) baseEnemyCount = 1 + Math.floor(rand() * 2);
            else if (this.seed < 5 * 12345) baseEnemyCount = 2 + Math.floor(rand() * 2);
            const enemyCount = Math.min(baseEnemyCount, this.platforms.length); const usedPlatforms = [];
            const enemyTypes = ['basic', 'advanced', 'heavy', 'assassin', 'mage'];
            for (let i = 0; i < enemyCount; i++) {
                let platformIndex; let attempts = 0; do { platformIndex = Math.floor(rand() * this.platforms.length); attempts++; } while (usedPlatforms.includes(platformIndex) && attempts < 20);
                if (!usedPlatforms.includes(platformIndex)) {
                    usedPlatforms.push(platformIndex); const platform = this.platforms[platformIndex]; const typeRoll = rand();
                    let type; if (this.seed < 3 * 12345) { if (typeRoll < 0.6) type = 'basic'; else if (typeRoll < 0.9) type = 'advanced'; else type = 'assassin'; }
                    else if (this.seed < 5 * 12345) { if (typeRoll < 0.35) type = 'basic'; else if (typeRoll < 0.6) type = 'advanced'; else if (typeRoll < 0.75) type = 'heavy'; else if (typeRoll < 0.9) type = 'assassin'; else type = 'mage'; }
                    else { if (typeRoll < 0.3) type = 'basic'; else if (typeRoll < 0.55) type = 'advanced'; else if (typeRoll < 0.7) type = 'heavy'; else if (typeRoll < 0.85) type = 'assassin'; else type = 'mage'; }
                    this.enemies.push(new Enemy(platform.x + platform.width / 2, platform.y - 40, type));
                }
            }
        }
    }
    draw() {
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height); gradient.addColorStop(0, '#3a3a3a'); gradient.addColorStop(1, '#1a1a1a'); ctx.fillStyle = gradient; ctx.fillRect(0, 0, canvas.width, canvas.height);
        for (let i = 0; i < 20; i++) for (let j = 0; j < 15; j++) { const x = i * 60 + (j % 2) * 30, y = j * 50; ctx.strokeStyle = '#2a2a2a'; ctx.lineWidth = 2; ctx.strokeRect(x, y, 60, 50); }
        for (let i = 0; i < 5; i++) { const x = 150 + i * 220, y = 80; const torchGradient = ctx.createRadialGradient(x, y, 0, x, y, 60); torchGradient.addColorStop(0, 'rgba(255,140,0,0.15)'); torchGradient.addColorStop(1, 'rgba(255,140,0,0)'); ctx.fillStyle = torchGradient; ctx.fillRect(x - 60, y - 60, 120, 120); ctx.fillStyle = '#ff8c00'; ctx.globalAlpha = 0.8 + Math.sin(Date.now() / 100 + i) * 0.2; ctx.beginPath(); ctx.ellipse(x, y, 6, 10 + Math.sin(Date.now() / 150 + i) * 3, 0, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1; }
        for (const platform of this.platforms) {
            ctx.fillStyle = 'rgba(0,0,0,0.4)'; ctx.fillRect(platform.x + 5, platform.y + 5, platform.width, platform.height);
            const platformGradient = ctx.createLinearGradient(0, platform.y, 0, platform.y + platform.height); platformGradient.addColorStop(0, '#5a5a5a'); platformGradient.addColorStop(1, '#3a3a3a'); ctx.fillStyle = platformGradient; ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
            ctx.fillStyle = '#6a6a6a'; ctx.fillRect(platform.x, platform.y, platform.width, 3);
            ctx.strokeStyle = '#2a2a2a'; ctx.lineWidth = 1; for (let i = 0; i < 3; i++) { const crackX = platform.x + (platform.width / 4) * (i + 0.5); ctx.beginPath(); ctx.moveTo(crackX, platform.y); ctx.lineTo(crackX + 5, platform.y + platform.height); ctx.stroke(); }
        }
        ctx.fillStyle = '#2a2a2a'; ctx.fillRect(0, canvas.height - 50, canvas.width, 50);
        ctx.strokeStyle = '#1a1a1a'; ctx.lineWidth = 2; for (let i = 0; i < canvas.width / 60; i++) ctx.strokeRect(i * 60, canvas.height - 50, 60, 50);
        ctx.fillStyle = '#4a4a4a'; ctx.fillRect(0, canvas.height - 50, canvas.width, 3);
        if (this.cleared || this.enemies.length === 0) {
            const doorX = canvas.width - 60, doorY = canvas.height - 180;
            ctx.fillStyle = '#4a4a4a'; ctx.fillRect(doorX, doorY, 50, 130);
            ctx.beginPath(); ctx.arc(doorX + 25, doorY + 130, 25, Math.PI, 0); ctx.fill();
            ctx.fillStyle = '#0a0a0a'; ctx.fillRect(doorX + 5, doorY + 20, 40, 110);
            const doorGradient = ctx.createRadialGradient(doorX + 25, doorY + 75, 0, doorX + 25, doorY + 75, 50); doorGradient.addColorStop(0, 'rgba(255,215,0,0.4)'); doorGradient.addColorStop(1, 'rgba(255,215,0,0)'); ctx.fillStyle = doorGradient; ctx.fillRect(doorX - 20, doorY, 90, 130);
            ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 300) * 0.3; ctx.fillStyle = '#ffd700'; ctx.fillRect(doorX + 5, doorY + 20, 40, 110); ctx.globalAlpha = 1;
            ctx.strokeStyle = '#6a6a6a'; ctx.lineWidth = 3; ctx.strokeRect(doorX, doorY, 50, 130);
            ctx.fillStyle = '#ffd700'; ctx.font = '20px Courier New'; ctx.textAlign = 'center'; ctx.globalAlpha = 0.7 + Math.sin(Date.now() / 300) * 0.3; ctx.fillText('‚Üí', doorX + 25, doorY - 10); ctx.globalAlpha = 1;
        }
    }
}

/* --------------  UPGRADE DEFINITIONS  -------------- */
const rarityColors = { common: '#b3b3b3', uncommon: '#5cb85c', rare: '#5bc0de', epic: '#a335ee', legendary: '#ff8c00', mythic: '#ffd700' };
const upgradeDefinitions = {
    /* passives */
    multishot: { name: "Multi-Shot", description: "Throw additional knives in a spread pattern", maxLevel: 3, icon: "‚öîÔ∏è", rarity: "uncommon", type: "passive" },
    rapidFire: { name: "Rapid Fire", description: "Reduce knife throwing cooldown significantly", maxLevel: 5, icon: "‚ö°", rarity: "common", type: "passive" },
    lifesteal: { name: "Life Steal", description: "Restore health when defeating enemies", maxLevel: 3, icon: "üíâ", rarity: "rare", type: "passive" },
    dashAttack: { name: "Shadow Strike", description: "Deal damage to enemies you dash through", maxLevel: 3, icon: "üí®", rarity: "uncommon", type: "passive" },
    criticalHit: { name: "Assassinate", description: "Chance to deal triple damage with attacks", maxLevel: 3, icon: "üí•", rarity: "rare", type: "passive" },
    thorns: { name: "Retribution", description: "Reflect damage back to nearby attackers", maxLevel: 3, icon: "üõ°Ô∏è", rarity: "uncommon", type: "passive" },
    speedBoost: { name: "Swift Steps", description: "Increase movement speed", maxLevel: 4, icon: "üèÉ", rarity: "common", type: "passive" },
    vampiricAura: { name: "Dark Essence", description: "Slowly regenerate health over time", maxLevel: 3, icon: "üåô", rarity: "rare", type: "passive" },
    explosiveKnives: { name: "Explosive Blades", description: "Knives explode on impact, damaging nearby enemies", maxLevel: 1, icon: "üí£", rarity: "epic", type: "passive" },
    armorPierce: { name: "Armor Breaker", description: "Deal extra damage to bosses and armored foes", maxLevel: 3, icon: "üî®", rarity: "rare", type: "passive" },
    doubleJump: { name: "Double Jump", description: "Jump again while in the air", maxLevel: 1, icon: "ü¶Ö", rarity: "uncommon", type: "passive" },
    /* abilities */
    dashBoost: { name: "Dash Boost", description: "Extended dash range and reduced cooldown", maxLevel: 1, icon: "üí´", rarity: "common", type: "ability", cooldown: 0 },
    fireStorm: { name: "Fire Storm", description: "Rain fire projectiles around you", maxLevel: 1, icon: "üî•", rarity: "uncommon", type: "ability", cooldown: 400 },
    iceWall: { name: "Ice Wall", description: "Create barrier that blocks projectiles", maxLevel: 1, icon: "‚ùÑÔ∏è", rarity: "uncommon", type: "ability", cooldown: 500 },
    shadowClone: { name: "Shadow Clone", description: "Create a clone that mimics your attacks for 10s", maxLevel: 1, icon: "üë•", rarity: "rare", type: "ability", cooldown: 600 },
    bladeDance: { name: "Blade Dance", description: "Spinning knife attack all around you", maxLevel: 1, icon: "üåÄ", rarity: "rare", type: "ability", cooldown: 350 },
    venomStrike: { name: "Venom Strike", description: "Poison all nearby enemies for massive DOT", maxLevel: 1, icon: "‚ò†Ô∏è", rarity: "rare", type: "ability", cooldown: 450 },
    timeStop: { name: "Time Stop", description: "Freeze all enemies for 3 seconds", maxLevel: 1, icon: "‚è∏Ô∏è", rarity: "epic", type: "ability", cooldown: 800 },
    deathMark: { name: "Death Mark", description: "Mark enemies - next hit deals 5x damage", maxLevel: 1, icon: "üíÄ", rarity: "epic", type: "ability", cooldown: 500 },
    phantomStrike: { name: "Phantom Strike", description: "Teleport behind nearest enemy and strike", maxLevel: 1, icon: "üëª", rarity: "epic", type: "ability", cooldown: 400 },
    omniSlash: { name: "Omni Slash", description: "Dash through all enemies dealing massive damage", maxLevel: 1, icon: "‚ö°", rarity: "legendary", type: "ability", cooldown: 700 },
    voidRift: { name: "Void Rift", description: "Create portal that sucks in and damages enemies", maxLevel: 1, icon: "üåÄ", rarity: "legendary", type: "ability", cooldown: 900 },
    bloodMoon: { name: "Blood Moon", description: "Lifesteal aura + attack speed for 8 seconds", maxLevel: 1, icon: "üî¥", rarity: "legendary", type: "ability", cooldown: 1000 },
    divineShield: { name: "Divine Shield", description: "Invulnerable for 4 seconds", maxLevel: 1, icon: "üõ°Ô∏è", rarity: "legendary", type: "ability", cooldown: 800 },
    stormCaller: { name: "Storm Caller", description: "Lightning strikes all enemies", maxLevel: 1, icon: "‚ö°", rarity: "legendary", type: "ability", cooldown: 750 },
    godMode: { name: "Ascension", description: "Invincible + 10x damage for 5 seconds", maxLevel: 99, icon: "‚ú®", rarity: "mythic", type: "ability", cooldown: 1500 },
    armageddon: { name: "Armageddon", description: "Meteors rain down destroying everything", maxLevel: 99, icon: "‚òÑÔ∏è", rarity: "mythic", type: "ability", cooldown: 1200 },
    infinityEdge: { name: "Infinity Edge", description: "Summon 20 homing blades for 10 seconds", maxLevel: 99, icon: "‚öîÔ∏è", rarity: "mythic", type: "ability", cooldown: 1400 },
    timestrike: { name: "Timestrike", description: "Stop time and attack freely for 5 seconds", maxLevel: 99, icon: "‚è±Ô∏è", rarity: "mythic", type: "ability", cooldown: 1600 },
    soulReaper: { name: "Soul Reaper", description: "Instantly kill all non-boss enemies", maxLevel: 99, icon: "üíÄ", rarity: "mythic", type: "ability", cooldown: 1800 },
    ragnarok: { name: "Ragnarok", description: "Screen-wide explosion of devastation", maxLevel: 99, icon: "üí•", rarity: "mythic", type: "ability", cooldown: 2000 }
};

/* --------------  UPGRADE SYSTEM  -------------- */
function getRandomUpgrades(count = 3) {
    if (!player.upgrades) player.upgrades = {};
    if (mythicMode) {
        const allMythics = ['godMode', 'armageddon', 'infinityEdge', 'timestrike', 'soulReaper', 'ragnarok'];
        const mythicUpgrades = allMythics.filter(key => (player.upgrades[key] || 0) < upgradeDefinitions[key].maxLevel);
        const selected = [];
        for (let i = 0; i < count; i++) if (mythicUpgrades.length > 0) selected.push(mythicUpgrades[Math.floor(Math.random() * mythicUpgrades.length)]);
        return selected;
    }
    const available = Object.keys(upgradeDefinitions).filter(key => (player.upgrades[key] || 0) < upgradeDefinitions[key].maxLevel);
    const rarityWeights = { common: 30, uncommon: 25, rare: 20, epic: 18, legendary: 15, mythic: 20 };
    const weightedPool = []; available.forEach(key => { const weight = rarityWeights[upgradeDefinitions[key].rarity] || 20; for (let i = 0; i < weight; i++) weightedPool.push(key); });
    const shuffled = weightedPool.sort(() => Math.random() - 0.5); const selected = []; const seen = new Set();
    for (const key of shuffled) { if (!seen.has(key)) { selected.push(key); seen.add(key); if (selected.length >= count) break; } }
    return selected;
}
function showUpgradeScreen() {
    showingUpgrade = true; const upgradeScreen = document.getElementById('upgradeScreen'); const upgradeOptions = document.getElementById('upgradeOptions'); upgradeOptions.innerHTML = '';
    const upgrades = getRandomUpgrades(3);
    upgrades.forEach(upgradeKey => {
        const upgrade = upgradeDefinitions[upgradeKey]; const currentLevel = player.upgrades[upgradeKey] || 0;
        const card = document.createElement('div'); card.className = 'upgrade-card'; const rarity = upgrade.rarity || 'common'; const color = rarityColors[rarity];
        card.style.borderColor = color; card.style.boxShadow = `0 5px 20px rgba(${rarity === 'mythic' ? '255,215,0' : '0,0,0'},0.3)`;
        if (rarity === 'mythic') { card.style.animation = 'mythicGlow 2s ease-in-out infinite'; card.style.background = 'linear-gradient(135deg,#2a1810,#1a0f08)'; }
        card.innerHTML = `<h3>${upgrade.icon} ${upgrade.name}</h3><div class="level" style="color:${color};">${rarity.toUpperCase()}</div><div class="level">Level ${currentLevel} ‚Üí ${currentLevel + 1}</div><p>${upgrade.description}</p>`;
        card.onclick = () => { if (!player.upgrades[upgradeKey]) player.upgrades[upgradeKey] = 0; player.upgrades[upgradeKey]++; if (upgrade.type === 'ability') { if (!specialAbilitiesArray.includes(upgradeKey)) specialAbilitiesArray.push(upgradeKey); if (!player.special1) player.special1 = upgradeKey; else if (!player.special2) player.special2 = upgradeKey; else player.special1 = upgradeKey; } upgradeScreen.style.display = 'none'; showingUpgrade = false; updateSpecialBinds(); for (let i = 0; i < 50; i++) particles.push(new Particle(player.x, player.y, color, (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10 - 5, 40)); };
        upgradeOptions.appendChild(card);
    });
    upgradeScreen.style.display = 'flex';
}

/* --------------  INPUT  -------------- -->
const keys = {};
window.addEventListener('keydown', e => {
    if (e.key.length === 1) { cheatCode += e.key.toLowerCase(); if (cheatCode.length > 10) cheatCode = cheatCode.substring(cheatCode.length - 10); if (cheatCode.endsWith(SECRET_CODE)) { mythicMode = !mythicMode; cheatCode = ''; for (let i = 0; i < 100; i++) particles.push(new Particle(player.x, player.y, mythicMode ? '#ffd700' : '#888', (Math.random() - 0.5) * 20, (Math.random() - 0.5) * 20, 60)); } }
    if (!gameStarted) { gameStarted = true; document.getElementById('titleScreen').classList.add('fade-out'); setTimeout(() => document.getElementById('titleScreen').style.display = 'none', 2000); }
    keys[e.key.toLowerCase()] = true;
    let aimX = 0, aimY = 0; if (keys['w'] || keys['arrowup']) aimY = -1; if (keys['s'] || keys['arrowdown']) aimY = 1; if (keys['a'] || keys['arrowleft']) aimX = -1; if (keys['d'] || keys['arrowright']) aimX = 1; if (aimX !== 0 || aimY !== 0) { const magnitude = Math.sqrt(aimX * aimX + aimY * aimY); player.aimDirection = { x: aimX / magnitude, y: aimY / magnitude }; }
    if (e.key === ' ' || e.key.toLowerCase() === 'w' || e.key === 'ArrowUp') {
        if (player.onGround && !showingUpgrade) { player.vy = -player.jumpPower; } else if (!player.onGround && !player.hasDoubleJumped && (player.upgrades.doubleJump || 0) > 0 && !showingUpgrade) { player.vy = -player.jumpPower; player.hasDoubleJumped = true; for (let i = 0; i < 15; i++) particles.push(new Particle(player.x, player.y, '#00ffff', (Math.random() - 0.5) * 8, Math.random() * 5, 20)); }
    }
    if (e.key.toLowerCase() === 'j' && !showingUpgrade) player.attack();
    if (e.key.toLowerCase() === 'k' && !showingUpgrade) player.dash();
    if (e.key.toLowerCase() === 'l' && !showingUpgrade) player.shootRanged();
    if (e.key.toLowerCase() === 'q' && !showingUpgrade) castSpecialAbility(0);
    if (e.key.toLowerCase() === 'e' && !showingUpgrade) castSpecialAbility(1);
    if (e.key.toLowerCase() === 'r' && !showingUpgrade) castSpecialAbility(2);
    if (e.key.toLowerCase() === 'f' && !showingUpgrade) castSpecialAbility(3);
    if (e.key.toLowerCase() === 'c' && !showingUpgrade) castSpecialAbility(4);
    if (e.key.toLowerCase() === 'v' && !showingUpgrade) castSpecialAbility(5);
    if (e.key.toLowerCase() === 'z' && !showingUpgrade) castSpecialAbility(6);
    if (e.key.toLowerCase() === 'x' && !showingUpgrade) castSpecialAbility(7);
});
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

/* --------------  SPECIAL ABILITY CAST  -------------- */
function castSpecialAbility(index) {
    if (index >= specialAbilitiesArray.length || !player || showingUpgrade) return;
    const specialKey = specialAbilitiesArray[index];
    const temp = player.special1;
    player.special1 = specialKey;
    player.useSpecial1();
    player.special1 = temp;
}

/* --------------  COLLISIONS / PROJECTILES  -------------- */
function checkAttackCollisions() {
    if (player.attacking && player.attackFrame >= 5 && player.attackFrame <= 12) {
        if (currentRoom.boss && currentRoom.boss.health > 0) {
            const boss = currentRoom.boss; const dx = boss.x - (player.x + player.facing * 30); const dy = boss.y - player.y; const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < player.attackRange + boss.width / 2) {
                let damage = player.attackDamage; const critChance = (player.upgrades.criticalHit || 0) * 0.2; if (Math.random() < critChance) { damage *= 3; for (let j = 0; j < 20; j++) particles.push(new Particle(boss.x, boss.y, '#ffff00', (Math.random() - 0.5) * 12, (Math.random() - 0.5) * 12, 30)); }
                boss.takeDamage(damage);
                if (boss.health <= 0) {
                    if ((player.upgrades.lifesteal || 0) > 0) { const healAmount = 30 * (player.upgrades.lifesteal || 0); player.health = Math.min(player.health + healAmount, player.maxHealth); for (let j = 0; j < 10; j++) particles.push(new Particle(player.x, player.y, '#00ff00', (Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5 - 3, 25)); }
                    for (let j = 0; j < 100; j++) particles.push(new Particle(boss.x, boss.y, j % 2 === 0 ? '#ffd700' : boss.color, (Math.random() - 0.5) * 20, (Math.random() - 0.5) * 20 - 5, 60));
                }
            }
        }
        for (let i = currentRoom.enemies.length - 1; i >= 0; i--) {
            const enemy = currentRoom.enemies[i]; const dx = enemy.x - (player.x + player.facing * 30); const dy = enemy.y - player.y; const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < player.attackRange && Math.sign(dx) === player.facing) {
                let damage = player.attackDamage; const critChance = (player.upgrades.criticalHit || 0) * 0.2; if (Math.random() < critChance) { damage *= 3; for (let j = 0; j < 20; j++) particles.push(new Particle(enemy.x, enemy.y, '#ffff00', (Math.random() - 0.5) * 12, (Math.random() - 0.5) * 12, 30)); }
                enemy.takeDamage(damage);
                if (enemy.health <= 0) {
                    if ((player.upgrades.lifesteal || 0) > 0) { const healAmount = 10 * (player.upgrades.lifesteal || 0); player.health = Math.min(player.health + healAmount, player.maxHealth); for (let k = 0; k < 10; k++) particles.push(new Particle(player.x, player.y, '#00ff00', (Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5 - 3, 25)); }
                    for (let k = 0; k < 30; k++) particles.push(new Particle(enemy.x, enemy.y, '#ff6600', (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10 - 3, 40));
                    currentRoom.enemies.splice(i, 1);
                }
            }
        }
    }
}
function updateProjectiles() {
    for (let i = projectiles.length - 1; i >= 0; i--) {
        const proj = projectiles[i]; proj.update();
        if (proj.owner === 'enemy') {
            const dx = player.x - proj.x; const dy = player.y - proj.y; const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < player.width / 2 + proj.radius) { player.takeDamage(proj.damage); projectiles.splice(i, 1); continue; }
        }
        if (proj.owner === 'player') {
            if (currentRoom.boss && currentRoom.boss.health > 0) {
                const boss = currentRoom.boss; const dx = boss.x - proj.x; const dy = boss.y - proj.y; const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < boss.width / 2 + proj.radius) {
                    if (proj.explosive) for (let k = 0; k < 40; k++) particles.push(new Particle(proj.x, proj.y, k % 2 === 0 ? '#ff6600' : '#ffaa00', (Math.random() - 0.5) * 15, (Math.random() - 0.5) * 15, 30));
                    boss.takeDamage(proj.damage);
                    if (boss.health <= 0) {
                        if ((player.upgrades.lifesteal || 0) > 0) { const healAmount = 30 * (player.upgrades.lifesteal || 0); player.health = Math.min(player.health + healAmount, player.maxHealth); for (let k = 0; k < 10; k++) particles.push(new Particle(player.x, player.y, '#00ff00', (Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5 - 3, 25)); }
                        for (let k = 0; k < 100; k++) particles.push(new Particle(boss.x, boss.y, k % 2 === 0 ? '#ffd700' : boss.color, (Math.random() - 0.5) * 20, (Math.random() - 0.5) * 20 - 5, 60));
                    }
                    projectiles.splice(i, 1); continue;
                }
            }
            for (let j = currentRoom.enemies.length - 1; j >= 0; j--) {
                const enemy = currentRoom.enemies[j]; const dx = enemy.x - proj.x; const dy = enemy.y - proj.y; const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < enemy.width / 2 + proj.radius) {
                    if (proj.explosive) {
                        for (let k = 0; k < currentRoom.enemies.length; k++) {
                            const nearEnemy = currentRoom.enemies[k]; const edx = nearEnemy.x - proj.x; const edy = nearEnemy.y - proj.y; const eDist = Math.sqrt(edx * edx + edy * edy);
                            if (eDist < 80) nearEnemy.takeDamage(proj.damage * 0.7);
                        }
                        for (let k = 0; k < 40; k++) particles.push(new Particle(proj.x, proj.y, k % 2 === 0 ? '#ff6600' : '#ffaa00', (Math.random() - 0.5) * 15, (Math.random() - 0.5) * 15, 30));
                    }
                    enemy.takeDamage(proj.damage);
                    if (enemy.health <= 0) {
                        if ((player.upgrades.lifesteal || 0) > 0) { const healAmount = 10 * (player.upgrades.lifesteal || 0); player.health = Math.min(player.health + healAmount, player.maxHealth); for (let k = 0; k < 10; k++) particles.push(new Particle(player.x, player.y, '#00ff00', (Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5 - 3, 25)); }
                        for (let k = 0; k < 30; k++) particles.push(new Particle(enemy.x, enemy.y, '#ff6600', (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10 - 3, 40));
                        currentRoom.enemies.splice(j, 1);
                    }
                    projectiles.splice(i, 1); break;
                }
            }
        }
        if (proj.life <= 0 || proj.x < 0 || proj.x > canvas.width || proj.y < 0 || proj.y > canvas.height) projectiles.splice(i, 1);
    }
}

/* --------------  GAME LOOP  -------------- */
function gameLoop() {
    if (!gameStarted || showingUpgrade || gameOver) { requestAnimationFrame(gameLoop); return; }
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    currentRoom.draw();
    for (let i = trails.length - 1; i >= 0; i--) { trails[i].update(); trails[i].draw(); if (trails[i].life <= 0) trails.splice(i, 1); }
    for (let i = shadowClones.length - 1; i >= 0; i--) { shadowClones[i].update(); shadowClones[i].draw(); if (shadowClones[i].lifetime <= 0) shadowClones.splice(i, 1); }
    for (let i = particles.length - 1; i >= 0; i--) { particles[i].update(); particles[i].draw(); if (particles[i].life <= 0) particles.splice(i, 1); }
    updateProjectiles(); for (const proj of projectiles) proj.draw();
    if (!player.dashing) {
        if (keys['a'] || keys['arrowleft']) { player.vx = -player.speed; player.facing = -1; } else if (keys['d'] || keys['arrowright']) { player.vx = player.speed; player.facing = 1; } else player.vx *= 0.8;
    }
    player.update(); checkAttackCollisions();
    for (const enemy of currentRoom.enemies) enemy.update();
    if (currentRoom.boss && currentRoom.boss.health > 0) currentRoom.boss.update();
    for (const enemy of currentRoom.enemies) enemy.draw();
    if (currentRoom.boss && currentRoom.boss.health > 0) currentRoom.boss.draw();
    player.draw();
    if (!player.attacking && !player.dashing) {
        const aimLength = 40; const aimX = player.x + player.aimDirection.x * aimLength; const aimY = player.y + player.aimDirection.y * aimLength;
        ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 2; ctx.globalAlpha = 0.6; ctx.beginPath(); ctx.moveTo(player.x, player.y); ctx.lineTo(aimX, aimY); ctx.stroke();
        const angle = Math.atan2(player.aimDirection.y, player.aimDirection.x);
        ctx.fillStyle = '#ffd700'; ctx.beginPath(); ctx.moveTo(aimX, aimY); ctx.lineTo(aimX - 8 * Math.cos(angle - 0.3), aimY - 8 * Math.sin(angle - 0.3)); ctx.lineTo(aimX - 8 * Math.cos(angle + 0.3), aimY - 8 * Math.sin(angle + 0.3)); ctx.closePath(); ctx.fill(); ctx.globalAlpha = 1;
    }
    const roomCleared = currentRoom.boss ? (currentRoom.boss.health <= 0) : (currentRoom.enemies.length === 0);
    if (roomCleared && !currentRoom.cleared) {
        currentRoom.cleared = true; for (let i = 0; i < 100; i++) particles.push(new Particle(canvas.width / 2, canvas.height / 2, i % 3 === 0 ? '#ffd700' : (i % 3 === 1 ? '#ffaa00' : '#ff8c00'), (Math.random() - 0.5) * 20, (Math.random() - 0.5) * 20 - 5, 60 + Math.random() * 30));
    }
    for (const enemy of currentRoom.enemies) enemy.draw();
    if (currentRoom.boss && currentRoom.boss.health > 0) currentRoom.boss.draw();
    player.draw();
    document.getElementById('health').textContent = Math.floor(player.health);
    document.getElementById('healthBar').style.width = (player.health / player.maxHealth * 100) + '%';
    document.getElementById('room').textContent = roomNumber;
    document.getElementById('enemies').textContent = currentRoom.enemies.length + (currentRoom.boss && currentRoom.boss.health > 0 ? 1 : 0);
    if (mythicMode) {
        ctx.save(); ctx.fillStyle = '#ffd700'; ctx.font = 'bold 24px Courier New'; ctx.textAlign = 'center'; ctx.shadowColor = 'rgba(255,215,0,0.8)'; ctx.shadowBlur = 10; const pulse = 0.8 + Math.sin(Date.now() / 200) * 0.2; ctx.globalAlpha = pulse; ctx.fillText('‚ú® MYTHIC MODE ‚ú®', canvas.width / 2, 30); ctx.restore();
    }
    if (player.health <= 0 && !gameOver) {
        gameOver = true; document.getElementById('finalRoom').textContent = roomNumber; document.getElementById('gameOverScreen').style.display = 'flex';
    }
    if (roomCleared && player.x > canvas.width - 50) {
        if (currentRoom.isBossRoom) saveCheckpoint();
        roomNumber++; const isBossRoom = (roomNumber % 5 === 0); currentRoom = new Room(roomNumber * 12345, isBossRoom);
        player.x = 100; player.y = canvas.height - 200; player.vy = 0; player.vx = 0; player.health = Math.min(player.health + 20, player.maxHealth);
        projectiles = []; particles = []; trails = []; shadowClones = [];
        for (let i = 0; i < 50; i++) particles.push(new Particle(player.x, player.y, isBossRoom ? '#ff0000' : '#ffd700', (Math.random() - 0.5) * 15, (Math.random() - 0.5) * 15, 30 + Math.random() * 20));
        if (!isBossRoom) showUpgradeScreen();
    }
    requestAnimationFrame(gameLoop);
}

/* --------------  INITIALISE  -------------- */
function updateSpecialBinds() {
    const container = document.getElementById('specialBindsList'); container.innerHTML = '';
    specialAbilitiesArray.forEach((key, idx) => {
        if (idx < SPECIAL_KEYBINDS.length) {
            const ability = upgradeDefinitions[key]; const div = document.createElement('div'); div.style.marginBottom = '2px'; div.textContent = `Special ${idx + 1} [${SPECIAL_KEYBINDS[idx].toUpperCase()}]: ${ability.name}`; container.appendChild(div);
        }
    });
    for (let i = specialAbilitiesArray.length; i < Math.max(2, specialAbilitiesArray.length); i++) {
        if (i < 2) {
            const div = document.createElement('div'); div.style.marginBottom = '2px'; div.textContent = `Special ${i + 1} [${SPECIAL_KEYBINDS[i].toUpperCase()}]: N/A`; container.appendChild(div);
        }
    }
}

/* --------------  BOOTSTRAP  -------------- */
window.addEventListener('load', () => {
    const save = localStorage.getItem('castleSave');
    if (save) checkpoint = JSON.parse(save);
    menuWrapper.style.display = 'flex';
});
</script>
</body>
</html>
```
