import React, { useEffect, useRef, useState } from 'react';
import * as THREE from 'three';

const VoxelWorld = () => {
  const mountRef = useRef(null);
  const [isLoaded, setIsLoaded] = useState(false);
  const [selectedBlock, setSelectedBlock] = useState('grass');

  useEffect(() => {
    if (!mountRef.current) return;

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 50, 150);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    mountRef.current.appendChild(renderer.domElement);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
    sunLight.position.set(50, 100, 50);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.width = 2048;
    sunLight.shadow.mapSize.height = 2048;
    sunLight.shadow.camera.near = 0.5;
    sunLight.shadow.camera.far = 500;
    sunLight.shadow.camera.left = -100;
    sunLight.shadow.camera.right = 100;
    sunLight.shadow.camera.top = 100;
    sunLight.shadow.camera.bottom = -100;
    scene.add(sunLight);

    // Block textures with pixelated style
    const textureLoader = new THREE.TextureLoader();
    
    const createPixelTexture = (colors) => {
      const canvas = document.createElement('canvas');
      canvas.width = 16;
      canvas.height = 16;
      const ctx = canvas.getContext('2d');
      
      for (let y = 0; y < 16; y++) {
        for (let x = 0; x < 16; x++) {
          const colorIndex = Math.floor(Math.random() * colors.length);
          ctx.fillStyle = colors[colorIndex];
          ctx.fillRect(x, y, 1, 1);
        }
      }
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.magFilter = THREE.NearestFilter;
      texture.minFilter = THREE.NearestFilter;
      return texture;
    };

    // Block materials
    const materials = {
      grass: [
        new THREE.MeshLambertMaterial({ map: createPixelTexture(['#8B7355', '#9B8365', '#7B6345']) }), // sides
        new THREE.MeshLambertMaterial({ map: createPixelTexture(['#8B7355', '#9B8365', '#7B6345']) }),
        new THREE.MeshLambertMaterial({ map: createPixelTexture(['#5F9F3F', '#6FAF4F', '#4F8F2F']) }), // top
        new THREE.MeshLambertMaterial({ map: createPixelTexture(['#8B6F47', '#7B5F37', '#6B4F27']) }), // bottom
        new THREE.MeshLambertMaterial({ map: createPixelTexture(['#8B7355', '#9B8365', '#7B6345']) }),
        new THREE.MeshLambertMaterial({ map: createPixelTexture(['#8B7355', '#9B8365', '#7B6345']) })
      ],
      dirt: new THREE.MeshLambertMaterial({ map: createPixelTexture(['#8B6F47', '#7B5F37', '#6B4F27', '#9B7F57']) }),
      stone: new THREE.MeshLambertMaterial({ map: createPixelTexture(['#7F7F7F', '#8F8F8F', '#6F6F6F', '#9F9F9F']) }),
      wood: [
        new THREE.MeshLambertMaterial({ map: createPixelTexture(['#8B6F47', '#7B5F37', '#9B7F57']) }), // sides
        new THREE.MeshLambertMaterial({ map: createPixelTexture(['#8B6F47', '#7B5F37', '#9B7F57']) }),
        new THREE.MeshLambertMaterial({ map: createPixelTexture(['#D4A574', '#C49564', '#B48554']) }), // top
        new THREE.MeshLambertMaterial({ map: createPixelTexture(['#D4A574', '#C49564', '#B48554']) }), // bottom
        new THREE.MeshLambertMaterial({ map: createPixelTexture(['#8B6F47', '#7B5F37', '#9B7F57']) }),
        new THREE.MeshLambertMaterial({ map: createPixelTexture(['#8B6F47', '#7B5F37', '#9B7F57']) })
      ],
      leaves: new THREE.MeshLambertMaterial({ 
        map: createPixelTexture(['#2F6F2F', '#3F7F3F', '#1F5F1F']),
        transparent: true,
        opacity: 0.9
      }),
      sand: new THREE.MeshLambertMaterial({ map: createPixelTexture(['#E8D89F', '#D8C88F', '#C8B87F', '#F8E8AF']) }),
      water: new THREE.MeshLambertMaterial({ 
        map: createPixelTexture(['#3F5F9F', '#4F6FAF', '#2F4F8F']),
        transparent: true,
        opacity: 0.7
      })
    };

    // World generation
    const worldSize = 40;
    const world = {};
    const blockSize = 2;

    const noise = (x, z) => {
      return Math.sin(x * 0.1) * Math.cos(z * 0.1) * 5 + 
             Math.sin(x * 0.05) * Math.cos(z * 0.05) * 10;
    };

    const getBlockKey = (x, y, z) => `${x},${y},${z}`;

    const createBlock = (x, y, z, type) => {
      const geometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
      const material = materials[type];
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(x * blockSize, y * blockSize, z * blockSize);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      mesh.userData = { x, y, z, type };
      return mesh;
    };

    const addBlock = (x, y, z, type) => {
      const key = getBlockKey(x, y, z);
      if (world[key]) return;
      
      const block = createBlock(x, y, z, type);
      scene.add(block);
      world[key] = block;
    };

    const removeBlock = (x, y, z) => {
      const key = getBlockKey(x, y, z);
      if (world[key]) {
        scene.remove(world[key]);
        delete world[key];
      }
    };

    // Generate terrain
    for (let x = -worldSize/2; x < worldSize/2; x++) {
      for (let z = -worldSize/2; z < worldSize/2; z++) {
        const height = Math.floor(noise(x, z));
        
        // Water level
        if (height < 0) {
          for (let y = height; y <= 0; y++) {
            if (y === 0) {
              addBlock(x, y, z, 'water');
            } else if (y > height) {
              addBlock(x, y, z, 'water');
            } else {
              addBlock(x, y, z, 'sand');
            }
          }
        } else {
          // Terrain layers
          for (let y = 0; y <= height; y++) {
            if (y === height) {
              addBlock(x, y, z, 'grass');
            } else if (y > height - 3) {
              addBlock(x, y, z, 'dirt');
            } else {
              addBlock(x, y, z, 'stone');
            }
          }
          
          // Trees
          if (height > 2 && Math.random() < 0.05) {
            const treeHeight = 4 + Math.floor(Math.random() * 2);
            for (let y = 1; y <= treeHeight; y++) {
              addBlock(x, height + y, z, 'wood');
            }
            // Leaves
            for (let lx = -2; lx <= 2; lx++) {
              for (let lz = -2; lz <= 2; lz++) {
                for (let ly = 0; ly <= 2; ly++) {
                  if (Math.abs(lx) === 2 && Math.abs(lz) === 2 && ly === 0) continue;
                  if (lx === 0 && lz === 0) continue;
                  addBlock(x + lx, height + treeHeight + ly, z + lz, 'leaves');
                }
              }
            }
          }
        }
      }
    }

    // Camera setup - start on ground
    camera.position.set(0, 20, 0);
    
    // Controls
    const keys = {};
    const velocity = new THREE.Vector3();
    const moveSpeed = 0.5;
    let mouseX = 0, mouseY = 0;
    let pitch = 0, yaw = 0;
    const playerHeight = 3.6; // Eye height above ground
    let isOnGround = false;
    let verticalVelocity = 0;

    window.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
    window.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

    let isPointerLocked = false;
    
    const onMouseMove = (e) => {
      if (!isPointerLocked) return;
      mouseX = e.movementX || 0;
      mouseY = e.movementY || 0;
      
      yaw -= mouseX * 0.002;
      pitch -= mouseY * 0.002;
      pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
    };

    const onClick = () => {
      if (!isPointerLocked) {
        renderer.domElement.requestPointerLock();
      }
    };

    const onPointerLockChange = () => {
      isPointerLocked = document.pointerLockElement === renderer.domElement;
    };

    renderer.domElement.addEventListener('click', onClick);
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('pointerlockchange', onPointerLockChange);

    // Raycaster for block interaction
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2(0, 0);

    const onMouseClick = (e) => {
      if (!isPointerLocked) return;
      
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(Object.values(world));
      
      if (intersects.length > 0) {
        const block = intersects[0].object;
        
        if (e.button === 0) { // Left click - remove block
          removeBlock(block.userData.x, block.userData.y, block.userData.z);
        } else if (e.button === 2) { // Right click - add block
          const normal = intersects[0].face.normal;
          const newX = block.userData.x + Math.round(normal.x);
          const newY = block.userData.y + Math.round(normal.y);
          const newZ = block.userData.z + Math.round(normal.z);
          addBlock(newX, newY, newZ, selectedBlock);
        }
      }
    };

    renderer.domElement.addEventListener('mousedown', onMouseClick);
    renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());

    // Animation loop
    const animate = () => {
      requestAnimationFrame(animate);

      // Camera rotation
      const quaternion = new THREE.Quaternion();
      quaternion.setFromEuler(new THREE.Euler(pitch, yaw, 0, 'YXZ'));
      camera.quaternion.copy(quaternion);

      // Movement - only horizontal
      const forward = new THREE.Vector3();
      const right = new THREE.Vector3();
      
      camera.getWorldDirection(forward);
      forward.y = 0;
      forward.normalize();
      
      right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();
      
      velocity.set(0, 0, 0);
      
      if (keys['w']) velocity.add(forward);
      if (keys['s']) velocity.sub(forward);
      if (keys['a']) velocity.sub(right);
      if (keys['d']) velocity.add(right);

      if (velocity.length() > 0) {
        velocity.normalize().multiplyScalar(moveSpeed);
        camera.position.x += velocity.x;
        camera.position.z += velocity.z;
      }

      // Gravity and ground collision
      const playerX = Math.floor(camera.position.x / blockSize);
      const playerZ = Math.floor(camera.position.z / blockSize);
      
      // Find ground height
      let groundHeight = 0;
      for (let y = 50; y >= -10; y--) {
        const key = getBlockKey(playerX, y, playerZ);
        if (world[key]) {
          groundHeight = (y + 1) * blockSize + playerHeight;
          break;
        }
      }
      
      // Jump
      if (keys[' '] && isOnGround) {
        velocity.y = 0.4;
        isOnGround = false;
      }
      
      // Apply gravity
      if (!isOnGround) {
        velocity.y -= 0.02;
        camera.position.y += velocity.y;
      }
      
      // Ground check
      if (camera.position.y <= groundHeight) {
        camera.position.y = groundHeight;
        velocity.y = 0;
        isOnGround = true;
      } else {
        isOnGround = false;
      }

      renderer.render(scene, camera);
    };

    animate();
    setIsLoaded(true);

    // Resize handler
    const handleResize = () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    };
    window.addEventListener('resize', handleResize);

    // Cleanup
    return () => {
      window.removeEventListener('resize', handleResize);
      window.removeEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
      window.removeEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('pointerlockchange', onPointerLockChange);
      renderer.domElement.removeEventListener('click', onClick);
      renderer.domElement.removeEventListener('mousedown', onMouseClick);
      mountRef.current?.removeChild(renderer.domElement);
    };
  }, [selectedBlock]);

  const blockTypes = ['grass', 'dirt', 'stone', 'wood', 'leaves', 'sand', 'water'];

  return (
    <div style={{ width: '100vw', height: '100vh', overflow: 'hidden', position: 'relative' }}>
      <div ref={mountRef} style={{ width: '100%', height: '100%' }} />
      
      {/* UI Overlay */}
      <div style={{
        position: 'absolute',
        top: '20px',
        left: '50%',
        transform: 'translateX(-50%)',
        background: 'rgba(0,0,0,0.7)',
        color: 'white',
        padding: '15px 25px',
        borderRadius: '10px',
        fontFamily: 'monospace',
        fontSize: '14px',
        textAlign: 'center',
        pointerEvents: 'none',
        userSelect: 'none'
      }}>
        <div style={{ marginBottom: '10px', fontSize: '16px', fontWeight: 'bold' }}>
          ðŸ§Š VOXEL WORLD
        </div>
        <div>WASD: Move | SPACE: Jump | MOUSE: Look</div>
        <div>LEFT CLICK: Mine | RIGHT CLICK: Place</div>
        <div style={{ marginTop: '8px', fontSize: '12px', opacity: 0.8 }}>
          Click to lock pointer and start playing
        </div>
      </div>

      {/* Block selector */}
      <div style={{
        position: 'absolute',
        bottom: '20px',
        left: '50%',
        transform: 'translateX(-50%)',
        display: 'flex',
        gap: '10px',
        background: 'rgba(0,0,0,0.7)',
        padding: '10px',
        borderRadius: '10px'
      }}>
        {blockTypes.map(type => (
          <button
            key={type}
            onClick={() => setSelectedBlock(type)}
            style={{
              width: '50px',
              height: '50px',
              border: selectedBlock === type ? '3px solid #fff' : '2px solid #666',
              borderRadius: '5px',
              cursor: 'pointer',
              background: type === 'grass' ? '#5F9F3F' :
                         type === 'dirt' ? '#8B6F47' :
                         type === 'stone' ? '#7F7F7F' :
                         type === 'wood' ? '#8B6F47' :
                         type === 'leaves' ? '#2F6F2F' :
                         type === 'sand' ? '#E8D89F' :
                         '#3F5F9F',
              boxShadow: selectedBlock === type ? '0 0 10px rgba(255,255,255,0.5)' : 'none',
              transition: 'all 0.2s',
              fontSize: '20px',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center'
            }}
          >
            {type === 'grass' ? 'ðŸŸ©' :
             type === 'dirt' ? 'ðŸŸ«' :
             type === 'stone' ? 'â¬œ' :
             type === 'wood' ? 'ðŸªµ' :
             type === 'leaves' ? 'ðŸŒ¿' :
             type === 'sand' ? 'ðŸŸ¨' :
             'ðŸ’§'}
          </button>
        ))}
      </div>

      {/* Crosshair */}
      <div style={{
        position: 'absolute',
        top: '50%',
        left: '50%',
        transform: 'translate(-50%, -50%)',
        width: '20px',
        height: '20px',
        pointerEvents: 'none'
      }}>
        <div style={{
          position: 'absolute',
          width: '2px',
          height: '20px',
          background: 'white',
          left: '50%',
          transform: 'translateX(-50%)',
          boxShadow: '0 0 2px black'
        }} />
        <div style={{
          position: 'absolute',
          width: '20px',
          height: '2px',
          background: 'white',
          top: '50%',
          transform: 'translateY(-50%)',
          boxShadow: '0 0 2px black'
        }} />
      </div>
    </div>
  );
};

export default VoxelWorld;
