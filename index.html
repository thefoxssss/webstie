<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shadow Assassin - Castle Infiltration</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0a;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }

        #gameCanvas {
            border: 2px solid #8b4513;
            box-shadow: 0 0 30px rgba(139, 69, 19, 0.5);
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
        }

        .health-bar {
            width: 200px;
            height: 20px;
            background: #222;
            border: 2px solid #8b4513;
            margin-top: 5px;
            position: relative;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #dc143c, #8b0000);
            transition: width 0.3s;
        }

        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #aaa;
            font-size: 12px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .title {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #fff;
            z-index: 5;
            pointer-events: none;
        }

        .title h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #8b4513;
            text-shadow: 0 0 20px rgba(139, 69, 19, 0.8);
        }

        .title p {
            font-size: 18px;
            color: #ccc;
        }

        .fade-out {
            animation: fadeOut 2s forwards;
        }

        @keyframes fadeOut {
            to { opacity: 0; }
        }

        .upgrade-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .upgrade-container {
            text-align: center;
            color: #fff;
        }

        .upgrade-title {
            font-size: 36px;
            color: #ffd700;
            margin-bottom: 30px;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .upgrade-options {
            display: flex;
            gap: 30px;
            justify-content: center;
        }

        .upgrade-card {
            background: linear-gradient(135deg, #2a2a2a, #1a1a1a);
            border: 3px solid #8b4513;
            padding: 20px;
            width: 250px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }

        .upgrade-card:hover {
            transform: translateY(-10px);
            border-color: #ffd700;
            box-shadow: 0 10px 30px rgba(255, 215, 0, 0.3);
        }

        .upgrade-card h3 {
            color: #ffd700;
            font-size: 22px;
            margin-bottom: 10px;
        }

        .upgrade-card .level {
            color: #ff8c00;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .upgrade-card p {
            color: #ccc;
            font-size: 14px;
            line-height: 1.5;
        }

        .game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .game-over-title {
            font-size: 48px;
            color: #ff0000;
            margin-bottom: 30px;
            text-shadow: 0 0 20px rgba(255, 0, 0, 0.8);
        }

        .game-over-stats {
            color: #ffd700;
            font-size: 20px;
            margin-bottom: 30px;
        }

        .button-container {
            display: flex;
            gap: 20px;
        }

        .game-button {
            background: linear-gradient(135deg, #8b4513, #654321);
            border: 3px solid #ffd700;
            padding: 15px 40px;
            color: #fff;
            font-size: 18px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }

        .game-button:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(255, 215, 0, 0.4);
            background: linear-gradient(135deg, #a0522d, #8b4513);
        }

        .game-button:active {
            transform: translateY(-2px);
        }
        
        @keyframes mythicGlow {
            0%, 100% {
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.6), 0 0 40px rgba(255, 215, 0, 0.4);
            }
            50% {
                box-shadow: 0 0 30px rgba(255, 215, 0, 0.8), 0 0 60px rgba(255, 215, 0, 0.6);
            }
        }
    </style>
</head>
<body>
    <div id="ui">
        <div>Health: <span id="health">100</span></div>
        <div class="health-bar">
            <div class="health-fill" id="healthBar"></div>
        </div>
        <div style="margin-top: 10px;">Chamber: <span id="room">1</span></div>
        <div>Knights: <span id="enemies">0</span></div>
        
        <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid #666;">
            <div style="font-size: 12px; color: #ffd700; margin-bottom: 5px;">‚ö° ABILITIES</div>
            <div style="font-size: 11px;">Special 1 [Q]: <span id="special1Bind">N/A</span></div>
            <div style="font-size: 11px;">Special 2 [E]: <span id="special2Bind">N/A</span></div>
        </div>
    </div>

    <div class="controls">
        WASD/Arrows: Move | SPACE: Jump | J: Dagger | K: Dash | L: Knife | Q/E: Specials
    </div>

    <div class="title" id="titleScreen">
        <h1>üó°Ô∏è SHADOW ASSASSIN üó°Ô∏è</h1>
        <p>Infiltrate the castle... Press any key to begin</p>
    </div>

    <div class="upgrade-screen" id="upgradeScreen">
        <div class="upgrade-container">
            <div class="upgrade-title">‚ö° CHOOSE YOUR UPGRADE ‚ö°</div>
            <div class="upgrade-options" id="upgradeOptions"></div>
        </div>
    </div>

    <div class="game-over-screen" id="gameOverScreen">
        <div class="game-over-title">üíÄ DEFEATED üíÄ</div>
        <div class="game-over-stats">
            You reached Chamber <span id="finalRoom">1</span>
        </div>
        <div class="button-container">
            <button class="game-button" id="playAgainBtn">‚öîÔ∏è Play Again</button>
            <button class="game-button" id="loadCheckpointBtn">üìç Load Checkpoint</button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = 1200;
        canvas.height = 700;

        // Shadow Clone class
        class ShadowClone {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 28;
                this.height = 38;
                this.lifetime = 600; // 10 seconds at 60fps
                this.facing = player.facing;
                this.opacity = 0.6;
                this.attackCooldown = 0;
                this.rangedCooldown = 0;
            }

            update() {
                this.lifetime--;
                
                // Follow player position with offset
                const targetX = player.x - this.facing * 60;
                const targetY = player.y;
                
                this.x += (targetX - this.x) * 0.1;
                this.y += (targetY - this.y) * 0.1;
                this.facing = player.facing;
                
                // Cooldowns
                if (this.attackCooldown > 0) this.attackCooldown--;
                if (this.rangedCooldown > 0) this.rangedCooldown--;
                
                // Fade out near end
                if (this.lifetime < 60) {
                    this.opacity = this.lifetime / 60 * 0.6;
                }
            }

            mimicMeleeAttack() {
                if (this.attackCooldown <= 0) {
                    this.attackCooldown = 30;
                    
                    // Check enemies in range
                    for (const enemy of currentRoom.enemies) {
                        const dx = enemy.x - (this.x + this.facing * 30);
                        const dy = enemy.y - this.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < 40 && Math.sign(dx) === this.facing) {
                            enemy.takeDamage(player.attackDamage * 0.5);
                        }
                    }
                    
                    // Check boss
                    if (currentRoom.boss && currentRoom.boss.health > 0) {
                        const boss = currentRoom.boss;
                        const dx = boss.x - (this.x + this.facing * 30);
                        const dy = boss.y - this.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < 50) {
                            boss.takeDamage(player.attackDamage * 0.5);
                        }
                    }
                }
            }

            mimicRangedAttack() {
                if (this.rangedCooldown <= 0) {
                    this.rangedCooldown = 25;
                    
                    const angle = Math.atan2(player.aimDirection.y, player.aimDirection.x);
                    const proj = new Projectile(
                        this.x + Math.cos(angle) * 20,
                        this.y + Math.sin(angle) * 20,
                        angle,
                        12,
                        'player'
                    );
                    proj.damage *= 0.5; // Clone does half damage
                    projectiles.push(proj);
                    
                    // Clone particles
                    for (let i = 0; i < 5; i++) {
                        particles.push(new Particle(
                            this.x, this.y, '#4a4a4a',
                            (Math.random() - 0.5) * 4,
                            (Math.random() - 0.5) * 4,
                            15
                        ));
                    }
                }
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.translate(this.x, this.y);
                ctx.scale(this.facing, 1);
                
                // Clone body (darker version of player)
                ctx.fillStyle = '#2a2a2a';
                ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                
                // Shadow effect
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(-this.width / 2 + 4, -this.height / 2 + 4, this.width - 8, this.height / 2);
                
                // Hood
                ctx.fillStyle = '#0a0a0a';
                ctx.beginPath();
                ctx.arc(0, -this.height / 2 + 6, 10, 0, Math.PI * 2);
                ctx.fill();
                
                // Glowing eyes
                ctx.fillStyle = '#00ffff';
                ctx.fillRect(-6, -this.height / 2 + 4, 4, 4);
                ctx.fillRect(2, -this.height / 2 + 4, 4, 4);
                
                ctx.restore();
            }
        }

        // Particle system for visual effects
        class Particle {
            constructor(x, y, color, vx, vy, life) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.vx = vx;
                this.vy = vy;
                this.life = life;
                this.maxLife = life;
                this.size = Math.random() * 3 + 2;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.3; // gravity
                this.life--;
                this.vx *= 0.98;
            }

            draw() {
                const alpha = this.life / this.maxLife;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        // Attack trail effect
        class Trail {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.life = 20;
                this.maxLife = 20;
            }

            update() {
                this.life--;
            }

            draw() {
                const alpha = this.life / this.maxLife;
                ctx.globalAlpha = alpha * 0.6;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        // Projectile class
        class Projectile {
            constructor(x, y, angle, speed, owner) {
                this.x = x;
                this.y = y;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.angle = angle;
                this.radius = owner === 'player' ? 12 : 6; // Larger hitbox for knives
                this.owner = owner;
                this.life = 180;
                this.damage = 15;
                this.explosive = false; // Set by upgrades
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(Math.atan2(this.vy, this.vx));
                
                if (this.owner === 'player') {
                    // Throwing knife - larger, more detailed
                    ctx.fillStyle = '#c0c0c0';
                    ctx.beginPath();
                    ctx.moveTo(12, 0);
                    ctx.lineTo(-8, -4);
                    ctx.lineTo(-8, 4);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Blade shine
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.moveTo(10, 0);
                    ctx.lineTo(2, -1.5);
                    ctx.lineTo(2, 1.5);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Handle wrap
                    ctx.fillStyle = '#654321';
                    ctx.fillRect(-8, -2, 5, 4);
                    
                    // Explosive glow if upgraded
                    if (this.explosive) {
                        ctx.globalAlpha = 0.5;
                        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 20);
                        gradient.addColorStop(0, '#ff6600');
                        gradient.addColorStop(1, 'rgba(255, 102, 0, 0)');
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(0, 0, 20, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                    }
                } else {
                    // Arrow for knights
                    ctx.strokeStyle = '#8b4513';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-8, 0);
                    ctx.lineTo(8, 0);
                    ctx.stroke();
                    
                    // Arrowhead
                    ctx.fillStyle = '#696969';
                    ctx.beginPath();
                    ctx.moveTo(8, 0);
                    ctx.lineTo(4, -4);
                    ctx.lineTo(4, 4);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Fletching
                    ctx.fillStyle = '#8b0000';
                    ctx.fillRect(-8, -2, 3, 4);
                }
                
                ctx.restore();
            }
        }

        // Player class
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 24;
                this.height = 32;
                this.vx = 0;
                this.vy = 0;
                this.speed = 5;
                this.jumpPower = 13;
                this.gravity = 0.6;
                this.onGround = false;
                this.health = 150; // Increased for easier gameplay
                this.maxHealth = 150;
                this.facing = 1;
                
                // Combat
                this.attacking = false;
                this.attackFrame = 0;
                this.attackCooldown = 0;
                this.attackDamage = 25;
                this.attackRange = 50;
                
                // Dash
                this.dashing = false;
                this.dashFrame = 0;
                this.dashCooldown = 0;
                this.dashSpeed = 15;
                
                // Ranged with directional aiming
                this.rangedCooldown = 0;
                this.aimDirection = { x: 1, y: 0 }; // Current aim direction
                
                // Upgrades
                this.upgrades = {
                    multishot: 0, rapidFire: 0, lifesteal: 0, dashAttack: 0,
                    criticalHit: 0, thorns: 0, speedBoost: 0, vampiricAura: 0,
                    explosiveKnives: 0, timeSlowOnKill: 0, poisonDagger: 0,
                    chainLightning: 0, shadowClone: 0, berserker: 0, ghostWalk: 0,
                    bloodRage: 0, frostNova: 0, executeThreshold: 0, knifeStorm: 0,
                    lastStand: 0, magneticKnives: 0, ricochet: 0, shadowStep: 0,
                    armorPierce: 0, doubleJump: 0, vortex: 0, backstab: 0,
                    necromancy: 0, bloodArmor: 0, flurry: 0
                };
                this.usedLastStand = false;
                this.bloodRageStacks = 0;
                this.shield = 0;
                this.hasDoubleJumped = false;
                
                // Special ability slots
                this.special1 = null; // Ability name like 'shadowClone'
                this.special2 = null;
                this.special1Cooldown = 0;
                this.special2Cooldown = 0;
                
                // Ability effects
                this.invincible = false;
                this.damageMultiplier = 1;
                
                // Animation
                this.animFrame = 0;
                this.animCounter = 0;
            }

            attack() {
                if (this.attackCooldown <= 0 && !this.attacking && !this.dashing) {
                    this.attacking = true;
                    this.attackFrame = 0;
                    this.attackCooldown = 30;
                    
                    // Trigger clone attacks
                    for (const clone of shadowClones) {
                        clone.mimicMeleeAttack();
                    }
                    
                    // Attack particles
                    for (let i = 0; i < 15; i++) {
                        const angle = (Math.random() - 0.5) * Math.PI;
                        const speed = Math.random() * 5 + 3;
                        particles.push(new Particle(
                            this.x + this.facing * 30,
                            this.y,
                            Math.random() > 0.5 ? '#1a1a1a' : '#4a4a4a',
                            Math.cos(angle) * speed * this.facing,
                            Math.sin(angle) * speed,
                            20 + Math.random() * 10
                        ));
                    }
                }
            }

            dash() {
                if (this.dashCooldown <= 0 && !this.dashing) {
                    this.dashing = true;
                    this.dashFrame = 0;
                    this.dashCooldown = 60;
                    this.vy = 0;
                }
            }

            shootRanged() {
                if (this.rangedCooldown <= 0) {
                    // Calculate angle from aim direction
                    const angle = Math.atan2(this.aimDirection.y, this.aimDirection.x);
                    
                    // Base cooldown reduced by rapidFire upgrade
                    const cooldown = Math.max(5, 20 - this.upgrades.rapidFire * 3);
                    
                    // Multishot - shoot multiple knives in a spread
                    const knifeCount = 1 + this.upgrades.multishot;
                    const spreadAngle = 0.3;
                    
                    for (let i = 0; i < knifeCount; i++) {
                        const offset = (i - (knifeCount - 1) / 2) * spreadAngle;
                        const proj = new Projectile(
                            this.x + Math.cos(angle) * 20,
                            this.y + Math.sin(angle) * 20,
                            angle + offset,
                            12,
                            'player'
                        );
                        proj.explosive = this.upgrades.explosiveKnives > 0;
                        projectiles.push(proj);
                    }
                    
                    this.rangedCooldown = cooldown;
                    
                    // Trigger clone ranged attacks
                    for (const clone of shadowClones) {
                        clone.mimicRangedAttack();
                    }
                    
                    // Muzzle flash
                    for (let i = 0; i < 10; i++) {
                        particles.push(new Particle(
                            this.x + Math.cos(angle) * 20,
                            this.y + Math.sin(angle) * 20,
                            '#1a1a1a',
                            (Math.random() - 0.5) * 4 + Math.cos(angle) * 3,
                            (Math.random() - 0.5) * 4 + Math.sin(angle) * 3,
                            15
                        ));
                    }
                }
            }

            useSpecial1() {
                if (this.special1 && this.special1Cooldown <= 0) {
                    const ability = upgradeDefinitions[this.special1];
                    this.special1Cooldown = ability.cooldown || 300;
                    
                    switch(this.special1) {
                        case 'shadowClone':
                            // Create actual shadow clone
                            shadowClones.push(new ShadowClone(this.x, this.y));
                            for (let i = 0; i < 30; i++) {
                                particles.push(new Particle(
                                    this.x, this.y, '#2a2a2a',
                                    (Math.random() - 0.5) * 10,
                                    (Math.random() - 0.5) * 10,
                                    50
                                ));
                            }
                            break;
                            
                        case 'fireStorm':
                            // Rain fire projectiles
                            for (let i = 0; i < 12; i++) {
                                setTimeout(() => {
                                    const x = this.x + (Math.random() - 0.5) * 200;
                                    const y = 50;
                                    projectiles.push(new Projectile(
                                        x, y, Math.PI / 2, 8, 'player'
                                    ));
                                    particles.push(new Particle(x, y, '#ff6600', 0, 0, 20));
                                }, i * 100);
                            }
                            break;
                            
                        case 'bladeDance':
                            // Spinning knife attack
                            for (let i = 0; i < 16; i++) {
                                const angle = (Math.PI * 2 / 16) * i;
                                projectiles.push(new Projectile(
                                    this.x, this.y, angle, 12, 'player'
                                ));
                            }
                            break;
                            
                        case 'timeStop':
                            // Freeze all enemies
                            for (const enemy of currentRoom.enemies) {
                                enemy.frozen = true;
                                setTimeout(() => enemy.frozen = false, 3000);
                            }
                            if (currentRoom.boss) {
                                currentRoom.boss.frozen = true;
                                setTimeout(() => currentRoom.boss.frozen = false, 3000);
                            }
                            break;
                            
                        case 'phantomStrike':
                            // Teleport behind nearest enemy
                            let nearest = null;
                            let nearestDist = Infinity;
                            for (const enemy of currentRoom.enemies) {
                                const dist = Math.sqrt((enemy.x - this.x)**2 + (enemy.y - this.y)**2);
                                if (dist < nearestDist) {
                                    nearestDist = dist;
                                    nearest = enemy;
                                }
                            }
                            if (nearest) {
                                this.x = nearest.x - nearest.facing * 50;
                                this.y = nearest.y;
                                nearest.takeDamage(100);
                            }
                            break;
                            
                        case 'omniSlash':
                            // Dash through all enemies
                            for (const enemy of currentRoom.enemies) {
                                enemy.takeDamage(80);
                            }
                            if (currentRoom.boss) currentRoom.boss.takeDamage(80);
                            break;
                            
                        case 'godMode':
                            // Invincible + 10x damage
                            this.invincible = true;
                            this.damageMultiplier = 10;
                            setTimeout(() => {
                                this.invincible = false;
                                this.damageMultiplier = 1;
                            }, 5000);
                            break;
                            
                        case 'armageddon':
                            // Meteors everywhere
                            for (let i = 0; i < 30; i++) {
                                setTimeout(() => {
                                    const x = Math.random() * canvas.width;
                                    projectiles.push(new Projectile(x, 0, Math.PI / 2, 15, 'player'));
                                }, i * 50);
                            }
                            break;
                            
                        case 'infinityEdge':
                            // Summon 20 homing blades
                            for (let i = 0; i < 20; i++) {
                                setTimeout(() => {
                                    const angle = Math.random() * Math.PI * 2;
                                    const proj = new Projectile(this.x, this.y, angle, 10, 'player');
                                    proj.homing = true;
                                    projectiles.push(proj);
                                }, i * 50);
                            }
                            break;
                            
                        case 'divineShield':
                            // Invulnerable for 4 seconds
                            this.invincible = true;
                            setTimeout(() => {
                                this.invincible = false;
                            }, 4000);
                            break;
                            
                        case 'stormCaller':
                            // Lightning strikes all enemies
                            for (const enemy of currentRoom.enemies) {
                                enemy.takeDamage(100);
                                for (let i = 0; i < 20; i++) {
                                    particles.push(new Particle(
                                        enemy.x, enemy.y, '#ffff00',
                                        (Math.random() - 0.5) * 10,
                                        (Math.random() - 0.5) * 10,
                                        30
                                    ));
                                }
                            }
                            if (currentRoom.boss) {
                                currentRoom.boss.takeDamage(100);
                            }
                            break;
                            
                        case 'timestrike':
                            // Stop time for 5 seconds
                            for (const enemy of currentRoom.enemies) {
                                enemy.frozen = true;
                                setTimeout(() => enemy.frozen = false, 5000);
                            }
                            if (currentRoom.boss) {
                                currentRoom.boss.frozen = true;
                                setTimeout(() => currentRoom.boss.frozen = false, 5000);
                            }
                            break;
                            
                        case 'soulReaper':
                            // Instantly kill all non-boss enemies
                            for (const enemy of currentRoom.enemies) {
                                enemy.health = 0;
                                for (let i = 0; i < 30; i++) {
                                    particles.push(new Particle(
                                        enemy.x, enemy.y, '#8b008b',
                                        (Math.random() - 0.5) * 15,
                                        (Math.random() - 0.5) * 15,
                                        40
                                    ));
                                }
                            }
                            break;
                            
                        case 'ragnarok':
                            // Screen-wide explosion
                            for (const enemy of currentRoom.enemies) {
                                enemy.takeDamage(200);
                            }
                            if (currentRoom.boss) {
                                currentRoom.boss.takeDamage(200);
                            }
                            
                            // Massive explosion effect
                            for (let i = 0; i < 200; i++) {
                                particles.push(new Particle(
                                    Math.random() * canvas.width,
                                    Math.random() * canvas.height,
                                    ['#ff0000', '#ff8800', '#ffff00'][Math.floor(Math.random() * 3)],
                                    (Math.random() - 0.5) * 20,
                                    (Math.random() - 0.5) * 20,
                                    50
                                ));
                            }
                            break;
                    }
                }
            }

            useSpecial2() {
                if (this.special2 && this.special2Cooldown <= 0) {
                    const ability = upgradeDefinitions[this.special2];
                    this.special2Cooldown = ability.cooldown || 300;
                    
                    // Same implementations as useSpecial1
                    switch(this.special2) {
                        case 'shadowClone':
                            shadowClones.push(new ShadowClone(this.x, this.y));
                            for (let i = 0; i < 30; i++) {
                                particles.push(new Particle(
                                    this.x, this.y, '#2a2a2a',
                                    (Math.random() - 0.5) * 10,
                                    (Math.random() - 0.5) * 10,
                                    50
                                ));
                            }
                            break;
                        case 'fireStorm':
                            for (let i = 0; i < 12; i++) {
                                setTimeout(() => {
                                    const x = this.x + (Math.random() - 0.5) * 200;
                                    projectiles.push(new Projectile(x, 50, Math.PI / 2, 8, 'player'));
                                }, i * 100);
                            }
                            break;
                        case 'bladeDance':
                            for (let i = 0; i < 16; i++) {
                                const angle = (Math.PI * 2 / 16) * i;
                                projectiles.push(new Projectile(this.x, this.y, angle, 12, 'player'));
                            }
                            break;
                        case 'timeStop':
                            for (const enemy of currentRoom.enemies) {
                                enemy.frozen = true;
                                setTimeout(() => enemy.frozen = false, 3000);
                            }
                            if (currentRoom.boss) {
                                currentRoom.boss.frozen = true;
                                setTimeout(() => currentRoom.boss.frozen = false, 3000);
                            }
                            break;
                        case 'phantomStrike':
                            let nearest = null;
                            let nearestDist = Infinity;
                            for (const enemy of currentRoom.enemies) {
                                const dist = Math.sqrt((enemy.x - this.x)**2 + (enemy.y - this.y)**2);
                                if (dist < nearestDist) {
                                    nearestDist = dist;
                                    nearest = enemy;
                                }
                            }
                            if (nearest) {
                                this.x = nearest.x - nearest.facing * 50;
                                this.y = nearest.y;
                                nearest.takeDamage(100);
                            }
                            break;
                        case 'omniSlash':
                            for (const enemy of currentRoom.enemies) enemy.takeDamage(80);
                            if (currentRoom.boss) currentRoom.boss.takeDamage(80);
                            break;
                        case 'godMode':
                            this.invincible = true;
                            this.damageMultiplier = 10;
                            setTimeout(() => {
                                this.invincible = false;
                                this.damageMultiplier = 1;
                            }, 5000);
                            break;
                        case 'armageddon':
                            for (let i = 0; i < 30; i++) {
                                setTimeout(() => {
                                    const x = Math.random() * canvas.width;
                                    projectiles.push(new Projectile(x, 0, Math.PI / 2, 15, 'player'));
                                }, i * 50);
                            }
                            break;
                        case 'infinityEdge':
                            for (let i = 0; i < 20; i++) {
                                setTimeout(() => {
                                    const angle = Math.random() * Math.PI * 2;
                                    const proj = new Projectile(this.x, this.y, angle, 10, 'player');
                                    proj.homing = true;
                                    projectiles.push(proj);
                                }, i * 50);
                            }
                            break;
                        case 'divineShield':
                            this.invincible = true;
                            setTimeout(() => this.invincible = false, 4000);
                            break;
                        case 'stormCaller':
                            for (const enemy of currentRoom.enemies) {
                                enemy.takeDamage(100);
                                for (let i = 0; i < 20; i++) {
                                    particles.push(new Particle(
                                        enemy.x, enemy.y, '#ffff00',
                                        (Math.random() - 0.5) * 10,
                                        (Math.random() - 0.5) * 10,
                                        30
                                    ));
                                }
                            }
                            if (currentRoom.boss) currentRoom.boss.takeDamage(100);
                            break;
                        case 'timestrike':
                            for (const enemy of currentRoom.enemies) {
                                enemy.frozen = true;
                                setTimeout(() => enemy.frozen = false, 5000);
                            }
                            if (currentRoom.boss) {
                                currentRoom.boss.frozen = true;
                                setTimeout(() => currentRoom.boss.frozen = false, 5000);
                            }
                            break;
                        case 'soulReaper':
                            for (const enemy of currentRoom.enemies) {
                                enemy.health = 0;
                                for (let i = 0; i < 30; i++) {
                                    particles.push(new Particle(
                                        enemy.x, enemy.y, '#8b008b',
                                        (Math.random() - 0.5) * 15,
                                        (Math.random() - 0.5) * 15,
                                        40
                                    ));
                                }
                            }
                            break;
                        case 'ragnarok':
                            for (const enemy of currentRoom.enemies) enemy.takeDamage(200);
                            if (currentRoom.boss) currentRoom.boss.takeDamage(200);
                            for (let i = 0; i < 200; i++) {
                                particles.push(new Particle(
                                    Math.random() * canvas.width,
                                    Math.random() * canvas.height,
                                    ['#ff0000', '#ff8800', '#ffff00'][Math.floor(Math.random() * 3)],
                                    (Math.random() - 0.5) * 20,
                                    (Math.random() - 0.5) * 20,
                                    50
                                ));
                            }
                            break;
                    }
                }
            }

            update() {
                // Apply speed boost upgrade
                const speedMultiplier = 1 + (this.upgrades.speedBoost * 0.15);
                this.speed = 5 * speedMultiplier;
                
                // Vampiric aura - passive health regen
                if (this.upgrades.vampiricAura > 0 && Math.random() < 0.01) {
                    this.health = Math.min(this.health + 0.5, this.maxHealth);
                }
                
                // Cooldowns
                if (this.attackCooldown > 0) this.attackCooldown--;
                if (this.dashCooldown > 0) this.dashCooldown--;
                if (this.rangedCooldown > 0) this.rangedCooldown--;
                if (this.special1Cooldown > 0) this.special1Cooldown--;
                if (this.special2Cooldown > 0) this.special2Cooldown--;
                
                // Attack animation
                if (this.attacking) {
                    this.attackFrame++;
                    if (this.attackFrame > 15) {
                        this.attacking = false;
                    }
                }
                
                // Dash
                if (this.dashing) {
                    this.dashFrame++;
                    this.vx = this.dashSpeed * this.facing;
                    
                    // Dash trail
                    if (this.dashFrame % 2 === 0) {
                        trails.push(new Trail(this.x, this.y, '#2a2a2a'));
                    }
                    
                    // Dash attack upgrade - damage enemies during dash (FIX: prevent negative health)
                    if (this.upgrades.dashAttack > 0) {
                        for (const enemy of currentRoom.enemies) {
                            const dx = enemy.x - this.x;
                            const dy = enemy.y - this.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < 40 && !enemy.dashedThisFrame) {
                                enemy.dashedThisFrame = true;
                                enemy.takeDamage(10 * this.upgrades.dashAttack);
                            }
                        }
                        // Reset dash flag after dash ends
                        if (this.dashFrame === 1) {
                            for (const enemy of currentRoom.enemies) {
                                enemy.dashedThisFrame = false;
                            }
                        }
                    }
                    
                    if (this.dashFrame > 10) {
                        this.dashing = false;
                        this.vx = 0;
                    }
                }
                
                // Physics
                if (!this.dashing) {
                    this.vy += this.gravity;
                }
                
                this.x += this.vx;
                this.y += this.vy;
                
                // Platform collision
                this.onGround = false;
                for (const platform of currentRoom.platforms) {
                    if (this.x + this.width / 2 > platform.x &&
                        this.x - this.width / 2 < platform.x + platform.width &&
                        this.y + this.height / 2 > platform.y &&
                        this.y + this.height / 2 < platform.y + 20 &&
                        this.vy >= 0) {
                        this.y = platform.y - this.height / 2;
                        this.vy = 0;
                        this.onGround = true;
                        this.hasDoubleJumped = false;
                    }
                }
                
                // Ground
                if (this.y > canvas.height - 50 - this.height / 2) {
                    this.y = canvas.height - 50 - this.height / 2;
                    this.vy = 0;
                    this.onGround = true;
                    this.hasDoubleJumped = false;
                }
                
                // Boundaries
                if (this.x < this.width / 2) this.x = this.width / 2;
                if (this.x > canvas.width - this.width / 2) this.x = canvas.width - this.width / 2;
                
                // Animation
                if (!this.dashing && !this.attacking) {
                    this.animCounter++;
                    if (this.animCounter > 8) {
                        this.animFrame = (this.animFrame + 1) % 4;
                        this.animCounter = 0;
                    }
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.facing, 1);
                
                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.ellipse(0, this.height / 2 + 5, this.width / 2, 5, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Dash effect
                if (this.dashing) {
                    ctx.globalAlpha = 0.5;
                    for (let i = 0; i < 3; i++) {
                        ctx.fillStyle = '#1a1a1a';
                        ctx.fillRect(-this.width / 2 - i * 10, -this.height / 2, this.width, this.height);
                    }
                    ctx.globalAlpha = 1;
                }
                
                // Body (assassin in dark cloak)
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                
                // Hood
                ctx.fillStyle = '#0a0a0a';
                ctx.beginPath();
                ctx.arc(0, -this.height / 2 + 6, 10, 0, Math.PI * 2);
                ctx.fill();
                
                // Face shadow
                ctx.fillStyle = '#2a2a2a';
                ctx.fillRect(-this.width / 2 + 6, -this.height / 2 + 8, this.width - 12, 8);
                
                // Eyes (glowing)
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(2, -8, 3, 2);
                
                // Cloak
                ctx.fillStyle = '#0a0a0a';
                ctx.beginPath();
                ctx.moveTo(-this.width / 2, -this.height / 2 + 12);
                ctx.lineTo(-this.width / 2 - 6, -this.height / 2 + 20 + Math.sin(Date.now() / 100) * 3);
                ctx.lineTo(-this.width / 2 - 4, this.height / 2);
                ctx.lineTo(-this.width / 2, this.height / 2);
                ctx.fill();
                
                // Belt
                ctx.fillStyle = '#4a2511';
                ctx.fillRect(-this.width / 2, 0, this.width, 4);
                
                // Weapon (dagger)
                if (this.attacking) {
                    const attackAngle = (this.attackFrame / 15) * Math.PI * 1.5 - Math.PI / 4;
                    ctx.save();
                    ctx.rotate(attackAngle);
                    
                    // Dagger blade (longer, knife-shaped)
                    ctx.fillStyle = '#c0c0c0';
                    ctx.beginPath();
                    ctx.moveTo(40, 0);
                    ctx.lineTo(10, -3);
                    ctx.lineTo(10, 3);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Blade shine
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.moveTo(35, 0);
                    ctx.lineTo(20, -1);
                    ctx.lineTo(20, 1);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Handle
                    ctx.fillStyle = '#8b4513';
                    ctx.fillRect(8, -2, 8, 4);
                    
                    // Pommel
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.arc(8, 0, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                }
                
                ctx.restore();
            }

            takeDamage(amount) {
                // Invincibility check
                if (this.invincible) return;
                
                // Thorns upgrade - reflect damage
                if (this.upgrades.thorns > 0) {
                    for (const enemy of currentRoom.enemies) {
                        const dx = enemy.x - this.x;
                        const dy = enemy.y - this.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 100) {
                            enemy.takeDamage(amount * 0.3 * this.upgrades.thorns);
                        }
                    }
                }
                
                this.health -= amount;
                if (this.health < 0) this.health = 0;
                
                // Damage particles
                for (let i = 0; i < 20; i++) {
                    particles.push(new Particle(
                        this.x,
                        this.y,
                        '#ff0066',
                        (Math.random() - 0.5) * 8,
                        (Math.random() - 0.5) * 8,
                        30
                    ));
                }
            }
        }

        // Enemy class
        class Enemy {
            constructor(x, y, type = 'basic') {
                this.x = x;
                this.y = y;
                this.width = 28;
                this.height = 32;
                this.vx = 0;
                this.vy = 0;
                this.gravity = 0.6;
                
                // Enemy types: basic (sword), advanced (archer), heavy (tank), assassin (fast), mage (ranged caster)
                const enemyStats = {
                    'basic': { health: 35, speed: 2, color: '#808080', damage: 8 },
                    'advanced': { health: 40, speed: 2.5, color: '#8b4513', damage: 10 },
                    'heavy': { health: 70, speed: 1, color: '#4a4a4a', damage: 12 },
                    'assassin': { health: 25, speed: 4, color: '#1a1a1a', damage: 6 },
                    'mage': { health: 25, speed: 1.5, color: '#4b0082', damage: 6 } // Reduced from 30 HP and 8 damage
                };
                
                const stats = enemyStats[type] || enemyStats['basic'];
                this.health = stats.health;
                this.maxHealth = stats.health;
                this.speed = stats.speed;
                this.color = stats.color;
                this.baseDamage = stats.damage;
                this.type = type;
                this.facing = -1;
                this.onGround = false;
                
                this.attackCooldown = 0;
                this.shootCooldown = 0;
                this.teleportCooldown = 0;
                this.state = 'idle';
                this.stateTimer = 0;
                
                this.animFrame = 0;
                this.animCounter = 0;
            }

            update() {
                // If frozen by Time Stop, skip AI
                if (this.frozen) {
                    this.vy += this.gravity;
                    this.y += this.vy;
                    if (this.y > canvas.height - 50 - this.height / 2) {
                        this.y = canvas.height - 50 - this.height / 2;
                        this.vy = 0;
                    }
                    return;
                }
                
                this.vy += this.gravity;
                this.x += this.vx;
                this.y += this.vy;
                
                // Platform collision
                this.onGround = false;
                for (const platform of currentRoom.platforms) {
                    if (this.x + this.width / 2 > platform.x &&
                        this.x - this.width / 2 < platform.x + platform.width &&
                        this.y + this.height / 2 > platform.y &&
                        this.y + this.height / 2 < platform.y + 20 &&
                        this.vy >= 0) {
                        this.y = platform.y - this.height / 2;
                        this.vy = 0;
                        this.onGround = true;
                    }
                }
                
                // Ground
                if (this.y > canvas.height - 50 - this.height / 2) {
                    this.y = canvas.height - 50 - this.height / 2;
                    this.vy = 0;
                    this.onGround = true;
                }
                
                // AI
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                this.facing = dx > 0 ? 1 : -1;
                
                if (this.attackCooldown > 0) this.attackCooldown--;
                if (this.shootCooldown > 0) this.shootCooldown--;
                if (this.teleportCooldown > 0) this.teleportCooldown--;
                
                // Type-specific AI
                switch(this.type) {
                    case 'basic':
                        // Sword knight - charges and melees
                        if (dist < 300) {
                            if (dist > 60) {
                                this.vx = this.facing * this.speed;
                            } else {
                                this.vx = 0;
                                if (this.attackCooldown <= 0 && dist < 50) {
                                    this.attackCooldown = 60;
                                    if (dist < 40) {
                                        player.takeDamage(this.baseDamage);
                                    }
                                }
                            }
                        } else {
                            this.vx *= 0.9;
                        }
                        break;
                        
                    case 'advanced':
                        // Archer - keeps distance and shoots
                        if (dist < 350 && dist > 150) {
                            this.vx = 0;
                            if (this.shootCooldown <= 0) {
                                this.shootCooldown = 90;
                                const angle = Math.atan2(dy, dx);
                                projectiles.push(new Projectile(
                                    this.x + this.facing * 15,
                                    this.y,
                                    angle,
                                    8,
                                    'enemy'
                                ));
                            }
                        } else if (dist < 150) {
                            // Back away
                            this.vx = -this.facing * this.speed;
                        } else if (dist < 400) {
                            this.vx = this.facing * this.speed * 0.8;
                        } else {
                            this.vx *= 0.9;
                        }
                        break;
                        
                    case 'heavy':
                        // Tank - slow but tanky, devastating melee
                        if (dist < 250) {
                            if (dist > 70) {
                                this.vx = this.facing * this.speed;
                            } else {
                                this.vx = 0;
                                if (this.attackCooldown <= 0) {
                                    this.attackCooldown = 90;
                                    if (dist < 60) {
                                        player.takeDamage(this.baseDamage);
                                        // Knockback
                                        player.vx = this.facing * 8;
                                    }
                                }
                            }
                        } else {
                            this.vx *= 0.9;
                        }
                        break;
                        
                    case 'assassin':
                        // Fast, unpredictable movement
                        if (Math.random() < 0.03) {
                            this.vx = (Math.random() - 0.5) * this.speed * 2;
                        }
                        
                        if (dist < 200) {
                            if (dist > 50) {
                                this.vx = this.facing * this.speed;
                            } else {
                                if (this.attackCooldown <= 0) {
                                    this.attackCooldown = 40;
                                    if (dist < 45) {
                                        player.takeDamage(this.baseDamage);
                                    }
                                }
                            }
                        } else {
                            this.vx *= 0.95;
                        }
                        break;
                        
                    case 'mage':
                        // Ranged caster, teleports occasionally (NERFED)
                        if (dist < 400 && dist > 200) {
                            this.vx = 0;
                            if (this.shootCooldown <= 0) {
                                this.shootCooldown = 100; // Increased from 70
                                const angle = Math.atan2(dy, dx);
                                // Fire burst of 2 projectiles (reduced from 3)
                                for (let i = -0.5; i <= 0.5; i++) {
                                    projectiles.push(new Projectile(
                                        this.x,
                                        this.y,
                                        angle + i * 0.2,
                                        8, // Reduced speed from 9
                                        'enemy'
                                    ));
                                }
                            }
                        } else if (dist < 150 && this.teleportCooldown <= 0) { // Changed from 200 to 150
                            // Teleport away (with bounds checking) - less frequent
                            this.teleportCooldown = 200; // Increased from 150
                            const teleAngle = Math.random() * Math.PI * 2;
                            let newX = this.x + Math.cos(teleAngle) * 150;
                            let newY = this.y + Math.sin(teleAngle) * 100;
                            
                            // Keep within bounds
                            newX = Math.max(50, Math.min(canvas.width - 50, newX));
                            newY = Math.max(100, Math.min(canvas.height - 100, newY));
                            
                            this.x = newX;
                            this.y = newY;
                            
                            // Teleport effect
                            for (let i = 0; i < 20; i++) {
                                particles.push(new Particle(
                                    this.x, this.y, '#4b0082',
                                    (Math.random() - 0.5) * 10,
                                    (Math.random() - 0.5) * 10,
                                    30
                                ));
                            }
                        } else if (dist > 400) {
                            this.vx = this.facing * this.speed * 0.7;
                        } else {
                            this.vx *= 0.9;
                        }
                        break;
                }
                
                // Animation
                this.animCounter++;
                if (this.animCounter > 10) {
                    this.animFrame = (this.animFrame + 1) % 3;
                    this.animCounter = 0;
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.facing, 1);
                
                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.ellipse(0, this.height / 2 + 5, this.width / 2, 5, 0, 0, Math.PI * 2);
                ctx.fill();
                
                switch(this.type) {
                    case 'basic':
                        // Sword Knight - Heavy armor (silver/gray)
                        ctx.fillStyle = '#808080';
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        ctx.fillStyle = '#a0a0a0';
                        ctx.fillRect(-this.width / 2 + 4, -this.height / 2 + 4, this.width - 8, this.height / 2);
                        
                        ctx.fillStyle = '#696969';
                        ctx.beginPath();
                        ctx.arc(0, -this.height / 2 + 6, 10, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = '#000000';
                        ctx.fillRect(-6, -this.height / 2 + 4, 12, 3);
                        
                        // Shield
                        ctx.fillStyle = '#8b0000';
                        ctx.beginPath();
                        ctx.arc(-8, 0, 8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#ffd700';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        // Sword
                        ctx.strokeStyle = '#c0c0c0';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(8, -4);
                        ctx.lineTo(8, -16);
                        ctx.stroke();
                        
                        ctx.fillStyle = '#8b4513';
                        ctx.fillRect(6, -6, 4, 6);
                        break;
                        
                    case 'advanced':
                        // Archer Knight - Lighter armor
                        ctx.fillStyle = '#8b4513';
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        ctx.fillStyle = '#654321';
                        ctx.fillRect(-this.width / 2 + 4, -this.height / 2 + 8, this.width - 8, this.height - 12);
                        
                        ctx.fillStyle = '#a0a0a0';
                        ctx.beginPath();
                        ctx.arc(0, -this.height / 2 + 6, 9, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = '#ffe0bd';
                        ctx.fillRect(-4, -this.height / 2 + 4, 8, 6);
                        
                        ctx.fillStyle = '#000000';
                        ctx.fillRect(-3, -this.height / 2 + 5, 2, 2);
                        ctx.fillRect(1, -this.height / 2 + 5, 2, 2);
                        
                        // Bow
                        ctx.strokeStyle = '#8b4513';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(10, 0, 12, -Math.PI/3, Math.PI/3);
                        ctx.stroke();
                        
                        ctx.strokeStyle = '#d3d3d3';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(10 + Math.cos(-Math.PI/3) * 12, Math.sin(-Math.PI/3) * 12);
                        ctx.lineTo(10 + Math.cos(Math.PI/3) * 12, Math.sin(Math.PI/3) * 12);
                        ctx.stroke();
                        
                        ctx.fillStyle = '#654321';
                        ctx.fillRect(-10, this.height / 4, 4, 8);
                        break;
                        
                    case 'heavy':
                        // Tank - Massive armor
                        ctx.fillStyle = '#4a4a4a';
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        // Extra armor plates
                        ctx.fillStyle = '#5a5a5a';
                        ctx.fillRect(-this.width / 2 + 2, -this.height / 2 + 2, this.width - 4, 8);
                        ctx.fillRect(-this.width / 2 + 2, 0, this.width - 4, 6);
                        
                        // Helmet with spikes
                        ctx.fillStyle = '#3a3a3a';
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, 10);
                        
                        // Spikes
                        ctx.fillStyle = '#8b4513';
                        for (let i = -1; i <= 1; i++) {
                            ctx.beginPath();
                            ctx.moveTo(i * 8, -this.height / 2);
                            ctx.lineTo(i * 8 - 3, -this.height / 2 - 6);
                            ctx.lineTo(i * 8 + 3, -this.height / 2 - 6);
                            ctx.fill();
                        }
                        
                        // Visor
                        ctx.fillStyle = '#ff0000';
                        ctx.fillRect(-8, -this.height / 2 + 12, 16, 3);
                        
                        // Giant hammer
                        ctx.fillStyle = '#696969';
                        ctx.fillRect(8, -8, 4, 16);
                        ctx.fillRect(6, -12, 8, 8);
                        break;
                        
                    case 'assassin':
                        // Fast assassin - Dark and slim
                        ctx.fillStyle = '#1a1a1a';
                        ctx.fillRect(-this.width / 2 + 4, -this.height / 2, this.width - 8, this.height);
                        
                        // Hood
                        ctx.fillStyle = '#0a0a0a';
                        ctx.beginPath();
                        ctx.arc(0, -this.height / 2 + 4, 8, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Red eyes
                        ctx.fillStyle = '#ff0000';
                        ctx.fillRect(-3, -this.height / 2 + 6, 2, 2);
                        ctx.fillRect(1, -this.height / 2 + 6, 2, 2);
                        
                        // Daggers
                        ctx.fillStyle = '#c0c0c0';
                        ctx.beginPath();
                        ctx.moveTo(8, 0);
                        ctx.lineTo(14, -2);
                        ctx.lineTo(14, 2);
                        ctx.fill();
                        
                        // Shadow trail
                        ctx.globalAlpha = 0.3;
                        ctx.fillStyle = '#1a1a1a';
                        ctx.fillRect(-this.width / 2 - 8, -this.height / 2, this.width - 8, this.height);
                        ctx.globalAlpha = 1;
                        break;
                        
                    case 'mage':
                        // Mage - Robes and staff
                        ctx.fillStyle = '#4b0082';
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        // Robe trim
                        ctx.fillStyle = '#8b008b';
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, 4);
                        ctx.fillRect(-this.width / 2, this.height / 2 - 4, this.width, 4);
                        
                        // Hood
                        ctx.fillStyle = '#6a0dad';
                        ctx.beginPath();
                        ctx.arc(0, -this.height / 2 + 6, 10, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Glowing eyes
                        ctx.fillStyle = '#00ffff';
                        ctx.beginPath();
                        ctx.arc(-3, -this.height / 2 + 6, 2, 0, Math.PI * 2);
                        ctx.arc(3, -this.height / 2 + 6, 2, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Staff with crystal
                        ctx.strokeStyle = '#8b4513';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(10, this.height / 2);
                        ctx.lineTo(10, -this.height / 2 + 4);
                        ctx.stroke();
                        
                        // Crystal
                        ctx.fillStyle = '#00ffff';
                        ctx.globalAlpha = 0.7 + Math.sin(Date.now() / 200) * 0.3;
                        ctx.beginPath();
                        ctx.arc(10, -this.height / 2 + 4, 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                        break;
                }
                
                ctx.restore();
                
                // Health bar
                if (this.health < this.maxHealth) {
                    ctx.fillStyle = '#333';
                    ctx.fillRect(this.x - 15, this.y - this.height / 2 - 10, 30, 4);
                    ctx.fillStyle = '#8b0000';
                    ctx.fillRect(this.x - 15, this.y - this.height / 2 - 10, 30 * (this.health / this.maxHealth), 4);
                }
            }

            takeDamage(amount) {
                this.health -= amount;
                
                // Damage particles
                for (let i = 0; i < 10; i++) {
                    particles.push(new Particle(
                        this.x,
                        this.y,
                        '#ff6600',
                        (Math.random() - 0.5) * 6,
                        (Math.random() - 0.5) * 6 - 2,
                        20
                    ));
                }
            }
        }

        // Boss class
        class Boss {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.width = 60;
                this.height = 70;
                this.vx = 0;
                this.vy = 0;
                this.gravity = 0.6;
                this.type = type;
                this.facing = -1;
                this.onGround = false;
                
                // Boss stats based on type - EASIER (Further Reduced)
                const bossStats = {
                    'Crimson Knight': { health: 400, speed: 3, color: '#8b0000', damage: 15 },
                    'Shadow Lord': { health: 350, speed: 4.5, color: '#2a2a2a', damage: 12 },
                    'Frost Warden': { health: 380, speed: 2.5, color: '#00bfff', damage: 14 },
                    'Flame Tyrant': { health: 360, speed: 3.5, color: '#ff4500', damage: 16 },
                    'Stone Golem': { health: 550, speed: 1.5, color: '#696969', damage: 20 },
                    'Toxic Assassin': { health: 320, speed: 5.5, color: '#228b22', damage: 12 },
                    'Thunder King': { health: 420, speed: 3.5, color: '#ffd700', damage: 18 },
                    'Necromancer': { health: 300, speed: 2.5, color: '#4b0082', damage: 14 },
                    'Blood Reaper': { health: 400, speed: 4, color: '#dc143c', damage: 16 },
                    'Void Walker': { health: 380, speed: 4.5, color: '#483d8b', damage: 15 }
                };
                
                const stats = bossStats[type];
                this.health = stats.health;
                this.maxHealth = stats.health;
                this.speed = stats.speed;
                this.color = stats.color;
                this.baseDamage = stats.damage;
                
                this.attackCooldown = 0;
                this.specialCooldown = 0;
                this.phase = 1;
                this.animFrame = 0;
                this.isBoss = true;
            }

            update() {
                // If frozen by Time Stop, skip AI
                if (this.frozen) {
                    this.vy += this.gravity;
                    this.y += this.vy;
                    if (this.y > canvas.height - 50 - this.height / 2) {
                        this.y = canvas.height - 50 - this.height / 2;
                        this.vy = 0;
                    }
                    return;
                }
                
                this.vy += this.gravity;
                this.x += this.vx;
                this.y += this.vy;
                
                // Platform collision
                this.onGround = false;
                for (const platform of currentRoom.platforms) {
                    if (this.x + this.width / 2 > platform.x &&
                        this.x - this.width / 2 < platform.x + platform.width &&
                        this.y + this.height / 2 > platform.y &&
                        this.y + this.height / 2 < platform.y + 20 &&
                        this.vy >= 0) {
                        this.y = platform.y - this.height / 2;
                        this.vy = 0;
                        this.onGround = true;
                    }
                }
                
                // Ground
                if (this.y > canvas.height - 50 - this.height / 2) {
                    this.y = canvas.height - 50 - this.height / 2;
                    this.vy = 0;
                    this.onGround = true;
                }
                
                // Phase transition - gets harder at 50% HP (reduced difficulty)
                if (this.health < this.maxHealth / 2 && this.phase === 1) {
                    this.phase = 2;
                    this.speed *= 1.4; // Was 1.8
                    this.baseDamage *= 1.2; // Was 1.5
                    
                    // Big phase change effect
                    for (let i = 0; i < 80; i++) {
                        particles.push(new Particle(
                            this.x, this.y, this.color,
                            (Math.random() - 0.5) * 20,
                            (Math.random() - 0.5) * 20,
                            50
                        ));
                    }
                }
                
                // AI behavior - MUCH MORE AGGRESSIVE
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                this.facing = dx > 0 ? 1 : -1;
                
                if (this.attackCooldown > 0) this.attackCooldown--;
                if (this.specialCooldown > 0) this.specialCooldown--;
                
                // Faster cooldowns in phase 2
                const attackSpeed = this.phase === 2 ? 0.7 : 1; // Less aggressive in phase 2 (was 0.6)
                const specialSpeed = this.phase === 2 ? 0.6 : 1; // Less aggressive in phase 2 (was 0.5)
                
                // Boss-specific aggressive behaviors
                switch(this.type) {
                    case 'Crimson Knight':
                        if (dist > 80) {
                            this.vx = this.facing * this.speed;
                        } else {
                            this.vx = 0;
                            if (this.attackCooldown <= 0) {
                                this.attackCooldown = Math.floor(30 * attackSpeed);
                                if (dist < 90) player.takeDamage(this.baseDamage);
                            }
                        }
                        
                        // Shield bash - VERY aggressive
                        if (this.specialCooldown <= 0 && dist < 200) {
                            this.specialCooldown = Math.floor(80 * specialSpeed);
                            this.vx = this.facing * this.speed * 4;
                            // Damage during charge
                            if (dist < 70) player.takeDamage(this.baseDamage * 1.5);
                        }
                        break;
                        
                    case 'Shadow Lord':
                        // Teleport frequently and unpredictably (NERFED)
                        if (this.specialCooldown <= 0 && dist > 200) { // Only teleport when far away, not randomly
                            this.specialCooldown = Math.floor(120 * specialSpeed); // Increased from 60 - teleports half as often
                            const angle = Math.atan2(dy, dx) + (Math.random() - 0.5) * Math.PI;
                            let newX = player.x + Math.cos(angle) * 150; // Teleport farther away
                            let newY = player.y + Math.sin(angle) * 100;
                            
                            // Keep within bounds
                            newX = Math.max(60, Math.min(canvas.width - 60, newX));
                            newY = Math.max(100, Math.min(canvas.height - 100, newY));
                            
                            this.x = newX;
                            this.y = newY;
                            
                            // No damage on teleport anymore
                            
                            for (let i = 0; i < 30; i++) {
                                particles.push(new Particle(
                                    this.x, this.y, '#2a2a2a',
                                    (Math.random() - 0.5) * 12,
                                    (Math.random() - 0.5) * 12,
                                    35
                                ));
                            }
                        }
                        
                        if (dist > 60) {
                            this.vx = this.facing * this.speed;
                        } else if (this.attackCooldown <= 0) {
                            this.attackCooldown = Math.floor(30 * attackSpeed); // Increased from 25
                            if (dist < 75) player.takeDamage(this.baseDamage);
                        }
                        break;
                        
                    case 'Frost Warden':
                        this.vx = this.facing * this.speed * 0.7;
                        
                        // Ice projectile barrage
                        if (this.attackCooldown <= 0 && dist < 450) {
                            this.attackCooldown = Math.floor(40 * attackSpeed);
                            const angle = Math.atan2(dy, dx);
                            const projCount = this.phase === 2 ? 5 : 3;
                            for (let i = 0; i < projCount; i++) {
                                const offset = (i - (projCount - 1) / 2) * 0.25;
                                projectiles.push(new Projectile(
                                    this.x, this.y, angle + offset, 11, 'enemy'
                                ));
                            }
                        }
                        
                        // Ice nova
                        if (this.specialCooldown <= 0 && dist < 150) {
                            this.specialCooldown = Math.floor(100 * specialSpeed);
                            for (let i = 0; i < 8; i++) {
                                const angle = (Math.PI * 2 / 8) * i;
                                projectiles.push(new Projectile(
                                    this.x, this.y, angle, 9, 'enemy'
                                ));
                            }
                        }
                        break;
                        
                    case 'Flame Tyrant':
                        if (dist > 100) {
                            this.vx = this.facing * this.speed;
                        }
                        
                        // Rapid fire breath
                        if (this.attackCooldown <= 0 && dist < 300) {
                            this.attackCooldown = Math.floor(15 * attackSpeed);
                            const angle = Math.atan2(dy, dx);
                            projectiles.push(new Projectile(
                                this.x + this.facing * 35, this.y, angle, 13, 'enemy'
                            ));
                        }
                        
                        // Fire wave
                        if (this.specialCooldown <= 0) {
                            this.specialCooldown = Math.floor(70 * specialSpeed);
                            for (let i = -2; i <= 2; i++) {
                                projectiles.push(new Projectile(
                                    this.x, this.y, i * 0.4, 10, 'enemy'
                                ));
                            }
                        }
                        break;
                        
                    case 'Stone Golem':
                        if (dist > 80) {
                            this.vx = this.facing * this.speed;
                        } else {
                            this.vx = 0;
                            if (this.attackCooldown <= 0) {
                                this.attackCooldown = Math.floor(60 * attackSpeed);
                                // Massive ground slam
                                if (dist < 180) {
                                    player.takeDamage(this.baseDamage);
                                    player.vx = this.facing * 10;
                                    
                                    for (let i = 0; i < 40; i++) {
                                        particles.push(new Particle(
                                            this.x, this.y + this.height/2,
                                            '#8b4513',
                                            (Math.random() - 0.5) * 25,
                                            -Math.random() * 12,
                                            35
                                        ));
                                    }
                                }
                            }
                        }
                        break;
                        
                    case 'Toxic Assassin':
                        // Extremely erratic and fast
                        if (Math.random() < 0.08) {
                            this.vx = (Math.random() - 0.5) * this.speed * 2.5;
                        }
                        
                        if (dist < 70 && this.attackCooldown <= 0) {
                            this.attackCooldown = Math.floor(20 * attackSpeed);
                            player.takeDamage(this.baseDamage);
                        }
                        
                        // Poison dart spam
                        if (this.specialCooldown <= 0 && dist < 350) {
                            this.specialCooldown = Math.floor(35 * specialSpeed);
                            const angle = Math.atan2(dy, dx);
                            const dartCount = this.phase === 2 ? 3 : 2;
                            for (let i = 0; i < dartCount; i++) {
                                setTimeout(() => {
                                    projectiles.push(new Projectile(
                                        this.x, this.y, angle + (Math.random() - 0.5) * 0.3, 16, 'enemy'
                                    ));
                                }, i * 100);
                            }
                        }
                        break;
                        
                    case 'Thunder King':
                        if (dist > 90) {
                            this.vx = this.facing * this.speed;
                        }
                        
                        // Lightning strikes - multiple
                        if (this.specialCooldown <= 0) {
                            this.specialCooldown = Math.floor(70 * specialSpeed);
                            const strikeCount = this.phase === 2 ? 3 : 2;
                            
                            for (let i = 0; i < strikeCount; i++) {
                                setTimeout(() => {
                                    const targetX = player.x;
                                    const targetY = player.y;
                                    
                                    // Visual warning
                                    for (let j = 0; j < 20; j++) {
                                        particles.push(new Particle(
                                            targetX, targetY - 200,
                                            '#ffff00',
                                            (Math.random() - 0.5) * 5,
                                            Math.random() * 15,
                                            30
                                        ));
                                    }
                                    
                                    setTimeout(() => {
                                        const pdx = player.x - targetX;
                                        const pdy = player.y - targetY;
                                        const pdist = Math.sqrt(pdx * pdx + pdy * pdy);
                                        if (pdist < 60) {
                                            player.takeDamage(this.baseDamage);
                                        }
                                        
                                        // Lightning visual
                                        for (let j = 0; j < 50; j++) {
                                            particles.push(new Particle(
                                                targetX, targetY,
                                                '#ffd700',
                                                (Math.random() - 0.5) * 15,
                                                (Math.random() - 0.5) * 15,
                                                25
                                            ));
                                        }
                                    }, 600);
                                }, i * 400);
                            }
                        }
                        break;
                        
                    case 'Necromancer':
                        this.vx = this.facing * this.speed * 0.8;
                        
                        // Summon minions frequently
                        if (this.specialCooldown <= 0 && currentRoom.enemies.length < 4) {
                            this.specialCooldown = Math.floor(150 * specialSpeed);
                            const minionCount = this.phase === 2 ? 2 : 1;
                            for (let i = 0; i < minionCount; i++) {
                                currentRoom.enemies.push(new Enemy(
                                    this.x + (Math.random() - 0.5) * 120,
                                    this.y - 60,
                                    'assassin'
                                ));
                            }
                        }
                        
                        // Dark bolt barrage
                        if (this.attackCooldown <= 0 && dist < 380) {
                            this.attackCooldown = Math.floor(30 * attackSpeed);
                            const angle = Math.atan2(dy, dx);
                            projectiles.push(new Projectile(
                                this.x, this.y, angle, 12, 'enemy'
                            ));
                        }
                        break;
                        
                    case 'Blood Reaper':
                        if (dist > 85) {
                            this.vx = this.facing * this.speed;
                        } else {
                            this.vx = 0;
                            if (this.attackCooldown <= 0) {
                                this.attackCooldown = Math.floor(28 * attackSpeed);
                                if (dist < 90) {
                                    player.takeDamage(this.baseDamage);
                                    // Strong heal
                                    this.health = Math.min(this.health + 15, this.maxHealth);
                                }
                            }
                        }
                        
                        // Blood projectiles
                        if (this.specialCooldown <= 0 && dist < 300) {
                            this.specialCooldown = Math.floor(50 * specialSpeed);
                            const angle = Math.atan2(dy, dx);
                            for (let i = -1; i <= 1; i++) {
                                projectiles.push(new Projectile(
                                    this.x, this.y, angle + i * 0.3, 11, 'enemy'
                                ));
                            }
                        }
                        break;
                        
                    case 'Void Walker':
                        // Constant phasing (with bounds)
                        if (Math.random() < 0.03) {
                            let newX = this.x + (Math.random() - 0.5) * 120;
                            let newY = this.y + (Math.random() - 0.5) * 60;
                            
                            // Keep within bounds
                            newX = Math.max(60, Math.min(canvas.width - 60, newX));
                            newY = Math.max(100, Math.min(canvas.height - 100, newY));
                            
                            this.x = newX;
                            this.y = newY;
                        }
                        
                        if (dist > 90) {
                            this.vx = this.facing * this.speed;
                        } else if (this.attackCooldown <= 0) {
                            this.attackCooldown = Math.floor(32 * attackSpeed);
                            if (dist < 80) player.takeDamage(this.baseDamage);
                        }
                        
                        // Void orb storm
                        if (this.specialCooldown <= 0) {
                            this.specialCooldown = Math.floor(60 * specialSpeed);
                            const orbCount = this.phase === 2 ? 6 : 4;
                            for (let i = 0; i < orbCount; i++) {
                                const angle = (Math.PI * 2 / orbCount) * i;
                                projectiles.push(new Projectile(
                                    this.x, this.y, angle, 9, 'enemy'
                                ));
                            }
                        }
                        break;
                }
                
                this.animFrame++;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.facing, 1);
                
                // Boss-specific unique visuals
                switch(this.type) {
                    case 'Crimson Knight':
                        // Massive armored knight with giant sword
                        ctx.fillStyle = '#8b0000';
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        // Gold trim
                        ctx.fillStyle = '#ffd700';
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, 6);
                        ctx.fillRect(-this.width / 2, this.height / 2 - 6, this.width, 6);
                        
                        // Crown
                        ctx.fillStyle = '#ffd700';
                        for (let i = -2; i <= 2; i++) {
                            ctx.fillRect(i * 10 - 3, -this.height / 2 - 8, 6, 12);
                        }
                        
                        // Giant sword
                        ctx.fillStyle = '#c0c0c0';
                        ctx.fillRect(this.width / 2, -this.height / 2, 8, this.height);
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(this.width / 2 + 2, -this.height / 2, 2, this.height);
                        break;
                        
                    case 'Shadow Lord':
                        // Dark phantom with flowing shadows
                        ctx.fillStyle = '#2a2a2a';
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        // Shadow aura
                        ctx.globalAlpha = 0.3 + Math.sin(Date.now() / 150) * 0.2;
                        ctx.fillStyle = '#000000';
                        for (let i = 0; i < 3; i++) {
                            ctx.fillRect(-this.width / 2 - i * 8, -this.height / 2, this.width, this.height);
                        }
                        ctx.globalAlpha = 1;
                        
                        // Glowing red eyes
                        ctx.fillStyle = '#ff0000';
                        ctx.globalAlpha = 0.8 + Math.sin(Date.now() / 200) * 0.2;
                        ctx.beginPath();
                        ctx.arc(-8, -this.height / 2 + 15, 5, 0, Math.PI * 2);
                        ctx.arc(8, -this.height / 2 + 15, 5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                        break;
                        
                    case 'Frost Warden':
                        // Ice-covered guardian
                        ctx.fillStyle = '#00bfff';
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        // Ice crystals
                        ctx.fillStyle = '#87ceeb';
                        for (let i = 0; i < 5; i++) {
                            const x = (i - 2) * 10;
                            const y = -this.height / 2 + (i % 2) * 20;
                            ctx.beginPath();
                            ctx.moveTo(x, y);
                            ctx.lineTo(x - 5, y + 10);
                            ctx.lineTo(x + 5, y + 10);
                            ctx.fill();
                        }
                        
                        // Frost aura
                        ctx.globalAlpha = 0.4;
                        const iceGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, this.width);
                        iceGrad.addColorStop(0, '#00ffff');
                        iceGrad.addColorStop(1, 'rgba(0, 255, 255, 0)');
                        ctx.fillStyle = iceGrad;
                        ctx.beginPath();
                        ctx.arc(0, 0, this.width, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                        break;
                        
                    case 'Flame Tyrant':
                        // Fire demon
                        ctx.fillStyle = '#ff4500';
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        // Flames
                        ctx.fillStyle = '#ff6600';
                        for (let i = 0; i < 6; i++) {
                            const flameX = (i - 2.5) * 10;
                            const flameHeight = 10 + Math.sin(Date.now() / 100 + i) * 5;
                            ctx.beginPath();
                            ctx.moveTo(flameX, this.height / 2);
                            ctx.lineTo(flameX - 5, this.height / 2 - flameHeight);
                            ctx.lineTo(flameX + 5, this.height / 2 - flameHeight);
                            ctx.fill();
                        }
                        
                        // Horns
                        ctx.fillStyle = '#8b0000';
                        ctx.beginPath();
                        ctx.moveTo(-15, -this.height / 2);
                        ctx.lineTo(-20, -this.height / 2 - 15);
                        ctx.lineTo(-10, -this.height / 2 - 10);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.moveTo(15, -this.height / 2);
                        ctx.lineTo(20, -this.height / 2 - 15);
                        ctx.lineTo(10, -this.height / 2 - 10);
                        ctx.fill();
                        
                        // Fire eyes
                        ctx.fillStyle = '#ffff00';
                        ctx.fillRect(-10, -this.height / 2 + 12, 6, 6);
                        ctx.fillRect(4, -this.height / 2 + 12, 6, 6);
                        break;
                        
                    case 'Stone Golem':
                        // Massive stone creature
                        ctx.fillStyle = '#696969';
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        // Stone blocks
                        ctx.strokeStyle = '#4a4a4a';
                        ctx.lineWidth = 2;
                        for (let y = -this.height / 2; y < this.height / 2; y += 15) {
                            ctx.strokeRect(-this.width / 2, y, this.width, 15);
                        }
                        
                        // Cracks
                        ctx.strokeStyle = '#2a2a2a';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(-this.width / 4, -this.height / 2);
                        ctx.lineTo(-this.width / 4 + 5, 0);
                        ctx.lineTo(-this.width / 4, this.height / 2);
                        ctx.stroke();
                        
                        // Glowing core
                        ctx.fillStyle = '#ff6600';
                        ctx.globalAlpha = 0.6 + Math.sin(Date.now() / 200) * 0.4;
                        ctx.beginPath();
                        ctx.arc(0, 0, 12, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                        break;
                        
                    case 'Toxic Assassin':
                        // Poisonous rogue
                        ctx.fillStyle = '#228b22';
                        ctx.fillRect(-this.width / 2 + 6, -this.height / 2, this.width - 12, this.height);
                        
                        // Poison drips
                        ctx.fillStyle = '#00ff00';
                        for (let i = 0; i < 4; i++) {
                            const dripX = (i - 1.5) * 12;
                            const dripY = this.height / 2 + (Math.sin(Date.now() / 100 + i) * 5);
                            ctx.beginPath();
                            ctx.arc(dripX, dripY, 3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        // Toxic mask
                        ctx.fillStyle = '#1a4d1a';
                        ctx.fillRect(-12, -this.height / 2 + 8, 24, 12);
                        
                        ctx.fillStyle = '#00ff00';
                        ctx.globalAlpha = 0.7;
                        ctx.fillRect(-8, -this.height / 2 + 10, 5, 8);
                        ctx.fillRect(3, -this.height / 2 + 10, 5, 8);
                        ctx.globalAlpha = 1;
                        break;
                        
                    case 'Thunder King':
                        // Electric ruler
                        ctx.fillStyle = '#ffd700';
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        // Lightning bolts
                        ctx.strokeStyle = '#ffff00';
                        ctx.lineWidth = 3;
                        ctx.globalAlpha = 0.7 + Math.sin(Date.now() / 100) * 0.3;
                        for (let i = 0; i < 3; i++) {
                            const x = (i - 1) * 15;
                            ctx.beginPath();
                            ctx.moveTo(x, -this.height / 2);
                            ctx.lineTo(x - 5, -this.height / 4);
                            ctx.lineTo(x + 5, 0);
                            ctx.lineTo(x - 5, this.height / 4);
                            ctx.lineTo(x, this.height / 2);
                            ctx.stroke();
                        }
                        ctx.globalAlpha = 1;
                        
                        // Crown
                        ctx.fillStyle = '#ffaa00';
                        for (let i = -2; i <= 2; i++) {
                            ctx.fillRect(i * 8 - 2, -this.height / 2 - 10, 4, 15);
                        }
                        break;
                        
                    case 'Necromancer':
                        // Death mage
                        ctx.fillStyle = '#4b0082';
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        // Skulls
                        ctx.fillStyle = '#ffffff';
                        ctx.globalAlpha = 0.8;
                        for (let i = 0; i < 3; i++) {
                            const skullY = -this.height / 2 + i * 20 + 10;
                            ctx.beginPath();
                            ctx.arc(-this.width / 3, skullY, 4, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        ctx.globalAlpha = 1;
                        
                        // Staff
                        ctx.strokeStyle = '#8b008b';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.moveTo(this.width / 2, this.height / 2);
                        ctx.lineTo(this.width / 2, -this.height / 2);
                        ctx.stroke();
                        
                        // Dark orb
                        ctx.fillStyle = '#000000';
                        ctx.beginPath();
                        ctx.arc(this.width / 2, -this.height / 2, 8, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = '#8b008b';
                        ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 150) * 0.5;
                        ctx.beginPath();
                        ctx.arc(this.width / 2, -this.height / 2, 6, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                        break;
                        
                    case 'Blood Reaper':
                        // Vampiric warrior
                        ctx.fillStyle = '#dc143c';
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        // Blood drips
                        ctx.fillStyle = '#8b0000';
                        for (let i = 0; i < 5; i++) {
                            const bloodX = (i - 2) * 12;
                            const bloodY = this.height / 2 + Math.sin(Date.now() / 80 + i) * 8;
                            ctx.fillRect(bloodX - 2, bloodY - 10, 4, 10);
                            ctx.beginPath();
                            ctx.arc(bloodX, bloodY, 3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        // Scythe
                        ctx.strokeStyle = '#2a2a2a';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(this.width / 2, this.height / 2);
                        ctx.lineTo(this.width / 2, -this.height / 2 + 10);
                        ctx.stroke();
                        
                        ctx.fillStyle = '#c0c0c0';
                        ctx.beginPath();
                        ctx.arc(this.width / 2, -this.height / 2 + 10, 10, Math.PI, 0);
                        ctx.fill();
                        break;
                        
                    case 'Void Walker':
                        // Dimensional being
                        ctx.fillStyle = '#483d8b';
                        ctx.globalAlpha = 0.7 + Math.sin(Date.now() / 120) * 0.3;
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        ctx.globalAlpha = 1;
                        
                        // Void portals
                        ctx.fillStyle = '#000000';
                        for (let i = 0; i < 4; i++) {
                            const portalX = (i % 2) * 20 - 10;
                            const portalY = Math.floor(i / 2) * 30 - 15;
                            ctx.globalAlpha = 0.4 + Math.sin(Date.now() / 100 + i) * 0.4;
                            ctx.beginPath();
                            ctx.arc(portalX, portalY, 6, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        ctx.globalAlpha = 1;
                        
                        // Energy outline
                        ctx.strokeStyle = '#9370db';
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 0.6 + Math.sin(Date.now() / 150) * 0.4;
                        ctx.strokeRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        ctx.globalAlpha = 1;
                        break;
                }
                
                // Phase 2 intense glow
                if (this.phase === 2) {
                    ctx.globalAlpha = 0.4 + Math.sin(Date.now() / 80) * 0.4;
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(-this.width / 2 - 2, -this.height / 2 - 2, this.width + 4, this.height + 4);
                    
                    // Pulsing aura
                    const auraGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, this.width * 1.5);
                    auraGrad.addColorStop(0, 'rgba(255, 0, 0, 0.5)');
                    auraGrad.addColorStop(1, 'rgba(255, 0, 0, 0)');
                    ctx.fillStyle = auraGrad;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
                
                ctx.restore();
                
                // Health bar - larger for boss
                ctx.fillStyle = '#333';
                ctx.fillRect(this.x - 50, this.y - this.height / 2 - 25, 100, 8);
                ctx.fillStyle = this.phase === 2 ? '#ff0000' : '#8b0000';
                ctx.fillRect(this.x - 50, this.y - this.height / 2 - 25, 100 * (this.health / this.maxHealth), 8);
                
                // Boss name and phase
                ctx.fillStyle = this.phase === 2 ? '#ff0000' : '#ffd700';
                ctx.font = 'bold 16px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText(this.type + (this.phase === 2 ? ' [ENRAGED]' : ''), this.x, this.y - this.height / 2 - 35);
            }

            takeDamage(amount) {
                // Bosses take less damage
                const armorPierceBonus = 1 + (player.upgrades.armorPierce * 0.3);
                this.health -= amount * armorPierceBonus;
                
                for (let i = 0; i < 15; i++) {
                    particles.push(new Particle(
                        this.x, this.y, this.color,
                        (Math.random() - 0.5) * 8,
                        (Math.random() - 0.5) * 8 - 2,
                        25
                    ));
                }
            }
        }

        // Room generator
        class Room {
            constructor(seed, isBossRoom = false) {
                this.seed = seed;
                this.platforms = [];
                this.enemies = [];
                this.boss = null;
                this.isBossRoom = isBossRoom;
                this.doors = { left: false, right: true };
                this.cleared = false;
                this.generate();
            }

            generate() {
                // Simple seeded random
                let randSeed = this.seed;
                const rand = () => {
                    randSeed = (randSeed * 9301 + 49297) % 233280;
                    return randSeed / 233280;
                };
                
                // Generate platforms - create a more structured layout
                const platformCount = 4 + Math.floor(rand() * 4);
                
                // Create layers of platforms
                const layers = [200, 320, 440, 560];
                const usedLayers = [];
                
                for (let i = 0; i < platformCount; i++) {
                    const layer = layers[Math.floor(rand() * layers.length)];
                    const width = 150 + rand() * 180;
                    const x = 100 + rand() * (canvas.width - width - 200);
                    
                    // Make sure platforms don't overlap too much
                    let overlap = false;
                    for (const p of this.platforms) {
                        if (Math.abs(p.y - layer) < 50 && 
                            x < p.x + p.width + 50 && 
                            x + width > p.x - 50) {
                            overlap = true;
                            break;
                        }
                    }
                    
                    if (!overlap) {
                        this.platforms.push({
                            x: x,
                            y: layer,
                            width: width,
                            height: 15
                        });
                    }
                }
                
                // Add some guaranteed safe platforms near spawn and exit
                this.platforms.push({
                    x: 50,
                    y: canvas.height - 150,
                    width: 200,
                    height: 15
                });
                
                this.platforms.push({
                    x: canvas.width - 250,
                    y: canvas.height - 150,
                    width: 200,
                    height: 15
                });
                
                // Boss room or normal room
                if (this.isBossRoom) {
                    const bossTypes = [
                        'Crimson Knight', 'Shadow Lord', 'Frost Warden', 'Flame Tyrant',
                        'Stone Golem', 'Toxic Assassin', 'Thunder King', 'Necromancer',
                        'Blood Reaper', 'Void Walker'
                    ];
                    const bossType = bossTypes[Math.floor(rand() * bossTypes.length)];
                    this.boss = new Boss(canvas.width / 2, canvas.height - 200, bossType);
                } else {
                    // Generate enemies on platforms with variety
                    // Progressive difficulty - start with fewer enemies
                    let baseEnemyCount = 2 + Math.floor(rand() * 4);
                    
                    // Scale down enemy count for early rooms (chambers 1-3)
                    if (this.seed < 3 * 12345) { // First 3 rooms
                        baseEnemyCount = 1 + Math.floor(rand() * 2); // 1-2 enemies
                    } else if (this.seed < 5 * 12345) { // Rooms 4-5
                        baseEnemyCount = 2 + Math.floor(rand() * 2); // 2-3 enemies
                    }
                    
                    const enemyCount = Math.min(baseEnemyCount, this.platforms.length);
                    const usedPlatforms = [];
                    
                    const enemyTypes = ['basic', 'advanced', 'heavy', 'assassin', 'mage'];
                    
                    for (let i = 0; i < enemyCount; i++) {
                        let platformIndex;
                        let attempts = 0;
                        do {
                            platformIndex = Math.floor(rand() * this.platforms.length);
                            attempts++;
                        } while (usedPlatforms.includes(platformIndex) && attempts < 20);
                        
                        if (!usedPlatforms.includes(platformIndex)) {
                            usedPlatforms.push(platformIndex);
                            const platform = this.platforms[platformIndex];
                            
                            // Varied enemy type selection - fewer mages in early rooms
                            const typeRoll = rand();
                            let type;
                            
                            // First 3 rooms - mostly basic enemies, no mages
                            if (this.seed < 3 * 12345) {
                                if (typeRoll < 0.6) type = 'basic';
                                else if (typeRoll < 0.9) type = 'advanced';
                                else type = 'assassin';
                            }
                            // Rooms 4-5 - introduce variety, very few mages
                            else if (this.seed < 5 * 12345) {
                                if (typeRoll < 0.35) type = 'basic';
                                else if (typeRoll < 0.6) type = 'advanced';
                                else if (typeRoll < 0.75) type = 'heavy';
                                else if (typeRoll < 0.9) type = 'assassin';
                                else type = 'mage';
                            }
                            // Later rooms - full variety
                            else {
                                if (typeRoll < 0.3) type = 'basic';
                                else if (typeRoll < 0.55) type = 'advanced';
                                else if (typeRoll < 0.7) type = 'heavy';
                                else if (typeRoll < 0.85) type = 'assassin';
                                else type = 'mage';
                            }
                            
                            // Spawn enemy in middle of platform
                            this.enemies.push(new Enemy(
                                platform.x + platform.width / 2,
                                platform.y - 40,
                                type
                            ));
                        }
                    }
                }
            }

            draw() {
                // Background gradient (castle stone walls)
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, '#3a3a3a');
                gradient.addColorStop(1, '#1a1a1a');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Stone wall texture
                for (let i = 0; i < 20; i++) {
                    for (let j = 0; j < 15; j++) {
                        const x = i * 60 + (j % 2) * 30;
                        const y = j * 50;
                        ctx.strokeStyle = '#2a2a2a';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x, y, 60, 50);
                    }
                }
                
                // Torches on walls (ambient lighting)
                for (let i = 0; i < 5; i++) {
                    const x = 150 + i * 220;
                    const y = 80;
                    
                    // Torch glow
                    const torchGradient = ctx.createRadialGradient(x, y, 0, x, y, 60);
                    torchGradient.addColorStop(0, 'rgba(255, 140, 0, 0.15)');
                    torchGradient.addColorStop(1, 'rgba(255, 140, 0, 0)');
                    ctx.fillStyle = torchGradient;
                    ctx.fillRect(x - 60, y - 60, 120, 120);
                    
                    // Flame
                    ctx.fillStyle = '#ff8c00';
                    ctx.globalAlpha = 0.8 + Math.sin(Date.now() / 100 + i) * 0.2;
                    ctx.beginPath();
                    ctx.ellipse(x, y, 6, 10 + Math.sin(Date.now() / 150 + i) * 3, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
                
                // Platforms
                for (const platform of this.platforms) {
                    // Platform shadow
                    ctx.fillStyle = 'rgba(0,0,0,0.4)';
                    ctx.fillRect(platform.x + 5, platform.y + 5, platform.width, platform.height);
                    
                    // Stone platform
                    const platformGradient = ctx.createLinearGradient(0, platform.y, 0, platform.y + platform.height);
                    platformGradient.addColorStop(0, '#5a5a5a');
                    platformGradient.addColorStop(1, '#3a3a3a');
                    ctx.fillStyle = platformGradient;
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                    
                    // Stone edge highlight
                    ctx.fillStyle = '#6a6a6a';
                    ctx.fillRect(platform.x, platform.y, platform.width, 3);
                    
                    // Stone cracks
                    ctx.strokeStyle = '#2a2a2a';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < 3; i++) {
                        const crackX = platform.x + (platform.width / 4) * (i + 0.5);
                        ctx.beginPath();
                        ctx.moveTo(crackX, platform.y);
                        ctx.lineTo(crackX + 5, platform.y + platform.height);
                        ctx.stroke();
                    }
                }
                
                // Ground (castle floor)
                ctx.fillStyle = '#2a2a2a';
                ctx.fillRect(0, canvas.height - 50, canvas.width, 50);
                
                // Floor tiles
                ctx.strokeStyle = '#1a1a1a';
                ctx.lineWidth = 2;
                for (let i = 0; i < canvas.width / 60; i++) {
                    ctx.strokeRect(i * 60, canvas.height - 50, 60, 50);
                }
                
                ctx.fillStyle = '#4a4a4a';
                ctx.fillRect(0, canvas.height - 50, canvas.width, 3);
                
                // Door indicator (right side)
                if (this.enemies.length === 0 && !this.cleared) {
                    this.cleared = true;
                }
                
                if (this.cleared || this.enemies.length === 0) {
                    // Castle doorway/archway
                    const doorX = canvas.width - 60;
                    const doorY = canvas.height - 180;
                    
                    // Archway stones
                    ctx.fillStyle = '#4a4a4a';
                    ctx.fillRect(doorX, doorY, 50, 130);
                    
                    // Arch
                    ctx.beginPath();
                    ctx.arc(doorX + 25, doorY + 130, 25, Math.PI, 0);
                    ctx.fill();
                    
                    // Door opening (dark)
                    ctx.fillStyle = '#0a0a0a';
                    ctx.fillRect(doorX + 5, doorY + 20, 40, 110);
                    
                    // Glowing exit effect
                    const doorGradient = ctx.createRadialGradient(doorX + 25, doorY + 75, 0, doorX + 25, doorY + 75, 50);
                    doorGradient.addColorStop(0, 'rgba(255, 215, 0, 0.4)');
                    doorGradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                    ctx.fillStyle = doorGradient;
                    ctx.fillRect(doorX - 20, doorY, 90, 130);
                    
                    // Pulsing light
                    ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 300) * 0.3;
                    ctx.fillStyle = '#ffd700';
                    ctx.fillRect(doorX + 5, doorY + 20, 40, 110);
                    ctx.globalAlpha = 1;
                    
                    // Stone border details
                    ctx.strokeStyle = '#6a6a6a';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(doorX, doorY, 50, 130);
                    
                    // "Exit" arrow
                    ctx.fillStyle = '#ffd700';
                    ctx.font = '20px Courier New';
                    ctx.textAlign = 'center';
                    ctx.globalAlpha = 0.7 + Math.sin(Date.now() / 300) * 0.3;
                    ctx.fillText('‚Üí', doorX + 25, doorY - 10);
                    ctx.globalAlpha = 1;
                }
            }
        }

        // Game state
        let player = new Player(100, 300);
        let currentRoom = new Room(1);
        let roomNumber = 1;
        let particles = [];
        let trails = [];
        let projectiles = [];
        let shadowClones = [];
        let gameStarted = false;
        let showingUpgrade = false;
        let gameOver = false;
        
        // Secret cheat code system
        let cheatCode = '';
        let mythicMode = false;
        const SECRET_CODE = 'goldengod'; // Type this for mythics only!
        
        // Checkpoint system
        let checkpoint = {
            room: 1,
            health: 150,
            upgrades: {},
            special1: null,
            special2: null
        };

        function saveCheckpoint() {
            checkpoint = {
                room: roomNumber,
                health: player.health,
                upgrades: JSON.parse(JSON.stringify(player.upgrades)),
                special1: player.special1,
                special2: player.special2
            };
            console.log('Checkpoint saved at room', checkpoint.room);
        }

        function loadCheckpoint() {
            roomNumber = checkpoint.room;
            const isBossRoom = (roomNumber % 5 === 0);
            currentRoom = new Room(roomNumber * 12345, isBossRoom);
            
            player = new Player(100, canvas.height - 200);
            player.health = checkpoint.health;
            player.maxHealth = 150;
            player.upgrades = JSON.parse(JSON.stringify(checkpoint.upgrades));
            player.special1 = checkpoint.special1;
            player.special2 = checkpoint.special2;
            
            projectiles = [];
            particles = [];
            trails = [];
            shadowClones = [];
            gameOver = false;
            gameStarted = true;
            
            document.getElementById('gameOverScreen').style.display = 'none';
            updateSpecialBinds();
        }

        function resetGame() {
            roomNumber = 1;
            currentRoom = new Room(1);
            player = new Player(100, 300);
            projectiles = [];
            particles = [];
            trails = [];
            shadowClones = [];
            gameOver = false;
            gameStarted = true;
            
            // Reset checkpoint
            checkpoint = {
                room: 1,
                health: 150,
                upgrades: {},
                special1: null,
                special2: null
            };
            
            document.getElementById('gameOverScreen').style.display = 'none';
            updateSpecialBinds();
        }

        function updateSpecialBinds() {
            const special1Name = player.special1 ? upgradeDefinitions[player.special1].name : 'N/A';
            const special2Name = player.special2 ? upgradeDefinitions[player.special2].name : 'N/A';
            document.getElementById('special1Bind').textContent = special1Name;
            document.getElementById('special2Bind').textContent = special2Name;
        }

        // Ability/Upgrade rarities with Fortnite colors
        const rarityColors = {
            common: '#b3b3b3',
            uncommon: '#5cb85c',
            rare: '#5bc0de',
            epic: '#a335ee',
            legendary: '#ff8c00',
            mythic: '#ffd700'
        };

        // Upgrade definitions with rarities
        const upgradeDefinitions = {
            // PASSIVE UPGRADES
            multishot: {
                name: "Multi-Shot",
                description: "Throw additional knives in a spread pattern",
                maxLevel: 3,
                icon: "‚öîÔ∏è",
                rarity: "uncommon",
                type: "passive"
            },
            rapidFire: {
                name: "Rapid Fire",
                description: "Reduce knife throwing cooldown significantly",
                maxLevel: 5,
                icon: "‚ö°",
                rarity: "common",
                type: "passive"
            },
            lifesteal: {
                name: "Life Steal",
                description: "Restore health when defeating enemies",
                maxLevel: 3,
                icon: "üíâ",
                rarity: "rare",
                type: "passive"
            },
            dashAttack: {
                name: "Shadow Strike",
                description: "Deal damage to enemies you dash through",
                maxLevel: 3,
                icon: "üí®",
                rarity: "uncommon",
                type: "passive"
            },
            criticalHit: {
                name: "Assassinate",
                description: "Chance to deal triple damage with attacks",
                maxLevel: 3,
                icon: "üí•",
                rarity: "rare",
                type: "passive"
            },
            thorns: {
                name: "Retribution",
                description: "Reflect damage back to nearby attackers",
                maxLevel: 3,
                icon: "üõ°Ô∏è",
                rarity: "uncommon",
                type: "passive"
            },
            speedBoost: {
                name: "Swift Steps",
                description: "Increase movement speed",
                maxLevel: 4,
                icon: "üèÉ",
                rarity: "common",
                type: "passive"
            },
            vampiricAura: {
                name: "Dark Essence",
                description: "Slowly regenerate health over time",
                maxLevel: 3,
                icon: "üåô",
                rarity: "rare",
                type: "passive"
            },
            explosiveKnives: {
                name: "Explosive Blades",
                description: "Knives explode on impact, damaging nearby enemies",
                maxLevel: 1,
                icon: "üí£",
                rarity: "epic",
                type: "passive"
            },
            armorPierce: {
                name: "Armor Breaker",
                description: "Deal extra damage to bosses and armored foes",
                maxLevel: 3,
                icon: "üî®",
                rarity: "rare",
                type: "passive"
            },
            doubleJump: {
                name: "Double Jump",
                description: "Jump again while in the air",
                maxLevel: 1,
                icon: "ü¶Ö",
                rarity: "uncommon",
                type: "passive"
            },
            
            // ACTIVE ABILITIES - Common
            dashBoost: {
                name: "Dash Boost",
                description: "Extended dash range and reduced cooldown",
                maxLevel: 1,
                icon: "üí´",
                rarity: "common",
                type: "ability",
                cooldown: 0
            },
            
            // ACTIVE ABILITIES - Uncommon
            fireStorm: {
                name: "Fire Storm",
                description: "Rain fire projectiles around you",
                maxLevel: 1,
                icon: "üî•",
                rarity: "uncommon",
                type: "ability",
                cooldown: 400
            },
            iceWall: {
                name: "Ice Wall",
                description: "Create barrier that blocks projectiles",
                maxLevel: 1,
                icon: "‚ùÑÔ∏è",
                rarity: "uncommon",
                type: "ability",
                cooldown: 500
            },
            
            // ACTIVE ABILITIES - Rare
            shadowClone: {
                name: "Shadow Clone",
                description: "Create a clone that mimics your attacks for 10s",
                maxLevel: 1,
                icon: "üë•",
                rarity: "rare",
                type: "ability",
                cooldown: 600
            },
            bladeDance: {
                name: "Blade Dance",
                description: "Spinning knife attack all around you",
                maxLevel: 1,
                icon: "üåÄ",
                rarity: "rare",
                type: "ability",
                cooldown: 350
            },
            venomStrike: {
                name: "Venom Strike",
                description: "Poison all nearby enemies for massive DOT",
                maxLevel: 1,
                icon: "‚ò†Ô∏è",
                rarity: "rare",
                type: "ability",
                cooldown: 450
            },
            
            // ACTIVE ABILITIES - Epic
            timeStop: {
                name: "Time Stop",
                description: "Freeze all enemies for 3 seconds",
                maxLevel: 1,
                icon: "‚è∏Ô∏è",
                rarity: "epic",
                type: "ability",
                cooldown: 800
            },
            deathMark: {
                name: "Death Mark",
                description: "Mark enemies - next hit deals 5x damage",
                maxLevel: 1,
                icon: "üíÄ",
                rarity: "epic",
                type: "ability",
                cooldown: 500
            },
            phantomStrike: {
                name: "Phantom Strike",
                description: "Teleport behind nearest enemy and strike",
                maxLevel: 1,
                icon: "üëª",
                rarity: "epic",
                type: "ability",
                cooldown: 400
            },
            
            // ACTIVE ABILITIES - Legendary
            omniSlash: {
                name: "Omni Slash",
                description: "Dash through all enemies dealing massive damage",
                maxLevel: 1,
                icon: "‚ö°",
                rarity: "legendary",
                type: "ability",
                cooldown: 700
            },
            voidRift: {
                name: "Void Rift",
                description: "Create portal that sucks in and damages enemies",
                maxLevel: 1,
                icon: "üåÄ",
                rarity: "legendary",
                type: "ability",
                cooldown: 900
            },
            bloodMoon: {
                name: "Blood Moon",
                description: "Lifesteal aura + attack speed for 8 seconds",
                maxLevel: 1,
                icon: "üî¥",
                rarity: "legendary",
                type: "ability",
                cooldown: 1000
            },
            divineShield: {
                name: "Divine Shield",
                description: "Invulnerable for 4 seconds",
                maxLevel: 1,
                icon: "üõ°Ô∏è",
                rarity: "legendary",
                type: "ability",
                cooldown: 800
            },
            stormCaller: {
                name: "Storm Caller",
                description: "Lightning strikes all enemies",
                maxLevel: 1,
                icon: "‚ö°",
                rarity: "legendary",
                type: "ability",
                cooldown: 750
            },
            
            // ACTIVE ABILITIES - Mythic (Repeatable in Golden God mode!)
            godMode: {
                name: "Ascension",
                description: "Invincible + 10x damage for 5 seconds",
                maxLevel: 99,
                icon: "‚ú®",
                rarity: "mythic",
                type: "ability",
                cooldown: 1500
            },
            armageddon: {
                name: "Armageddon",
                description: "Meteors rain down destroying everything",
                maxLevel: 99,
                icon: "‚òÑÔ∏è",
                rarity: "mythic",
                type: "ability",
                cooldown: 1200
            },
            infinityEdge: {
                name: "Infinity Edge",
                description: "Summon 20 homing blades for 10 seconds",
                maxLevel: 99,
                icon: "‚öîÔ∏è",
                rarity: "mythic",
                type: "ability",
                cooldown: 1400
            },
            timestrike: {
                name: "Timestrike",
                description: "Stop time and attack freely for 5 seconds",
                maxLevel: 99,
                icon: "‚è±Ô∏è",
                rarity: "mythic",
                type: "ability",
                cooldown: 1600
            },
            soulReaper: {
                name: "Soul Reaper",
                description: "Instantly kill all non-boss enemies",
                maxLevel: 99,
                icon: "üíÄ",
                rarity: "mythic",
                type: "ability",
                cooldown: 1800
            },
            ragnarok: {
                name: "Ragnarok",
                description: "Screen-wide explosion of devastation",
                maxLevel: 99,
                icon: "üí•",
                rarity: "mythic",
                type: "ability",
                cooldown: 2000
            }
        };

        function getRandomUpgrades(count = 3) {
            // Initialize upgrades object if needed
            if (!player.upgrades) {
                player.upgrades = {};
            }
            
            // MYTHIC MODE - ONLY mythics, can be repeated!
            if (mythicMode) {
                const allMythics = ['godMode', 'armageddon', 'infinityEdge', 'timestrike', 'soulReaper', 'ragnarok'];
                
                const mythicUpgrades = allMythics.filter(key => {
                    const upgrade = upgradeDefinitions[key];
                    const currentLevel = player.upgrades[key] || 0;
                    return currentLevel < upgrade.maxLevel;
                });
                
                // If we have mythics available, ONLY show mythics
                if (mythicUpgrades.length > 0) {
                    const selected = [];
                    
                    // Allow duplicates to fill all 3 slots
                    for (let i = 0; i < count; i++) {
                        if (mythicUpgrades.length > 0) {
                            const randomIndex = Math.floor(Math.random() * mythicUpgrades.length);
                            selected.push(mythicUpgrades[randomIndex]);
                        }
                    }
                    
                    return selected;
                }
            }
            
            // Normal mode - weighted selection with BETTER mythic rates
            const available = Object.keys(upgradeDefinitions).filter(key => {
                const currentLevel = player.upgrades[key] || 0;
                return currentLevel < upgradeDefinitions[key].maxLevel;
            });
            
            // Weighted random selection - MUCH better mythic rates
            const rarityWeights = {
                common: 30,      // Reduced from 40
                uncommon: 25,    // Reduced from 30
                rare: 20,        // Same
                epic: 18,        // Increased from 15
                legendary: 15,   // Increased from 10
                mythic: 20       // MASSIVELY increased from 8!
            };
            
            const weightedPool = [];
            available.forEach(key => {
                const upgrade = upgradeDefinitions[key];
                const weight = rarityWeights[upgrade.rarity] || 20;
                for (let i = 0; i < weight; i++) {
                    weightedPool.push(key);
                }
            });
            
            // Shuffle weighted pool
            const shuffled = weightedPool.sort(() => Math.random() - 0.5);
            
            // Pick unique upgrades
            const selected = [];
            const seen = new Set();
            for (const key of shuffled) {
                if (!seen.has(key)) {
                    selected.push(key);
                    seen.add(key);
                    if (selected.length >= count) break;
                }
            }
            
            return selected;
        }

        function showUpgradeScreen() {
            showingUpgrade = true;
            const upgradeScreen = document.getElementById('upgradeScreen');
            const upgradeOptions = document.getElementById('upgradeOptions');
            upgradeOptions.innerHTML = '';
            
            const upgrades = getRandomUpgrades(3);
            
            upgrades.forEach(upgradeKey => {
                const upgrade = upgradeDefinitions[upgradeKey];
                const currentLevel = player.upgrades[upgradeKey] || 0;
                
                const card = document.createElement('div');
                card.className = 'upgrade-card';
                const rarity = upgrade.rarity || 'common';
                const color = rarityColors[rarity];
                card.style.borderColor = color;
                card.style.boxShadow = `0 5px 20px rgba(${rarity === 'mythic' ? '255, 215, 0' : '0, 0, 0'}, 0.${rarity === 'mythic' ? 6 : 3})`;
                
                // Mythic glow animation
                if (rarity === 'mythic') {
                    card.style.animation = 'mythicGlow 2s ease-in-out infinite';
                    card.style.background = 'linear-gradient(135deg, #2a1810, #1a0f08)';
                }
                
                card.innerHTML = `
                    <h3>${upgrade.icon} ${upgrade.name}</h3>
                    <div class="level" style="color: ${color};">${rarity.toUpperCase()}</div>
                    <div class="level">Level ${currentLevel} ‚Üí ${currentLevel + 1}</div>
                    <p>${upgrade.description}</p>
                `;
                
                card.onclick = () => {
                    // Initialize if needed
                    if (!player.upgrades[upgradeKey]) {
                        player.upgrades[upgradeKey] = 0;
                    }
                    player.upgrades[upgradeKey]++;
                    
                    // Assign to special slot if it's an ability type
                    if (upgrade.type === 'ability') {
                        if (!player.special1) {
                            player.special1 = upgradeKey;
                        } else if (!player.special2) {
                            player.special2 = upgradeKey;
                        } else {
                            // Replace special1 if both are full
                            player.special1 = upgradeKey;
                        }
                    }
                    
                    upgradeScreen.style.display = 'none';
                    showingUpgrade = false;
                    
                    // Update special binds display
                    updateSpecialBinds();
                    
                    // Visual feedback with rarity color
                    for (let i = 0; i < 50; i++) {
                        particles.push(new Particle(
                            player.x,
                            player.y,
                            color,
                            (Math.random() - 0.5) * 10,
                            (Math.random() - 0.5) * 10 - 5,
                            40
                        ));
                    }
                };
                
                upgradeOptions.appendChild(card);
            });
            
            upgradeScreen.style.display = 'flex';
        }

        const keys = {};

        // Button event listeners
        document.getElementById('playAgainBtn').addEventListener('click', () => {
            resetGame();
        });

        document.getElementById('loadCheckpointBtn').addEventListener('click', () => {
            loadCheckpoint();
        });

        window.addEventListener('keydown', (e) => {
            // Cheat code detection
            if (e.key.length === 1) {
                cheatCode += e.key.toLowerCase();
                // Keep only last 10 characters
                if (cheatCode.length > 10) {
                    cheatCode = cheatCode.substring(cheatCode.length - 10);
                }
                
                // Check if cheat code matches
                if (cheatCode.endsWith(SECRET_CODE)) {
                    mythicMode = !mythicMode;
                    cheatCode = '';
                    
                    console.log('MYTHIC MODE:', mythicMode ? 'ACTIVATED' : 'DEACTIVATED');
                    
                    // Visual feedback
                    const message = mythicMode ? '‚ú® MYTHIC MODE ACTIVATED! ‚ú®' : 'Mythic Mode Deactivated';
                    const color = mythicMode ? '#ffd700' : '#888';
                    
                    for (let i = 0; i < 100; i++) {
                        particles.push(new Particle(
                            player.x, player.y, color,
                            (Math.random() - 0.5) * 20,
                            (Math.random() - 0.5) * 20,
                            60
                        ));
                    }
                    
                    // Show message on screen briefly
                    ctx.save();
                    ctx.fillStyle = color;
                    ctx.font = 'bold 48px Courier New';
                    ctx.textAlign = 'center';
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                    ctx.shadowBlur = 10;
                    setTimeout(() => {
                        ctx.fillText(message, canvas.width / 2, canvas.height / 2);
                    }, 100);
                    ctx.restore();
                }
            }
            
            if (!gameStarted) {
                gameStarted = true;
                document.getElementById('titleScreen').classList.add('fade-out');
                setTimeout(() => {
                    document.getElementById('titleScreen').style.display = 'none';
                }, 2000);
            }
            
            keys[e.key.toLowerCase()] = true;
            
            // Update aim direction based on WASD
            if (!showingUpgrade) {
                let aimX = 0;
                let aimY = 0;
                
                if (keys['w'] || keys['arrowup']) aimY = -1;
                if (keys['s'] || keys['arrowdown']) aimY = 1;
                if (keys['a'] || keys['arrowleft']) aimX = -1;
                if (keys['d'] || keys['arrowright']) aimX = 1;
                
                // If any direction is pressed, update aim
                if (aimX !== 0 || aimY !== 0) {
                    const magnitude = Math.sqrt(aimX * aimX + aimY * aimY);
                    player.aimDirection = {
                        x: aimX / magnitude,
                        y: aimY / magnitude
                    };
                }
            }
            
            if (e.key === ' ' || e.key.toLowerCase() === 'w' || e.key === 'ArrowUp') {
                if (player.onGround && !showingUpgrade) {
                    player.vy = -player.jumpPower;
                } else if (!player.onGround && !player.hasDoubleJumped && player.upgrades.doubleJump > 0 && !showingUpgrade) {
                    player.vy = -player.jumpPower;
                    player.hasDoubleJumped = true;
                    
                    // Double jump effect
                    for (let i = 0; i < 15; i++) {
                        particles.push(new Particle(
                            player.x, player.y,
                            '#00ffff',
                            (Math.random() - 0.5) * 8,
                            Math.random() * 5,
                            20
                        ));
                    }
                }
            }
            if (e.key.toLowerCase() === 'j' && !showingUpgrade) {
                player.attack();
            }
            if (e.key.toLowerCase() === 'k' && !showingUpgrade) {
                player.dash();
            }
            if (e.key.toLowerCase() === 'l' && !showingUpgrade) {
                player.shootRanged();
            }
            if (e.key.toLowerCase() === 'q' && !showingUpgrade) {
                player.useSpecial1();
            }
            if (e.key.toLowerCase() === 'e' && !showingUpgrade) {
                player.useSpecial2();
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        function checkAttackCollisions() {
            if (player.attacking && player.attackFrame >= 5 && player.attackFrame <= 12) {
                // Check boss
                if (currentRoom.boss && currentRoom.boss.health > 0) {
                    const boss = currentRoom.boss;
                    const dx = boss.x - (player.x + player.facing * 30);
                    const dy = boss.y - player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < player.attackRange + boss.width / 2) {
                        let damage = player.attackDamage;
                        const critChance = player.upgrades.criticalHit * 0.2;
                        if (Math.random() < critChance) {
                            damage *= 3;
                            for (let j = 0; j < 20; j++) {
                                particles.push(new Particle(
                                    boss.x, boss.y, '#ffff00',
                                    (Math.random() - 0.5) * 12,
                                    (Math.random() - 0.5) * 12,
                                    30
                                ));
                            }
                        }
                        
                        boss.takeDamage(damage);
                        
                        if (boss.health <= 0) {
                            // Boss defeated
                            if (player.upgrades.lifesteal > 0) {
                                const healAmount = 30 * player.upgrades.lifesteal;
                                player.health = Math.min(player.health + healAmount, player.maxHealth);
                                
                                for (let j = 0; j < 10; j++) {
                                    particles.push(new Particle(
                                        player.x, player.y, '#00ff00',
                                        (Math.random() - 0.5) * 5,
                                        (Math.random() - 0.5) * 5 - 3,
                                        25
                                    ));
                                }
                            }
                            
                            for (let j = 0; j < 100; j++) {
                                particles.push(new Particle(
                                    boss.x, boss.y,
                                    j % 2 === 0 ? '#ffd700' : boss.color,
                                    (Math.random() - 0.5) * 20,
                                    (Math.random() - 0.5) * 20 - 5,
                                    60 + Math.random() * 30
                                ));
                            }
                        }
                    }
                }
                
                // Check normal enemies
                for (let i = currentRoom.enemies.length - 1; i >= 0; i--) {
                    const enemy = currentRoom.enemies[i];
                    const dx = enemy.x - (player.x + player.facing * 30);
                    const dy = enemy.y - player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < player.attackRange && Math.sign(dx) === player.facing) {
                        // Critical hit chance
                        let damage = player.attackDamage;
                        const critChance = player.upgrades.criticalHit * 0.2;
                        if (Math.random() < critChance) {
                            damage *= 3;
                            // Critical hit effect
                            for (let j = 0; j < 20; j++) {
                                particles.push(new Particle(
                                    enemy.x,
                                    enemy.y,
                                    '#ffff00',
                                    (Math.random() - 0.5) * 12,
                                    (Math.random() - 0.5) * 12,
                                    30
                                ));
                            }
                        }
                        
                        enemy.takeDamage(damage);
                        
                        if (enemy.health <= 0) {
                            // Lifesteal
                            if (player.upgrades.lifesteal > 0) {
                                const healAmount = 10 * player.upgrades.lifesteal;
                                player.health = Math.min(player.health + healAmount, player.maxHealth);
                                
                                // Heal visual
                                for (let j = 0; j < 10; j++) {
                                    particles.push(new Particle(
                                        player.x,
                                        player.y,
                                        '#00ff00',
                                        (Math.random() - 0.5) * 5,
                                        (Math.random() - 0.5) * 5 - 3,
                                        25
                                    ));
                                }
                            }
                            
                            // Time slow on kill
                            if (player.upgrades.timeSlowOnKill > 0) {
                                // Visual effect (we'll handle the slow in the game loop)
                                for (let j = 0; j < 30; j++) {
                                    particles.push(new Particle(
                                        enemy.x,
                                        enemy.y,
                                        '#00ffff',
                                        (Math.random() - 0.5) * 8,
                                        (Math.random() - 0.5) * 8,
                                        50
                                    ));
                                }
                            }
                            
                            // Death explosion
                            for (let j = 0; j < 30; j++) {
                                particles.push(new Particle(
                                    enemy.x,
                                    enemy.y,
                                    j % 2 === 0 ? '#ff6600' : '#ffaa00',
                                    (Math.random() - 0.5) * 10,
                                    (Math.random() - 0.5) * 10 - 3,
                                    40 + Math.random() * 20
                                ));
                            }
                            currentRoom.enemies.splice(i, 1);
                        }
                    }
                }
            }
        }

        function updateProjectiles() {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                proj.update();
                
                // Check collision with player
                if (proj.owner === 'enemy') {
                    const dx = player.x - proj.x;
                    const dy = player.y - proj.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < player.width / 2 + proj.radius) {
                        player.takeDamage(proj.damage);
                        projectiles.splice(i, 1);
                        continue;
                    }
                }
                
                // Check collision with enemies and bosses
                if (proj.owner === 'player') {
                    // Check boss
                    if (currentRoom.boss && currentRoom.boss.health > 0) {
                        const boss = currentRoom.boss;
                        const dx = boss.x - proj.x;
                        const dy = boss.y - proj.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < boss.width / 2 + proj.radius) {
                            if (proj.explosive) {
                                for (let k = 0; k < 40; k++) {
                                    particles.push(new Particle(
                                        proj.x, proj.y,
                                        k % 2 === 0 ? '#ff6600' : '#ffaa00',
                                        (Math.random() - 0.5) * 15,
                                        (Math.random() - 0.5) * 15,
                                        30
                                    ));
                                }
                            }
                            
                            boss.takeDamage(proj.damage);
                            
                            if (boss.health <= 0) {
                                // Boss defeated effects
                                if (player.upgrades.lifesteal > 0) {
                                    const healAmount = 30 * player.upgrades.lifesteal;
                                    player.health = Math.min(player.health + healAmount, player.maxHealth);
                                }
                                
                                for (let k = 0; k < 100; k++) {
                                    particles.push(new Particle(
                                        boss.x, boss.y,
                                        k % 2 === 0 ? '#ffd700' : boss.color,
                                        (Math.random() - 0.5) * 20,
                                        (Math.random() - 0.5) * 20 - 5,
                                        60
                                    ));
                                }
                            }
                            projectiles.splice(i, 1);
                            continue;
                        }
                    }
                    
                    // Check normal enemies
                    for (let j = currentRoom.enemies.length - 1; j >= 0; j--) {
                        const enemy = currentRoom.enemies[j];
                        const dx = enemy.x - proj.x;
                        const dy = enemy.y - proj.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < enemy.width / 2 + proj.radius) {
                            // Explosive knives - damage nearby enemies
                            if (proj.explosive) {
                                for (let k = 0; k < currentRoom.enemies.length; k++) {
                                    const nearEnemy = currentRoom.enemies[k];
                                    const edx = nearEnemy.x - proj.x;
                                    const edy = nearEnemy.y - proj.y;
                                    const eDist = Math.sqrt(edx * edx + edy * edy);
                                    
                                    if (eDist < 80) {
                                        nearEnemy.takeDamage(proj.damage * 0.7);
                                    }
                                }
                                
                                // Explosion effect
                                for (let k = 0; k < 40; k++) {
                                    particles.push(new Particle(
                                        proj.x,
                                        proj.y,
                                        k % 2 === 0 ? '#ff6600' : '#ffaa00',
                                        (Math.random() - 0.5) * 15,
                                        (Math.random() - 0.5) * 15,
                                        30
                                    ));
                                }
                            }
                            
                            enemy.takeDamage(proj.damage);
                            
                            if (enemy.health <= 0) {
                                // Lifesteal
                                if (player.upgrades.lifesteal > 0) {
                                    const healAmount = 10 * player.upgrades.lifesteal;
                                    player.health = Math.min(player.health + healAmount, player.maxHealth);
                                    
                                    for (let k = 0; k < 10; k++) {
                                        particles.push(new Particle(
                                            player.x,
                                            player.y,
                                            '#00ff00',
                                            (Math.random() - 0.5) * 5,
                                            (Math.random() - 0.5) * 5 - 3,
                                            25
                                        ));
                                    }
                                }
                                
                                for (let k = 0; k < 30; k++) {
                                    particles.push(new Particle(
                                        enemy.x,
                                        enemy.y,
                                        '#ff6600',
                                        (Math.random() - 0.5) * 10,
                                        (Math.random() - 0.5) * 10 - 3,
                                        40
                                    ));
                                }
                                currentRoom.enemies.splice(j, 1);
                            }
                            projectiles.splice(i, 1);
                            break;
                        }
                    }
                }
                
                // Remove if out of bounds or expired
                if (proj.life <= 0 || proj.x < 0 || proj.x > canvas.width || proj.y < 0 || proj.y > canvas.height) {
                    projectiles.splice(i, 1);
                }
            }
        }

        function gameLoop() {
            if (!gameStarted) {
                requestAnimationFrame(gameLoop);
                return;
            }
            
            // Game over check
            if (gameOver) {
                requestAnimationFrame(gameLoop);
                return;
            }
            
            // Pause game when showing upgrades
            if (showingUpgrade) {
                requestAnimationFrame(gameLoop);
                return;
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw room
            currentRoom.draw();
            
            // Update and draw trails
            for (let i = trails.length - 1; i >= 0; i--) {
                trails[i].update();
                trails[i].draw();
                if (trails[i].life <= 0) {
                    trails.splice(i, 1);
                }
            }
            
            // Update and draw shadow clones
            for (let i = shadowClones.length - 1; i >= 0; i--) {
                shadowClones[i].update();
                shadowClones[i].draw();
                if (shadowClones[i].lifetime <= 0) {
                    shadowClones.splice(i, 1);
                }
            }
            
            // Update and draw particles
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                particles[i].draw();
                if (particles[i].life <= 0) {
                    particles.splice(i, 1);
                }
            }
            
            // Update projectiles
            updateProjectiles();
            
            // Draw projectiles
            for (const proj of projectiles) {
                proj.draw();
            }
            
            // Player movement
            if (!player.dashing) {
                if (keys['a'] || keys['arrowleft']) {
                    player.vx = -player.speed;
                    player.facing = -1;
                } else if (keys['d'] || keys['arrowright']) {
                    player.vx = player.speed;
                    player.facing = 1;
                } else {
                    player.vx *= 0.8;
                }
            }
            
            // Update
            player.update();
            checkAttackCollisions();
            
            // Check if room just cleared
            const roomCleared = currentRoom.boss ? 
                (currentRoom.boss.health <= 0) : 
                (currentRoom.enemies.length === 0);
                
            if (roomCleared && !currentRoom.cleared) {
                currentRoom.cleared = true;
                // Room cleared effect - golden victory particles
                for (let i = 0; i < 100; i++) {
                    particles.push(new Particle(
                        canvas.width / 2,
                        canvas.height / 2,
                        i % 3 === 0 ? '#ffd700' : (i % 3 === 1 ? '#ffaa00' : '#ff8c00'),
                        (Math.random() - 0.5) * 20,
                        (Math.random() - 0.5) * 20 - 5,
                        60 + Math.random() * 30
                    ));
                }
            }
            
            // Update enemies
            for (const enemy of currentRoom.enemies) {
                enemy.update();
            }
            
            // Update boss if present
            if (currentRoom.boss && currentRoom.boss.health > 0) {
                currentRoom.boss.update();
            }
            
            // Draw enemies
            for (const enemy of currentRoom.enemies) {
                enemy.draw();
            }
            
            // Draw boss
            if (currentRoom.boss && currentRoom.boss.health > 0) {
                currentRoom.boss.draw();
            }
            
            // Draw player
            player.draw();
            
            // Draw aim direction indicator
            if (!player.attacking && !player.dashing) {
                const aimLength = 40;
                const aimX = player.x + player.aimDirection.x * aimLength;
                const aimY = player.y + player.aimDirection.y * aimLength;
                
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.6;
                ctx.beginPath();
                ctx.moveTo(player.x, player.y);
                ctx.lineTo(aimX, aimY);
                ctx.stroke();
                
                // Arrowhead
                const angle = Math.atan2(player.aimDirection.y, player.aimDirection.x);
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.moveTo(aimX, aimY);
                ctx.lineTo(aimX - 8 * Math.cos(angle - 0.3), aimY - 8 * Math.sin(angle - 0.3));
                ctx.lineTo(aimX - 8 * Math.cos(angle + 0.3), aimY - 8 * Math.sin(angle + 0.3));
                ctx.closePath();
                ctx.fill();
                ctx.globalAlpha = 1;
            }
            
            // Check for room transition
            if (roomCleared && player.x > canvas.width - 50) {
                // Save checkpoint if this was a boss room
                if (currentRoom.isBossRoom) {
                    saveCheckpoint();
                }
                
                roomNumber++;
                
                // Boss room every 5 rooms
                const isBossRoom = (roomNumber % 5 === 0);
                currentRoom = new Room(roomNumber * 12345, isBossRoom);
                
                player.x = 100;
                player.y = canvas.height - 200;
                player.vy = 0;
                player.vx = 0;
                player.health = Math.min(player.health + 20, player.maxHealth);
                projectiles = [];
                particles = [];
                trails = [];
                shadowClones = [];
                
                // Transition effect
                for (let i = 0; i < 50; i++) {
                    particles.push(new Particle(
                        player.x,
                        player.y,
                        isBossRoom ? '#ff0000' : '#ffd700',
                        (Math.random() - 0.5) * 15,
                        (Math.random() - 0.5) * 15,
                        30 + Math.random() * 20
                    ));
                }
                
                // Show upgrade screen (not on boss rooms - reward after defeating boss)
                if (!isBossRoom) {
                    showUpgradeScreen();
                }
            }
            
            // Update UI
            document.getElementById('health').textContent = Math.floor(player.health);
            document.getElementById('healthBar').style.width = (player.health / player.maxHealth * 100) + '%';
            document.getElementById('room').textContent = roomNumber;
            const enemyCount = currentRoom.enemies.length + (currentRoom.boss && currentRoom.boss.health > 0 ? 1 : 0);
            document.getElementById('enemies').textContent = enemyCount;
            
            // Draw mythic mode indicator
            if (mythicMode) {
                ctx.save();
                ctx.fillStyle = '#ffd700';
                ctx.font = 'bold 24px Courier New';
                ctx.textAlign = 'center';
                ctx.shadowColor = 'rgba(255, 215, 0, 0.8)';
                ctx.shadowBlur = 10;
                const pulse = 0.8 + Math.sin(Date.now() / 200) * 0.2;
                ctx.globalAlpha = pulse;
                ctx.fillText('‚ú® MYTHIC MODE ‚ú®', canvas.width / 2, 30);
                ctx.restore();
            }
            
            // Game over
            if (player.health <= 0 && !gameOver) {
                gameOver = true;
                document.getElementById('finalRoom').textContent = roomNumber;
                document.getElementById('gameOverScreen').style.display = 'flex';
            }
            
            requestAnimationFrame(gameLoop);
        }

        gameLoop();
        updateSpecialBinds();
    </script>
</body>
</html>
