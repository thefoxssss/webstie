### Full single-file HTML: cinematic Tetris with dynamic themes, reactive audio-visuals, comfort mode, achievements, end-game sequence, and polished animations

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>TETRIS ‚Äî Cosmic Cinematic Edition</title>
  <style>
    /* =========================================================
       0) Core variables (reactive, themes, comfort mode)
       ========================================================= */
    * { margin: 0; padding: 0; box-sizing: border-box; }

    :root {
      /* Base palette and speed (animated background) */
      --bg1: #0e132f;
      --bg2: #14213d;
      --bg3: #1f2a57;
      --bg-speed: 16s;

      /* Neon accents */
      --accent1: #a855f7; /* violet */
      --accent2: #06b6d4; /* cyan */

      /* Board glow and inset */
      --board-glow: rgba(168, 85, 247, 0.26);
      --board-inset: rgba(0, 0, 0, 0.5);

      /* Ghost visuals */
      --ghost-border: rgba(255, 255, 255, 0.36);
      --ghost-bg: rgba(255, 255, 255, 0.12);

      /* Reactive filters (global) */
      --reactive-brightness: 1;
      --reactive-hue: 0deg;
      --reactive-sat: 105%;
      --reactive-blur: 0px;

      /* UI micro-scale feedback */
      --ui-scale: 1;
      --title-glow: rgba(168, 85, 247, 0.5);

      /* Comfort mode limits (soft visuals) */
      --comfort-brightness-cap: 1.3;
      --comfort-duration: 360ms;

      /* Theme name for UI reflect (cosmic, aurora, cyberpunk, retro, jungle) */
      --theme-name: "cosmic";
    }

    /* =========================================================
       1) Reactive background: multi-layer gradients, sparkles, aurora
       ========================================================= */
    body {
      font-family: 'Arial', sans-serif;
      background:
        radial-gradient(60% 60% at 20% 20%, rgba(255,255,255,0.03), transparent 60%),
        linear-gradient(135deg, var(--bg1) 0%, var(--bg2) 50%, var(--bg3) 100%);
      background-size: 400% 400%;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      overflow: hidden;
      filter: brightness(var(--reactive-brightness)) saturate(var(--reactive-sat)) hue-rotate(var(--reactive-hue));
      backdrop-filter: blur(var(--reactive-blur));
      animation: bgShift var(--bg-speed) ease infinite;
    }

    @keyframes bgShift {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    /* Subtle sparkle overlay (multi radial layers) */
    .bg-sparkle {
      position: fixed; inset: 0; pointer-events: none; z-index: 0;
      background:
        radial-gradient(1200px 800px at 10% 20%, rgba(255,255,255,0.03), transparent 60%),
        radial-gradient(1000px 900px at 90% 30%, rgba(255,255,255,0.04), transparent 65%),
        radial-gradient(900px 700px at 50% 80%, rgba(255,255,255,0.02), transparent 70%);
      mix-blend-mode: screen;
      animation: sparkleMove 22s linear infinite;
      opacity: 0.35;
    }
    @keyframes sparkleMove {
      0% { transform: translate(0,0); }
      50% { transform: translate(24px,-16px); }
      100% { transform: translate(0,0); }
    }

    /* Aurora ribbons, theme-reactive */
    .aurora-layer {
      position: fixed; inset: 0; pointer-events: none; z-index: 0;
      background:
        conic-gradient(from 180deg at 50% 50%, rgba(166,85,247,0.14), rgba(6,182,212,0.12), rgba(255,255,255,0) 70%),
        linear-gradient(90deg, rgba(255,255,255,0.06), rgba(255,255,255,0.0));
      opacity: 0.28;
      filter: blur(20px);
      animation: auroraFlow 16s ease-in-out infinite alternate;
    }
    @keyframes auroraFlow {
      0% { transform: translateY(0) scale(1); opacity: 0.28; }
      50% { transform: translateY(-8px) scale(1.02); opacity: 0.33; }
      100% { transform: translateY(4px) scale(0.99); opacity: 0.27; }
    }

    /* Ripple blast on clears (soft comfort) */
    .bg-ripple {
      position: fixed; inset: 0; pointer-events: none; z-index: 1;
      background: radial-gradient(circle, rgba(255,255,255,0.25) 0%, transparent 70%);
      opacity: 0;
    }
    .bg-ripple.active { animation: rippleExpand 0.75s ease-out forwards; }
    @keyframes rippleExpand {
      0% { opacity: 0.6; transform: scale(0); }
      50% { opacity: 0.3; transform: scale(1.8); }
      100% { opacity: 0; transform: scale(2.6); }
    }

    /* End game cinematic backdrop */
    .end-game-bg {
      position: fixed; inset: 0; pointer-events: none; z-index: 999;
      background: radial-gradient(circle, rgba(255,0,0,0) 0%, rgba(0,0,0,0) 100%);
      opacity: 0;
    }
    .end-game-bg.active { animation: endFade 2.2s ease-in forwards; }
    @keyframes endFade {
      0% { opacity: 0; background: radial-gradient(circle, rgba(255,0,0,0) 0%, rgba(0,0,0,0) 100%); }
      50% { opacity: 0.7; background: radial-gradient(circle, rgba(255,0,0,0.45) 0%, rgba(0,0,0,0.8) 100%); }
      100% { opacity: 1; background: radial-gradient(circle, rgba(255,0,0,0.75) 0%, rgba(0,0,0,1) 100%); }
    }

    /* =========================================================
       2) Layout and panels
       ========================================================= */
    .game-container {
      display: flex;
      gap: 20px;
      padding: 20px;
      position: relative;
      transform: scale(var(--ui-scale));
      transition: transform 200ms ease;
      z-index: 10;
    }

    .side-panel {
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      border: 2px solid rgba(168, 85, 247, 0.3);
      border-radius: 15px;
      padding: 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      min-width: 160px;
    }
    .side-panel.glow { box-shadow: 0 0 22px rgba(168, 85, 247, 0.6); transform: scale(1.04); }

    .main-panel { display: flex; flex-direction: column; align-items: center; gap: 15px; }

    .title {
      font-size: 3rem;
      font-weight: bold;
      text-align: center;
      background: linear-gradient(45deg, var(--accent1), var(--accent2));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: 0 0 24px var(--title-glow);
      animation: pulse 2s infinite;
      letter-spacing: 4px;
    }

    /* =========================================================
       3) Stats + achievements strip
       ========================================================= */
    .stats { display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; }
    .stat-box {
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      padding: 10px 20px;
      border-radius: 10px;
      text-align: center;
      min-width: 110px;
      transition: all 0.25s ease;
      transform-origin: center;
      border: 2px solid rgba(168, 85, 247, 0.2);
    }
    .stat-label { font-size: 0.75rem; opacity: 0.75; margin-bottom: 5px; }
    .stat-value { font-size: 1.5rem; font-weight: bold; }

    .achievements {
      display: flex; gap: 8px; align-items: center; justify-content: center; margin-top: 4px; flex-wrap: wrap;
    }
    .badge {
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.12);
      color: #fff;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 0.75rem;
      box-shadow: 0 0 10px rgba(168,85,247,0.24);
      display: inline-flex; gap: 6px; align-items: center;
    }
    .badge .dot {
      width: 8px; height: 8px; border-radius: 50%;
      background: var(--accent2);
      box-shadow: 0 0 6px var(--accent2);
    }

    /* =========================================================
       4) Board and cells
       ========================================================= */
    #gameBoard {
      position: relative;
      background: #0a0a0a;
      border: 3px solid;
      border-image: linear-gradient(45deg, var(--accent1), var(--accent2)) 1;
      box-shadow: 0 0 40px var(--board-glow), inset 0 0 60px var(--board-inset);
      transition: transform 0.05s;
      display: grid;
      gap: 1px;
      padding: 2px;
    }
    #gameBoard.shake { animation: shake 0.12s; }

    .cell {
      border: 1px solid rgba(255, 255, 255, 0.1);
      transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
      border-radius: 2px;
      background: #0a0a0a;
    }

    .panel-title { font-size: 0.875rem; font-weight: bold; text-align: center; margin-bottom: 10px; opacity: 0.8; }

    .preview-box {
      background: rgba(255, 255, 255, 0.03);
      padding: 10px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 80px;
      transition: all 0.3s;
    }

    .next-preview { opacity: 0.6; margin-bottom: 10px; min-height: 60px; }

    /* =========================================================
       5) Controls + buttons + update log
       ========================================================= */
    .controls {
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      padding: 15px;
      border-radius: 10px;
      margin-top: 15px;
      text-align: center;
      font-size: 0.75rem;
      border: 1px solid rgba(168, 85, 247, 0.2);
      max-width: 440px;
    }
    .controls-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 10px; }

    .btn {
      background: linear-gradient(45deg, var(--accent1), var(--accent2));
      border: none;
      color: white;
      padding: 12px 32px;
      border-radius: 8px;
      font-size: 1.1rem;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 4px 15px rgba(168, 85, 247, 0.4);
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .btn:hover { transform: translateY(-2px) scale(1.05); box-shadow: 0 6px 25px rgba(168, 85, 247, 0.6); }
    .btn:active { transform: translateY(0) scale(1); }

    .play-again-btn {
      display: inline-block;
      margin-top: 15px;
      background: linear-gradient(45deg, var(--accent1), var(--accent2));
      border: none;
      color: white;
      padding: 12px 32px;
      border-radius: 8px;
      font-size: 1.1rem;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 4px 15px rgba(168, 85, 247, 0.4);
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .play-again-btn:hover { transform: translateY(-2px) scale(1.05); box-shadow: 0 6px 25px rgba(168, 85, 247, 0.6); }

    .update-log-btn {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(168, 85, 247, 0.8);
      backdrop-filter: blur(10px);
      border: 2px solid rgba(168, 85, 247, 0.5);
      color: white;
      padding: 10px 20px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: bold;
      font-size: 0.9rem;
      transition: all 0.3s;
      z-index: 1000;
      box-shadow: 0 4px 15px rgba(168, 85, 247, 0.3);
    }
    .update-log-btn:hover { background: rgba(168, 85, 247, 1); transform: translateY(-2px); box-shadow: 0 6px 20px rgba(168, 85, 247, 0.5); }

    .update-log-modal {
      position: fixed; inset: 0;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(5px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      animation: fadeIn 0.3s;
    }
    .update-log-modal.show { display: flex; }

    .update-log-content {
      background: linear-gradient(135deg, #0e132f 0%, #1a1a2e 100%);
      border: 3px solid rgba(168, 85, 247, 0.5);
      border-radius: 20px;
      padding: 30px;
      max-width: 720px;
      width: 92%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 10px 50px rgba(168, 85, 247, 0.5);
      animation: slideIn 0.3s;
    }

    .update-log-content h2 { color: #a855f7; margin-bottom: 10px; font-size: 2rem; text-shadow: 0 0 10px rgba(168, 85, 247, 0.5); }
    .version { color: #06b6d4; font-size: 1.2rem; margin-bottom: 20px; font-weight: bold; }
    .update-section { margin-bottom: 20px; padding: 15px; background: rgba(255, 255, 255, 0.04); border-radius: 10px; border-left: 4px solid #a855f7; }
    .update-section h3 { color: #06b6d4; margin-bottom: 10px; font-size: 1.1rem; }
    .update-section ul { list-style: none; padding: 0; }
    .update-section li { padding: 5px 0; color: rgba(255, 255, 255, 0.9); font-size: 0.9rem; }
    .update-section li:before { content: "‚ú® "; color: #a855f7; }

    .close-modal {
      background: linear-gradient(45deg, var(--accent1), var(--accent2));
      border: none; color: white; padding: 10px 30px; border-radius: 8px; font-weight: bold;
      cursor: pointer; margin-top: 20px; width: 100%; font-size: 1rem; transition: all 0.3s;
    }
    .close-modal:hover { transform: translateY(-2px); box-shadow: 0 5px 20px rgba(168, 85, 247, 0.5); }
    @keyframes slideIn { from { transform: translateY(-50px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

    /* =========================================================
       6) Overlays and messages
       ========================================================= */
    .overlay-message {
      position: absolute; top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      font-weight: bold; pointer-events: none; z-index: 100;
      text-align: center; white-space: nowrap;
    }
    .combo-text { font-size: 3.2rem; color: #ffff00; text-shadow: 0 0 18px #ffff00, 0 0 36px #ffff00; animation: comboPopIn 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55); }
    .action-text { font-size: 2.3rem; color: #ff00ff; text-shadow: 0 0 24px #ff00ff; animation: actionPopIn 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55); }
    .perfect-clear { font-size: 2rem; color: #00f0f0; text-shadow: 0 0 32px #00f0f0; animation: perfectClearAnim 2s ease-out; }
    .paused { font-size: 2rem; color: #ffff00; text-shadow: 0 0 12px #ffff00; animation: pulse 1.5s infinite; }

    .game-over { text-align: center; animation: fadeIn 0.5s; }
    .game-over-title { font-size: 2.5rem; color: #ff0000; text-shadow: 0 0 18px #ff0000; animation: pulse 1s infinite; margin-bottom: 20px; }

    canvas { position: absolute; top: 0; left: 0; pointer-events: none; }

    /* =========================================================
       7) Animations (general)
       ========================================================= */
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
    @keyframes shake { 0%, 100% { transform: translate(0, 0); } 25% { transform: translate(-2px, 2px); } 50% { transform: translate(2px, -2px); } 75% { transform: translate(-2px, -2px); } }
    @keyframes comboPopIn { 0% { transform: translate(-50%, -50%) scale(0) rotate(-180deg); opacity: 0; } 50% { transform: translate(-50%, -50%) scale(1.25) rotate(10deg); } 100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); opacity: 1; } }
    @keyframes actionPopIn { 0% { transform: translate(-50%, -50%) scale(0); opacity: 0; } 60% { transform: translate(-50%, -50%) scale(1.15); opacity: 1; } 100% { transform: translate(-50%, -50%) scale(1); } }
    @keyframes perfectClearAnim { 0% { transform: translate(-50%, -50%) scale(0); opacity: 0; } 30% { transform: translate(-50%, -50%) scale(1.45); opacity: 1; } 70% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; } 100% { transform: translate(-50%, -50%) scale(1); opacity: 0; } }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }

    /* =========================================================
       8) Line clear per-cell glow/explosion
       ========================================================= */
    @keyframes clearLineCell {
      0%   { opacity: 1; transform: scale(1); box-shadow: 0 0 10px var(--cell-color); filter: brightness(1); }
      25%  { opacity: 1; transform: scale(1.15); box-shadow: 0 0 22px #fff, 0 0 40px var(--cell-color); filter: brightness(1.25) saturate(1.4); }
      50%  { opacity: 1; transform: scale(1.06); box-shadow: 0 0 30px var(--cell-color), inset 0 0 18px #fff; filter: hue-rotate(90deg) brightness(1.3); }
      75%  { opacity: 0.75; transform: scale(0.84); box-shadow: 0 0 24px #ff00ff; }
      100% { opacity: 0; transform: scale(0.6); box-shadow: none; filter: brightness(0.4); }
    }
    .clearing { animation: clearLineCell 0.66s ease-out forwards; }
  </style>
</head>
<body>
  <!-- Reactive overlays -->
  <div class="bg-sparkle"></div>
  <div class="aurora-layer" id="aurora"></div>
  <div class="bg-ripple" id="bgRipple"></div>
  <div class="end-game-bg" id="endGameBg"></div>

  <!-- Update Log Button -->
  <button class="update-log-btn" onclick="toggleUpdateLog()">üìã Update Log</button>

  <!-- Update Log Modal -->
  <div class="update-log-modal" id="updateLogModal">
    <div class="update-log-content">
      <h2>Update Log</h2>
      <div class="version">Version 4.0.0 ‚Äî Cosmic Cinematic Edition</div>

      <div class="update-section">
        <h3>üéÆ New Features</h3>
        <ul>
          <li>Dynamic themes: Cosmic, Aurora, Cyberpunk, Jungle, Retro ‚Äî reactive colors, ribbons, and glow</li>
          <li>Comfort Mode: flashes reserved for major events only (line clears, Tetris, Perfect Clear, Game Over)</li>
          <li>Audio-reactive stubs: hook-ready for beat/rhythm visuals</li>
          <li>Achievements strip: unlock badges for combos, Tetris streaks, perfect clears</li>
          <li>End-game cinematic: soft red/black fade + particle burst + board collapse</li>
        </ul>
      </div>

      <div class="update-section">
        <h3>‚ú® Improvements</h3>
        <ul>
          <li>Preserved DAS movement, enhanced wall kicks</li>
          <li>Stable render loop at 60fps</li>
          <li>Polished UI with micro-animations and reactive title glow</li>
          <li>Ghost piece visibility: dashed border + subtle fill</li>
        </ul>
      </div>

      <div class="update-section">
        <h3>üõ† Settings</h3>
        <ul>
          <li>Theme selector</li>
          <li>Comfort Mode toggle</li>
          <li>Particles intensity slider (visual-only in this build)</li>
        </ul>
      </div>

      <button class="close-modal" onclick="toggleUpdateLog()">Close</button>
    </div>
  </div>

  <!-- Game Container -->
  <div class="game-container" id="gameContainer">
    <div class="side-panel" id="holdPanel">
      <div class="panel-title">HOLD (C)</div>
      <div class="preview-box" id="holdBox"></div>
      <div class="panel-title" style="margin-top:12px;">SETTINGS</div>
      <div class="preview-box" style="flex-direction:column; gap:10px;">
        <label style="font-size:0.8rem;">
          Theme:
          <select id="themeSelect" style="margin-left:8px; padding:4px 6px; border-radius:6px; border:1px solid rgba(255,255,255,0.2); background:rgba(255,255,255,0.06); color:#fff;">
            <option value="cosmic">Cosmic</option>
            <option value="aurora">Aurora</option>
            <option value="cyberpunk">Cyberpunk</option>
            <option value="retro">Retro</option>
            <option value="jungle">Jungle</option>
          </select>
        </label>
        <label style="font-size:0.8rem;">
          Comfort mode:
          <input type="checkbox" id="comfortToggle" checked style="margin-left:8px;">
        </label>
        <label style="font-size:0.8rem;">
          Particles:
          <input type="range" id="particlesSlider" min="0" max="100" value="70" style="vertical-align:middle; margin-left:8px; width:120px;">
        </label>
      </div>
    </div>

    <div class="main-panel">
      <div class="title" id="title">TETRIS</div>

      <div class="stats">
        <div class="stat-box" style="border: 2px solid rgba(0, 240, 240, 0.3);">
          <div class="stat-label">SCORE</div>
          <div class="stat-value" id="score" style="color: #00f0f0; text-shadow: 0 0 10px #00f0f0;">0</div>
        </div>
        <div class="stat-box" style="border: 2px solid rgba(0, 240, 0, 0.3);">
          <div class="stat-label">LEVEL</div>
          <div class="stat-value" id="level" style="color: #00f000;">1</div>
        </div>
        <div class="stat-box" style="border: 2px solid rgba(240, 240, 0, 0.3);">
          <div class="stat-label">LINES</div>
          <div class="stat-value" id="lines" style="color: #f0f000;">0</div>
        </div>
      </div>

      <div class="achievements" id="achievements">
        <!-- badges injected dynamically -->
      </div>

      <div style="position: relative;">
        <div id="gameBoard"></div>
        <canvas id="particleCanvas"></canvas>
        <div id="overlayMessages"></div>
      </div>

      <div id="gameOverScreen" style="display: none;"></div>

      <button class="play-again-btn" onclick="location.reload()" style="display: block;">üîÑ Play Again</button>

      <div class="controls">
        <div style="font-weight: bold; margin-bottom: 10px; color: #a855f7;">CONTROLS</div>
        <div class="controls-grid">
          <div>‚Üê ‚Üí Move</div>
          <div>‚Üë Rotate</div>
          <div>‚Üì Soft Drop</div>
          <div>SPACE Hard Drop</div>
          <div>C Hold</div>
          <div>P Pause</div>
        </div>
      </div>
    </div>

    <div class="side-panel">
      <div class="panel-title">NEXT</div>
      <div id="nextPieces"></div>
    </div>
  </div>

  <script>
    /* =========================================================
       A) Modal toggles
       ========================================================= */
    function toggleUpdateLog() {
      const modal = document.getElementById('updateLogModal');
      modal.classList.toggle('show');
    }
    document.getElementById('updateLogModal').addEventListener('click', function(e) {
      if (e.target === this) toggleUpdateLog();
    });

    /* =========================================================
       B) Constants, shapes, colors
       ========================================================= */
    const BOARD_WIDTH = 10;
    const BOARD_HEIGHT = 20;
    const CELL_SIZE = 30;
    const DAS_DELAY = 170;
    const DAS_INTERVAL = 50;

    const SHAPES = {
      I: [[1,1,1,1]],
      O: [[1,1],[1,1]],
      T: [[0,1,0],[1,1,1]],
      S: [[0,1,1],[1,1,0]],
      Z: [[1,1,0],[0,1,1]],
      J: [[1,0,0],[1,1,1]],
      L: [[0,0,1],[1,1,1]]
    };

    const COLORS = {
      I: '#00f0f0',
      O: '#f0f000',
      T: '#a000f0',
      S: '#00f000',
      Z: '#f00000',
      J: '#0000f0',
      L: '#f0a000'
    };

    /* =========================================================
       C) Theme engine (palette sets)
       ========================================================= */
    const THEMES = {
      cosmic: {
        bg1: '#0e132f', bg2: '#14213d', bg3: '#1f2a57',
        accent1: '#a855f7', accent2: '#06b6d4', auroraOpacity: 0.28
      },
      aurora: {
        bg1: '#041b2d', bg2: '#093a46', bg3: '#0b5d5b',
        accent1: '#8b5cf6', accent2: '#22d3ee', auroraOpacity: 0.35
      },
      cyberpunk: {
        bg1: '#120015', bg2: '#210022', bg3: '#2c0033',
        accent1: '#ff00ff', accent2: '#00ffc8', auroraOpacity: 0.32
      },
      retro: {
        bg1: '#2a1f1a', bg2: '#3b2c26', bg3: '#4b3a32',
        accent1: '#f79f1a', accent2: '#1af7d6', auroraOpacity: 0.22
      },
      jungle: {
        bg1: '#0b1f12', bg2: '#163f26', bg3: '#1f5d38',
        accent1: '#49f77b', accent2: '#1ad1f7', auroraOpacity: 0.30
      }
    };

    function applyTheme(name) {
      const theme = THEMES[name] || THEMES.cosmic;
      const root = document.documentElement;
      root.style.setProperty('--bg1', theme.bg1);
      root.style.setProperty('--bg2', theme.bg2);
      root.style.setProperty('--bg3', theme.bg3);
      root.style.setProperty('--accent1', theme.accent1);
      root.style.setProperty('--accent2', theme.accent2);
      document.getElementById('aurora').style.opacity = String(theme.auroraOpacity);
      root.style.setProperty('--theme-name', `"${name}"`);
    }

    /* =========================================================
       D) Game class
       ========================================================= */
    class TetrisGame {
      constructor() {
        this.board = Array(BOARD_HEIGHT).fill().map(() => Array(BOARD_WIDTH).fill(0));
        this.currentPiece = null;
        this.currentPos = { x: 0, y: 0 };
        this.heldPiece = null;
        this.canHold = true;

        this.score = 0;
        this.level = 1;
        this.lines = 0;

        this.gameOver = false;
        this.isPaused = false;

        this.nextPieces = [];
        this.clearingLines = [];
        this.ghostPos = null;
        this.particles = [];
        this.comboCount = 0;

        this.fallSpeed = 500;
        this.lastFallTime = Date.now();
        this.dropLock = false;

        this.keysPressed = {};
        this.dasTimers = {};
        this.dasIntervals = {};

        /* Achievements (unlocked badges) */
        this.achievements = {
          tetrisMaster: false,
          comboKing: false,
          perfectClearer: false,
          speedRunner: false
        };

        /* Settings */
        this.comfortMode = true;
        this.particlesIntensity = 70; // 0..100

        this.initGame();
        this.setupControls();
        this.setupSettingsUI();
        this.gameLoop();
      }

      initGame() {
        applyTheme('cosmic');
        this.nextPieces = [this.getRandomPiece(), this.getRandomPiece(), this.getRandomPiece()];
        this.spawnPiece();
        this.setupParticleCanvas();
        this.updateDisplay();
        this.updateAchievementsUI();
        this.updateReactiveBackground(true);
      }

      setupSettingsUI() {
        const themeSelect = document.getElementById('themeSelect');
        themeSelect.addEventListener('change', () => {
          applyTheme(themeSelect.value);
        });

        const comfortToggle = document.getElementById('comfortToggle');
        comfortToggle.addEventListener('change', () => {
          this.comfortMode = comfortToggle.checked;
        });

        const particlesSlider = document.getElementById('particlesSlider');
        particlesSlider.addEventListener('input', () => {
          this.particlesIntensity = parseInt(particlesSlider.value, 10);
        });
      }

      setupParticleCanvas() {
        const canvas = document.getElementById('particleCanvas');
        canvas.width = BOARD_WIDTH * CELL_SIZE + 6;
        canvas.height = BOARD_HEIGHT * CELL_SIZE + 6;
        this.particleCtx = canvas.getContext('2d');
      }

      getRandomPiece() {
        const types = Object.keys(SHAPES);
        const type = types[Math.floor(Math.random() * types.length)];
        return { type, shape: JSON.parse(JSON.stringify(SHAPES[type])) };
      }

      spawnPiece(piece = null) {
        const newPiece = piece || this.nextPieces.shift();
        if (!piece) this.nextPieces.push(this.getRandomPiece());

        const x = Math.floor(BOARD_WIDTH / 2) - Math.floor(newPiece.shape[0].length / 2);
        this.currentPiece = newPiece;
        this.currentPos = { x, y: 0 };
        this.canHold = true;
        this.calculateGhost();

        if (this.checkCollision(this.currentPiece, this.currentPos)) {
          this.gameOver = true;
          this.showGameOver();
        }

        this.render();
      }

      checkCollision(piece, pos) {
        for (let y = 0; y < piece.shape.length; y++) {
          for (let x = 0; x < piece.shape[y].length; x++) {
            if (piece.shape[y][x]) {
              const newX = pos.x + x;
              const newY = pos.y + y;
              if (newX < 0 || newX >= BOARD_WIDTH || newY >= BOARD_HEIGHT) return true;
              if (newY >= 0 && this.board[newY][newX]) return true;
            }
          }
        }
        return false;
      }

      movePiece(dx, dy) {
        if (!this.currentPiece || this.gameOver || this.isPaused || this.clearingLines.length > 0 || this.dropLock) return false;

        const newPos = { x: this.currentPos.x + dx, y: this.currentPos.y + dy };
        if (!this.checkCollision(this.currentPiece, newPos)) {
          this.currentPos = newPos;
          this.calculateGhost();
          this.render();
          return true;
        }
        return false;
      }

      rotatePiece() {
        if (!this.currentPiece || this.gameOver || this.isPaused || this.clearingLines.length > 0 || this.dropLock) return;

        const rotated = this.currentPiece.shape[0].map((_, i) =>
          this.currentPiece.shape.map(row => row[i]).reverse()
        );
        const rotatedPiece = { ...this.currentPiece, shape: rotated };

        const kicks = [
          { x: 0, y: 0 }, { x: -1, y: 0 }, { x: 1, y: 0 },
          { x: 0, y: -1 }, { x: -1, y: -1 }, { x: 1, y: -1 },
          { x: -2, y: 0 }, { x: 2, y: 0 }
        ];

        for (let kick of kicks) {
          const testPos = { x: this.currentPos.x + kick.x, y: this.currentPos.y + kick.y };
          if (!this.checkCollision(rotatedPiece, testPos)) {
            this.currentPiece = rotatedPiece;
            this.currentPos = testPos;
            this.calculateGhost();
            this.render();
            /* No flash for rotate in comfort mode */
            return;
          }
        }
      }

      calculateGhost() {
        if (!this.currentPiece) { this.ghostPos = null; return; }
        let ghostY = this.currentPos.y;
        while (!this.checkCollision(this.currentPiece, { x: this.currentPos.x, y: ghostY + 1 })) ghostY++;
        this.ghostPos = ghostY;
      }

      hardDrop() {
        if (!this.currentPiece || this.gameOver || this.isPaused || this.clearingLines.length > 0 || this.dropLock) return;

        this.dropLock = true;
        let newY = this.currentPos.y;
        while (!this.checkCollision(this.currentPiece, { x: this.currentPos.x, y: newY + 1 })) newY++;

        const dropDistance = newY - this.currentPos.y;
        this.currentPos.y = newY;

        for (let y = 0; y < this.currentPiece.shape.length; y++) {
          for (let x = 0; x < this.currentPiece.shape[y].length; x++) {
            if (this.currentPiece.shape[y][x]) {
              const intensityFactor = this.particlesIntensity / 100;
              this.createParticles(this.currentPos.x + x, this.currentPos.y + y, COLORS[this.currentPiece.type], Math.round(16 * intensityFactor));
            }
          }
        }

        this.shakeBoard();
        /* No flash for drop (comfort) */
        this.lockPiece();

        const points = dropDistance * 2;
        this.score += points;
        this.updateDisplay();
      }

      lockPiece() {
        for (let y = 0; y < this.currentPiece.shape.length; y++) {
          for (let x = 0; x < this.currentPiece.shape[y].length; x++) {
            if (this.currentPiece.shape[y][x]) {
              const boardY = this.currentPos.y + y;
              if (boardY >= 0) {
                this.board[boardY][this.currentPos.x + x] = this.currentPiece.type;
              }
            }
          }
        }
        this.clearLines();
      }

      clearLines() {
        const linesToClear = [];
        this.board.forEach((row, y) => { if (row.every(cell => cell !== 0)) linesToClear.push(y); });

        if (linesToClear.length > 0) {
          this.clearingLines = linesToClear;

          const boardEl = document.getElementById('gameBoard');
          const cells = boardEl.children;
          linesToClear.forEach((lineY) => {
            for (let x = 0; x < BOARD_WIDTH; x++) {
              const idx = lineY * BOARD_WIDTH + x;
              const cellEl = cells[idx];
              const type = this.board[lineY][x];
              const color = COLORS[type] || '#ffffff';
              if (cellEl) {
                cellEl.style.setProperty('--cell-color', color);
                cellEl.classList.add('clearing');
              }
              const intensityFactor = this.particlesIntensity / 100;
              this.createParticles(x, lineY, color, Math.round(14 * intensityFactor));
            }
          });

          // Background ripple blast (soft)
          const ripple = document.getElementById('bgRipple');
          ripple.classList.add('active');
          setTimeout(() => ripple.classList.remove('active'), 750);

          this.shakeBoard();
          // Controlled flash for major events only
          this.flashBackground(linesToClear.length === 4 ? 'tetris' : 'clear', linesToClear.length);

          setTimeout(() => {
            // Remove lines
            this.board = this.board.filter((_, y) => !linesToClear.includes(y));
            while (this.board.length < BOARD_HEIGHT) this.board.unshift(Array(BOARD_WIDTH).fill(0));

            // Score and level updates
            const points = linesToClear.length === 1 ? 100 :
                           linesToClear.length === 2 ? 300 :
                           linesToClear.length === 3 ? 500 : 800;
            this.score += points * this.level;
            this.lines += linesToClear.length;
            this.level = Math.floor(this.lines / 10) + 1;
            this.fallSpeed = Math.max(100, 500 - (this.level - 1) * 40);

            // Achievements gates
            if (linesToClear.length === 4) this.achievements.tetrisMaster = true;

            // Perfect clear check
            if (this.board.every(row => row.every(cell => cell === 0))) {
              this.showMessage('‚òÖ PERFECT CLEAR ‚òÖ', 'perfect-clear', 2000);
              this.score += 1000;
              this.achievements.perfectClearer = true;
              this.flashBackground('perfect', 5);
            }

            // Action text
            let actionText = '';
            if (linesToClear.length === 4) actionText = 'TETRIS!';
            else if (linesToClear.length === 3) actionText = 'TRIPLE!';
            else if (linesToClear.length === 2) actionText = 'DOUBLE!';
            if (actionText) this.showMessage(actionText, 'action-text', 1500);

            // Combo
            this.comboCount++;
            if (this.comboCount >= 3) this.achievements.comboKing = true;
            if (this.comboCount > 1) {
              this.showMessage(`${this.comboCount}x COMBO!`, 'combo-text', 1000);
              /* No extra flash for combo in comfort mode */
            }

            this.clearingLines = [];
            this.updateDisplay();
            this.updateAchievementsUI();
            this.dropLock = false;
            this.spawnPiece();
            this.render();
            this.updateReactiveBackground();
          }, 440);
        } else {
          this.comboCount = 0;
          this.dropLock = false;
          this.spawnPiece();
        }
      }

      holdPiece() {
        if (!this.canHold || !this.currentPiece || this.gameOver || this.isPaused || this.clearingLines.length > 0 || this.dropLock) return;

        this.canHold = false;
        const holdPanel = document.getElementById('holdPanel');
        holdPanel.classList.add('glow');
        setTimeout(() => holdPanel.classList.remove('glow'), 280);

        if (this.heldPiece) {
          const temp = this.currentPiece;
          this.spawnPiece(this.heldPiece);
          this.heldPiece = temp;
        } else {
          this.heldPiece = this.currentPiece;
          this.spawnPiece();
        }

        this.renderHold();
      }

      createParticles(x, y, color, count) {
        for (let i = 0; i < count; i++) {
          this.particles.push({
            x: x * CELL_SIZE + CELL_SIZE / 2 + 2,
            y: y * CELL_SIZE + CELL_SIZE / 2 + 2,
            vx: (Math.random() - 0.5) * 10,
            vy: (Math.random() - 0.5) * 10 - 3.2,
            color,
            life: 1,
            size: Math.random() * 3 + 2
          });
        }
      }

      updateParticles() {
        const ctx = this.particleCtx;
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

        this.particles = this.particles.filter(p => {
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.38;
          p.vx *= 0.988;
          p.life -= 0.015;

          if (p.life > 0) {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.shadowBlur = 10;
            ctx.shadowColor = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
            ctx.fill();
            return true;
          }
          return false;
        });

        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
      }

      shakeBoard() {
        const board = document.getElementById('gameBoard');
        board.classList.add('shake');
        setTimeout(() => board.classList.remove('shake'), 110);
      }

      showMessage(text, className, duration) {
        const container = document.getElementById('overlayMessages');
        const msg = document.createElement('div');
        msg.className = `overlay-message ${className}`;
        msg.textContent = text;
        container.appendChild(msg);
        setTimeout(() => { msg.remove(); }, duration);
      }

      updateAchievementsUI() {
        const wrap = document.getElementById('achievements');
        wrap.innerHTML = '';
        const entries = Object.entries(this.achievements);
        entries.forEach(([key, val]) => {
          if (!val) return;
          const badge = document.createElement('div');
          badge.className = 'badge';
          const dot = document.createElement('div');
          dot.className = 'dot';
          const label = document.createElement('span');
          label.textContent = key.replace(/([A-Z])/g, ' $1').toUpperCase();
          badge.appendChild(dot);
          badge.appendChild(label);
          wrap.appendChild(badge);
        });
      }

      showGameOver() {
        const screen = document.getElementById('gameOverScreen');
        screen.style.display = 'block';
        screen.innerHTML = `
          <div class="game-over" style="animation: fadeIn 0.5s;">
            <div class="game-over-title">GAME OVER</div>
            <div style="font-size: 1.5rem; margin-bottom: 20px;">
              Final Score: <span style="color: #00f0f0; font-weight: bold;">${this.score}</span>
            </div>
            <button class="btn" onclick="location.reload()">Play Again</button>
          </div>
        `;
        // End-game backdrop and subtle board collapse (comfort)
        const endBg = document.getElementById('endGameBg');
        endBg.classList.add('active');

        const gameContainer = document.getElementById('gameContainer');
        gameContainer.animate(
          [
            { transform: 'scale(1)', filter: 'none' },
            { transform: 'scale(0.95)', filter: 'blur(0.6px)' },
            { transform: 'scale(0.92) rotate(0.6deg)', filter: 'blur(1px)' }
          ],
          { duration: 520, easing: 'ease-in', fill: 'forwards' }
        );

        // Particle burst across the board (soft)
        for (let y = 0; y < BOARD_HEIGHT; y++) {
          for (let x = 0; x < BOARD_WIDTH; x++) {
            if (this.board[y][x]) {
              const color = COLORS[this.board[y][x]];
              const intensityFactor = this.particlesIntensity / 100;
              this.createParticles(x, y, color, Math.round(8 * intensityFactor));
            }
          }
        }
        this.flashBackground('gameover', 3);
      }

      setupControls() {
        document.addEventListener('keydown', (e) => {
          if (this.gameOver) return;

          if (['ArrowLeft', 'ArrowRight', 'ArrowDown', 'ArrowUp', ' ', 'c', 'C', 'p', 'P'].includes(e.key)) {
            e.preventDefault();
          }

          if (!this.keysPressed[e.key]) {
            this.keysPressed[e.key] = true;

            switch(e.key) {
              case 'ArrowUp': this.rotatePiece(); break;
              case ' ': this.hardDrop(); break;
              case 'c': case 'C': this.holdPiece(); break;
              case 'p': case 'P':
                this.isPaused = !this.isPaused;
                if (this.isPaused) {
                  this.showMessage('‚è∏ PAUSED', 'paused', 999999);
                } else {
                  document.getElementById('overlayMessages').innerHTML = '';
                  this.lastFallTime = Date.now();
                }
                break;
            }

            if (['ArrowLeft', 'ArrowRight', 'ArrowDown'].includes(e.key)) {
              this.handleMovement(e.key);
              this.dasTimers[e.key] = setTimeout(() => {
                this.dasIntervals[e.key] = setInterval(() => { this.handleMovement(e.key); }, DAS_INTERVAL);
              }, DAS_DELAY);
            }
          }
        });

        document.addEventListener('keyup', (e) => {
          this.keysPressed[e.key] = false;
          if (this.dasTimers[e.key]) { clearTimeout(this.dasTimers[e.key]); delete this.dasTimers[e.key]; }
          if (this.dasIntervals[e.key]) { clearInterval(this.dasIntervals[e.key]); delete this.dasIntervals[e.key]; }
        });
      }

      handleMovement(key) {
        switch(key) {
          case 'ArrowLeft':
            this.movePiece(-1, 0);
            break;
          case 'ArrowRight':
            this.movePiece(1, 0);
            break;
          case 'ArrowDown':
            if (this.movePiece(0, 1)) this.lastFallTime = Date.now();
            break;
        }
      }

      gameLoop() {
        const now = Date.now();

        if (!this.gameOver && !this.isPaused && !this.dropLock && now - this.lastFallTime > this.fallSpeed) {
          if (!this.movePiece(0, 1)) this.lockPiece();
          this.lastFallTime = now;
        }

        this.updateParticles();
        requestAnimationFrame(() => this.gameLoop());
      }

      render() {
        const board = document.getElementById('gameBoard');
        board.innerHTML = '';
        board.style.gridTemplateColumns = `repeat(${BOARD_WIDTH}, ${CELL_SIZE}px)`;

        for (let y = 0; y < BOARD_HEIGHT; y++) {
          for (let x = 0; x < BOARD_WIDTH; x++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.dataset.y = y;
            cell.dataset.x = x;
            cell.style.width = CELL_SIZE + 'px';
            cell.style.height = CELL_SIZE + 'px';

            let isCurrentPiece = false;
            let isGhost = false;
            let pieceColor = null;

            if (this.currentPiece) {
              for (let py = 0; py < this.currentPiece.shape.length; py++) {
                for (let px = 0; px < this.currentPiece.shape[py].length; px++) {
                  if (this.currentPiece.shape[py][px]) {
                    if (this.currentPos.x + px === x && this.currentPos.y + py === y) {
                      isCurrentPiece = true;
                      pieceColor = COLORS[this.currentPiece.type];
                    }
                    if (this.ghostPos !== null && this.currentPos.x + px === x && this.ghostPos + py === y) {
                      isGhost = true;
                    }
                  }
                }
              }
            }

            if (isCurrentPiece) {
              cell.style.backgroundColor = pieceColor;
              cell.style.boxShadow = `0 0 12px ${pieceColor}, inset 0 0 8px ${pieceColor}40`;
            } else if (isGhost && !this.board[y][x]) {
              cell.style.backgroundColor = 'var(--ghost-bg)';
              cell.style.border = `2px dashed var(--ghost-border)`;
            } else if (this.board[y][x]) {
              const color = COLORS[this.board[y][x]];
              cell.style.backgroundColor = color;
              cell.style.boxShadow = `0 0 6px ${color}40`;
            } else {
              cell.style.backgroundColor = '#0a0a0a';
            }

            if (this.clearingLines.includes(y) && this.board[y][x]) {
              const type = this.board[y][x];
              const color = COLORS[type];
              cell.style.setProperty('--cell-color', color);
              cell.classList.add('clearing');
            }

            board.appendChild(cell);
          }
        }

        this.renderHold();
        this.renderNext();
      }

      renderHold() {
        const holdBox = document.getElementById('holdBox');
        holdBox.innerHTML = '';

        if (this.heldPiece) {
          const preview = this.createPiecePreview(this.heldPiece, 20);
          holdBox.appendChild(preview);
        }
      }

      renderNext() {
        const container = document.getElementById('nextPieces');
        container.innerHTML = '';

        this.nextPieces.slice(0, 3).forEach((piece, i) => {
          const box = document.createElement('div');
          box.className = 'preview-box next-preview';
          box.style.opacity = (1 - (i * 0.25)).toString();
          box.style.transform = 'scale(' + (1 - (i * 0.1)) + ')';

          const preview = this.createPiecePreview(piece, 20);
          box.appendChild(preview);
          container.appendChild(box);
        });
      }

      createPiecePreview(piece, size) {
        const container = document.createElement('div');
        container.style.display = 'inline-block';

        piece.shape.forEach(function(row) {
          const rowDiv = document.createElement('div');
          rowDiv.style.display = 'flex';

          row.forEach(function(cell) {
            const cellDiv = document.createElement('div');
            cellDiv.style.width = size + 'px';
            cellDiv.style.height = size + 'px';
            cellDiv.style.border = cell ? '1px solid rgba(255,255,255,0.3)' : 'none';
            cellDiv.style.backgroundColor = cell ? COLORS[piece.type] : 'transparent';
            cellDiv.style.borderRadius = '2px';
            cellDiv.style.transition = 'all 0.1s';
            if (cell) {
              cellDiv.style.boxShadow = '0 0 ' + (size/4) + 'px ' + COLORS[piece.type] + '40';
            }
            rowDiv.appendChild(cellDiv);
          });

          container.appendChild(rowDiv);
        });

        return container;
      }

      updateDisplay() {
        document.getElementById('score').textContent = this.score;
        document.getElementById('level').textContent = this.level;
        document.getElementById('lines').textContent = this.lines;

        // Micro feedback on stats (soft)
        const scoreEl = document.getElementById('score').parentElement;
        const levelEl = document.getElementById('level').parentElement;
        const linesEl = document.getElementById('lines').parentElement;

        scoreEl.animate([{ transform: 'scale(1)' }, { transform: 'scale(1.04)' }, { transform: 'scale(1)' }], { duration: 180 });
        levelEl.animate([{ transform: 'scale(1)' }, { transform: 'scale(1.02)' }, { transform: 'scale(1)' }], { duration: 180 });
        linesEl.animate([{ transform: 'scale(1)' }, { transform: 'scale(1.02)' }, { transform: 'scale(1)' }], { duration: 180 });
      }

      updateReactiveBackground(initial = false) {
        const root = document.documentElement;
        const speed = Math.max(7.5, 16 - (this.level - 1) * 1.1);
        root.style.setProperty('--bg-speed', `${speed}s`);

        const intensity = Math.min(1, 0.055 * (this.level - 1));
        const bg1 = this.mixColor('#0e132f', getComputedStyle(root).getPropertyValue('--accent1').trim(), intensity);
        const bg2 = this.mixColor('#14213d', getComputedStyle(root).getPropertyValue('--accent2').trim(), intensity * 0.7);
        const bg3 = this.mixColor('#1f2a57', '#00f0f0', intensity * 0.5);
        root.style.setProperty('--bg1', bg1);
        root.style.setProperty('--bg2', bg2);
        root.style.setProperty('--bg3', bg3);

        const titleGlow = `rgba(168, 85, 247, ${0.38 + Math.min(0.28, intensity)})`;
        root.style.setProperty('--title-glow', titleGlow);

        if (initial) {
          root.style.setProperty('--reactive-brightness', '1');
          root.style.setProperty('--reactive-sat', '105%');
          root.style.setProperty('--reactive-hue', '0deg');
        }
      }

      // Comfort-mode flash: reserved for major events; reduced intensity
      flashBackground(type, magnitude = 1) {
        if (!this.comfortMode) {
          /* If comfort mode off, we could crank visuals ‚Äî here still modest */
        }
        const root = document.documentElement;
        const originalSpeed = getComputedStyle(root).getPropertyValue('--bg-speed').trim();
        const originalGlow = getComputedStyle(root).getPropertyValue('--board-glow').trim();

        let boostB = 1.18;
        let boostS = 112;
        let hue = 0;
        let blur = '0px';
        let speedBoost = 0.7;
        let glow = originalGlow;
        let uiScale = 1;

        switch (type) {
          case 'clear':
            boostB = 1.22; boostS = 115; hue = 18; blur = '0.8px'; speedBoost = 0.6; glow = 'rgba(255,255,255,0.6)'; uiScale = 1.015; break;
          case 'tetris':
            boostB = 1.26; boostS = 118; hue = 42; blur = '1.2px'; speedBoost = 0.5; glow = 'rgba(255,0,255,0.7)'; uiScale = 1.02; break;
          case 'perfect':
            boostB = 1.28; boostS = 120; hue = 120; blur = '1.4px'; speedBoost = 0.48; glow = 'rgba(0,240,240,0.8)'; uiScale = 1.025; break;
          case 'gameover':
            boostB = 1.24; boostS = 108; hue = -22; blur = '1px'; speedBoost = 0.65; glow = 'rgba(255,0,0,0.7)'; uiScale = 0.985; break;
          default:
            return; // movement/hold/rotate: no flash
        }

        // Clamp brightness to comfort cap
        const cap = parseFloat(getComputedStyle(root).getPropertyValue('--comfort-brightness-cap')) || 1.3;
        boostB = Math.min(boostB, cap);

        root.style.setProperty('--reactive-brightness', boostB.toString());
        root.style.setProperty('--reactive-sat', `${boostS}%`);
        root.style.setProperty('--reactive-hue', `${hue}deg`);
        root.style.setProperty('--reactive-blur', blur);

        const newSpeed = `calc(${originalSpeed} * ${speedBoost})`;
        root.style.setProperty('--bg-speed', newSpeed);
        root.style.setProperty('--board-glow', glow);
        root.style.setProperty('--ui-scale', uiScale.toString());

        const duration = parseFloat(getComputedStyle(root).getPropertyValue('--comfort-duration')) || 360;

        setTimeout(() => {
          root.style.setProperty('--reactive-brightness', '1');
          root.style.setProperty('--reactive-sat', '105%');
          root.style.setProperty('--reactive-hue', '0deg');
          root.style.setProperty('--reactive-blur', '0px');
          root.style.setProperty('--bg-speed', originalSpeed);
          root.style.setProperty('--board-glow', originalGlow);
          root.style.setProperty('--ui-scale', '1');
        }, duration);
      }

      mixColor(hex1, hex2, t) {
        const a = this.hexToRgb(hex1), b = this.hexToRgb(hex2);
        const r = Math.round(a.r + (b.r - a.r) * t);
        const g = Math.round(a.g + (b.g - a.g) * t);
        const b2 = Math.round(a.b + (b.b - a.b) * t);
        return `rgb(${r}, ${g}, ${b2})`;
      }

      hexToRgb(hex) {
        const h = hex.replace('#', '');
        const bigint = parseInt(h, 16);
        if (h.length === 6) {
          return { r: (bigint >> 16) & 255, g: (bigint >> 8) & 255, b: bigint & 255 };
        }
        const r = parseInt(h[0] + h[0], 16);
        const g = parseInt(h[1] + h[1], 16);
        const b = parseInt(h[2] + h[2], 16);
        return { r, g, b };
      }
    }

    /* =========================================================
       E) Boot
       ========================================================= */
    window.addEventListener('DOMContentLoaded', () => { new TetrisGame(); });
  </script>
</body>
</html>
```
