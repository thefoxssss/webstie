<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shadow Assassin - Castle Infiltration</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0a;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }

        #gameCanvas {
            border: 2px solid #8b4513;
            box-shadow: 0 0 30px rgba(139, 69, 19, 0.5);
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
        }

        #keybinds {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #fff;
            font-size: 13px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border: 2px solid #8b4513;
            border-radius: 5px;
            min-width: 200px;
        }

        #keybinds h3 {
            color: #ffd700;
            margin-bottom: 10px;
            font-size: 16px;
            text-align: center;
        }

        .keybind-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 3px 0;
            border-bottom: 1px solid rgba(139, 69, 19, 0.3);
        }

        .keybind-key {
            color: #ffd700;
            font-weight: bold;
        }

        .keybind-ability {
            color: #ccc;
        }

        #mythicPanel {
            position: absolute;
            top: 20px;
            left: 250px;
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid #ff00ff;
            padding: 15px;
            border-radius: 5px;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
            z-index: 100;
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.5);
        }

        #mythicPanel h2 {
            color: #ff00ff;
            text-align: center;
            margin-bottom: 15px;
            font-size: 20px;
            text-shadow: 0 0 10px #ff00ff;
        }

        .mythic-ability {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin: 5px 0;
            background: rgba(139, 69, 19, 0.3);
            border: 1px solid #8b4513;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .mythic-ability:hover {
            background: rgba(139, 69, 19, 0.5);
            border-color: #ffd700;
        }

        .mythic-ability.active {
            background: rgba(255, 215, 0, 0.2);
            border-color: #ffd700;
        }

        .mythic-ability-name {
            color: #fff;
            font-size: 12px;
            flex: 1;
        }

        .mythic-ability-toggle {
            width: 40px;
            height: 20px;
            background: #444;
            border: 2px solid #666;
            border-radius: 10px;
            position: relative;
            transition: all 0.3s;
        }

        .mythic-ability.active .mythic-ability-toggle {
            background: #4caf50;
            border-color: #66bb6a;
        }

        .mythic-ability-toggle::after {
            content: '';
            position: absolute;
            width: 12px;
            height: 12px;
            background: #fff;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: all 0.3s;
        }

        .mythic-ability.active .mythic-ability-toggle::after {
            left: 20px;
        }

        #mythicToggleBtn {
            position: absolute;
            top: 120px;
            left: 20px;
            background: linear-gradient(135deg, #8b008b, #4b0082);
            border: 3px solid #ff00ff;
            padding: 10px 15px;
            color: #fff;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            display: none;
            z-index: 10;
            border-radius: 5px;
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.5);
            animation: mythicPulse 2s ease-in-out infinite;
        }

        @keyframes mythicPulse {
            0%, 100% {
                box-shadow: 0 0 15px rgba(255, 0, 255, 0.5);
            }
            50% {
                box-shadow: 0 0 25px rgba(255, 0, 255, 0.8);
            }
        }

        #mythicToggleBtn:hover {
            background: linear-gradient(135deg, #9932cc, #8b008b);
            transform: scale(1.05);
        }

        .health-bar {
            width: 200px;
            height: 20px;
            background: #222;
            border: 2px solid #8b4513;
            margin-top: 5px;
            position: relative;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #dc143c, #8b0000);
            transition: width 0.3s;
        }

        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #aaa;
            font-size: 12px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .title {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #fff;
            z-index: 5;
            pointer-events: none;
        }

        .title h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #8b4513;
            text-shadow: 0 0 20px rgba(139, 69, 19, 0.8);
        }

        .title p {
            font-size: 18px;
            color: #ccc;
        }

        .fade-out {
            animation: fadeOut 2s forwards;
        }

        @keyframes fadeOut {
            to { opacity: 0; }
        }

        .upgrade-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .upgrade-container {
            text-align: center;
            color: #fff;
        }

        .upgrade-title {
            font-size: 36px;
            color: #ffd700;
            margin-bottom: 30px;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .upgrade-options {
            display: flex;
            gap: 30px;
            justify-content: center;
        }

        .upgrade-card {
            background: linear-gradient(135deg, #2a2a2a, #1a1a1a);
            border: 3px solid #8b4513;
            padding: 20px;
            width: 250px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }

        .upgrade-card:hover {
            transform: translateY(-10px);
            border-color: #ffd700;
            box-shadow: 0 10px 30px rgba(255, 215, 0, 0.3);
        }

        .upgrade-card h3 {
            color: #ffd700;
            font-size: 22px;
            margin-bottom: 10px;
        }

        .upgrade-card .level {
            color: #ff8c00;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .upgrade-card p {
            color: #ccc;
            font-size: 14px;
            line-height: 1.5;
        }

        .upgrade-card.mythic {
            border-color: #ff00ff;
            animation: mythicGlow 2s ease-in-out infinite;
        }

        .upgrade-card.mythic h3 {
            color: #ff00ff;
            text-shadow: 0 0 15px #ff00ff;
        }

        @keyframes mythicGlow {
            0%, 100% {
                box-shadow: 0 0 20px rgba(255, 0, 255, 0.6), 0 0 40px rgba(255, 0, 255, 0.4);
            }
            50% {
                box-shadow: 0 0 30px rgba(255, 0, 255, 0.8), 0 0 60px rgba(255, 0, 255, 0.6);
            }
        }

        .game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .game-over-title {
            font-size: 48px;
            color: #ff0000;
            margin-bottom: 30px;
            text-shadow: 0 0 20px rgba(255, 0, 0, 0.8);
        }

        .game-over-stats {
            color: #ffd700;
            font-size: 20px;
            margin-bottom: 30px;
        }

        .button-container {
            display: flex;
            gap: 20px;
        }

        .game-button {
            background: linear-gradient(135deg, #8b4513, #654321);
            border: 3px solid #ffd700;
            padding: 15px 40px;
            color: #fff;
            font-size: 18px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }

        .game-button:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(255, 215, 0, 0.4);
            background: linear-gradient(135deg, #a0522d, #8b4513);
        }

        .game-button:active {
            transform: translateY(-2px);
        }
        
        .main-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 50%, #0a0a0a 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }

        .main-menu h1 {
            font-size: 64px;
            color: #8b4513;
            text-shadow: 0 0 30px rgba(139, 69, 19, 0.9);
            margin-bottom: 50px;
            animation: titlePulse 2s ease-in-out infinite;
        }

        @keyframes titlePulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .menu-button {
            background: linear-gradient(135deg, #8b4513, #654321);
            border: 3px solid #ffd700;
            padding: 20px 60px;
            color: #fff;
            font-size: 24px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            min-width: 300px;
        }

        .menu-button:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(255, 215, 0, 0.4);
            background: linear-gradient(135deg, #a0522d, #8b4513);
        }

        .settings-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 201;
        }

        .settings-container {
            background: linear-gradient(135deg, #2a2a2a, #1a1a1a);
            border: 3px solid #8b4513;
            padding: 40px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .settings-container h2 {
            color: #ffd700;
            font-size: 32px;
            margin-bottom: 30px;
            text-align: center;
        }

        .setting-item {
            margin-bottom: 25px;
            color: #fff;
        }

        .setting-item label {
            display: block;
            margin-bottom: 10px;
            font-size: 16px;
            color: #ffd700;
        }

        .setting-item input[type="range"] {
            width: 100%;
            height: 8px;
            background: #444;
            outline: none;
            border-radius: 4px;
        }

        .setting-item input[type="range"]::-webkit-slider-thumb {
            width: 20px;
            height: 20px;
            background: #ffd700;
            cursor: pointer;
            border-radius: 50%;
        }

        .setting-value {
            display: inline-block;
            margin-left: 15px;
            color: #fff;
            font-weight: bold;
        }

        .toggle-button {
            padding: 10px 20px;
            background: #444;
            border: 2px solid #666;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Courier New', monospace;
        }

        .toggle-button.active {
            background: #ffd700;
            border-color: #ffd700;
            color: #000;
        }

        .setting-item select {
            width: 100%;
            padding: 10px;
            background: #444;
            border: 2px solid #666;
            color: #fff;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }

        #safeRoomScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 50, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 150;
        }

        #safeRoomScreen h2 {
            color: #00ff00;
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 0 30px rgba(0, 255, 0, 0.8);
        }

        #safeRoomScreen p {
            color: #90ee90;
            font-size: 20px;
            margin-bottom: 40px;
            text-align: center;
            max-width: 600px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="1200" height="700"></canvas>
    
    <!-- UI Overlay -->
    <div id="ui">
        <div>Health: <span id="health">150</span></div>
        <div class="health-bar">
            <div id="healthBar" class="health-fill" style="width: 100%"></div>
        </div>
        <div style="margin-top: 10px;">Chamber: <span id="room">1</span></div>
        <div>Enemies: <span id="enemies">0</span></div>
        
        <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid #666;">
            <div style="font-size: 12px; color: #ffd700; margin-bottom: 5px;">⚡ SPECIAL ABILITIES</div>
            <div id="specialAbilitiesList" style="font-size: 11px;"></div>
        </div>
    </div>
    
    <!-- Keybinds Display -->
    <div id="keybinds">
        <h3>⚔️ Abilities ⚔️</h3>
        <div class="keybind-item">
            <span class="keybind-key">[J]</span>
            <span class="keybind-ability">Dagger Attack</span>
        </div>
        <div class="keybind-item">
            <span class="keybind-key">[K]</span>
            <span class="keybind-ability">Dash</span>
        </div>
        <div class="keybind-item">
            <span class="keybind-key">[L]</span>
            <span class="keybind-ability">Ranged Attack</span>
        </div>
        <div id="additionalKeybinds"></div>
    </div>
    
    <!-- Mythic Mode Toggle Button -->
    <button id="mythicToggleBtn">🔮 Mythic Panel</button>
    
    <!-- Mythic Mode Ability Panel -->
    <div id="mythicPanel">
        <h2>✨ MYTHIC ABILITIES ✨</h2>
        <div id="mythicAbilityList"></div>
    </div>
    
    <!-- Controls -->
    <div class="controls">
        WASD/Arrows: Move & Aim Knife | SPACE: Jump | J: Dagger | K: Dash | L: Knife<br>
        Q/E: Special Abilities
    </div>
    
    <!-- Main Menu -->
    <div id="mainMenu" class="main-menu">
        <h1>⚔️ SHADOW ASSASSIN ⚔️</h1>
        <div class="menu-buttons">
            <button id="playBtn" class="menu-button">NEW GAME</button>
            <button id="continueBtn" class="menu-button" style="display: none;">CONTINUE</button>
            <button id="settingsBtn" class="menu-button">SETTINGS</button>
        </div>
    </div>

    <!-- Settings Menu -->
    <div id="settingsMenu" class="settings-menu">
        <div class="settings-container">
            <h2>⚙️ SETTINGS ⚙️</h2>
            
            <div class="setting-item">
                <label>Master Volume: <span id="volumeValue" class="setting-value">100%</span></label>
                <input type="range" id="volumeSlider" min="0" max="100" value="100">
            </div>
            
            <div class="setting-item">
                <label>Music Volume: <span id="musicValue" class="setting-value">70%</span></label>
                <input type="range" id="musicSlider" min="0" max="100" value="70">
            </div>
            
            <div class="setting-item">
                <label>SFX Volume: <span id="sfxValue" class="setting-value">100%</span></label>
                <input type="range" id="sfxSlider" min="0" max="100" value="100">
            </div>
            
            <div class="setting-item">
                <label>Particles: <span id="particlesValue" class="setting-value">ON</span></label>
                <button id="particlesToggle" class="toggle-button active">TOGGLE</button>
            </div>
            
            <div class="setting-item">
                <label>Screen Shake: <span id="screenShakeValue" class="setting-value">ON</span></label>
                <button id="screenShakeToggle" class="toggle-button active">TOGGLE</button>
            </div>
            
            <div class="setting-item">
                <label>Damage Numbers: <span id="damageNumbersValue" class="setting-value">ON</span></label>
                <button id="damageNumbersToggle" class="toggle-button active">TOGGLE</button>
            </div>
            
            <div class="setting-item">
                <label>Show FPS: <span id="fpsValue" class="setting-value">OFF</span></label>
                <button id="fpsToggle" class="toggle-button">TOGGLE</button>
            </div>
            
            <div class="setting-item">
                <label>Difficulty:</label>
                <select id="difficultySelect">
                    <option value="easy">Easy</option>
                    <option value="normal" selected>Normal</option>
                    <option value="hard">Hard</option>
                </select>
            </div>
            
            <button id="backBtn" class="game-button" style="width: 100%; margin-top: 20px;">BACK</button>
        </div>
    </div>
    
    <!-- Upgrade Screen -->
    <div id="upgradeScreen" class="upgrade-screen">
        <div class="upgrade-container">
            <div class="upgrade-title">⚡ CHOOSE YOUR UPGRADE ⚡</div>
            <div id="upgradeOptions" class="upgrade-options"></div>
        </div>
    </div>
    
    <!-- Game Over Screen -->
    <div id="gameOverScreen" class="game-over-screen">
        <div class="game-over-title">💀 DEFEATED 💀</div>
        <div class="game-over-stats">
            You reached Chamber <span id="finalRoom">1</span>
        </div>
        <div class="button-container">
            <button class="game-button" id="playAgainBtn">⚔️ Play Again</button>
            <button class="game-button" id="loadCheckpointBtn">📍 Load Checkpoint</button>
        </div>
    </div>

    <div id="safeRoomScreen">
        <h2>🛡️ SAFE ROOM 🛡️</h2>
        <p>You have reached a safe checkpoint. Your progress has been saved.<br>Health fully restored. Take a moment to prepare for the challenges ahead.</p>
        <button class="game-button" id="safeRoomContinueBtn">CONTINUE</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Particle class
        class Particle {
            constructor(x, y, color, vx, vy, life) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.vx = vx;
                this.vy = vy;
                this.life = life;
                this.maxLife = life;
            }
            
            update() {
                // Pause during upgrade selection
                if (showingUpgrade) return;
                
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.2;
                this.life--;
            }
            
            draw() {
                const alpha = this.life / this.maxLife;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - 2, this.y - 2, 4, 4);
                ctx.globalAlpha = 1;
            }
        }

        // Projectile class  
        class Projectile {
            constructor(x, y, angle, speed, owner) {
                this.x = x;
                this.y = y;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.owner = owner;
                this.life = 180;
                this.explosive = false;
                this.homing = false;
                this.angle = angle;
            }
            
            update() {
                // Pause during upgrade selection
                if (showingUpgrade) return true;
                
                // Homing behavior
                if (this.homing && this.owner === 'player') {
                    let nearest = null;
                    let nearestDist = Infinity;
                    for (const enemy of currentRoom.enemies) {
                        const dist = Math.sqrt((enemy.x - this.x)**2 + (enemy.y - this.y)**2);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearest = enemy;
                        }
                    }
                    if (nearest && nearestDist < 400) {
                        const angle = Math.atan2(nearest.y - this.y, nearest.x - this.x);
                        this.vx += Math.cos(angle) * 0.5;
                        this.vy += Math.sin(angle) * 0.5;
                    }
                }
                
                this.x += this.vx;
                this.y += this.vy;
                this.life--;
                
                // Trail particle
                if (Math.random() < 0.2) {
                    particles.push(new Particle(
                        this.x, this.y,
                        this.owner === 'player' ? '#1a1a1a' : '#ff4500',
                        0, 0, 10
                    ));
                }
                
                return this.life > 0 && this.x > 0 && this.x < canvas.width && this.y > 0 && this.y < canvas.height;
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(Math.atan2(this.vy, this.vx));
                
                // Knife shape
                if (this.owner === 'player') {
                    ctx.fillStyle = '#c0c0c0';
                    ctx.fillRect(0, -2, 12, 4);
                    ctx.fillStyle = '#8b4513';
                    ctx.fillRect(-4, -1, 4, 2);
                } else {
                    // Enemy projectile (arrow)
                    ctx.fillStyle = '#8b4513';
                    ctx.fillRect(-4, -1, 8, 2);
                    ctx.fillStyle = '#c0c0c0';
                    ctx.beginPath();
                    ctx.moveTo(8, 0);
                    ctx.lineTo(4, -4);
                    ctx.lineTo(4, 4);
                    ctx.closePath();
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }

        // Shadow Clone class
        class ShadowClone {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 24;
                this.height = 32;
                this.vx = 0;
                this.vy = 0;
                this.life = 300;
                this.facing = 1;
                this.onGround = false;
                this.gravity = 0.6;
                this.attackCooldown = 0;
            }
            
            mimicMeleeAttack() {
                this.attackCooldown = 30;
                for (let i = 0; i < 10; i++) {
                    const angle = (Math.random() - 0.5) * Math.PI;
                    const speed = Math.random() * 3 + 2;
                    particles.push(new Particle(
                        this.x + this.facing * 20,
                        this.y,
                        '#2a2a2a',
                        Math.cos(angle) * speed * this.facing,
                        Math.sin(angle) * speed,
                        15
                    ));
                }
            }
            
            mimicRangedAttack() {
                let nearest = null;
                let nearestDist = Infinity;
                for (const enemy of currentRoom.enemies) {
                    const dist = Math.sqrt((enemy.x - this.x)**2 + (enemy.y - this.y)**2);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearest = enemy;
                    }
                }
                
                if (nearest) {
                    const angle = Math.atan2(nearest.y - this.y, nearest.x - this.x);
                    projectiles.push(new Projectile(this.x, this.y, angle, 10, 'player'));
                }
            }
            
            update() {
                // Pause during upgrade selection
                if (showingUpgrade) return true;
                
                this.life--;
                if (this.attackCooldown > 0) this.attackCooldown--;
                
                // Simple AI - follow nearest enemy
                let nearest = null;
                let nearestDist = Infinity;
                for (const enemy of currentRoom.enemies) {
                    const dist = Math.sqrt((enemy.x - this.x)**2 + (enemy.y - this.y)**2);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearest = enemy;
                    }
                }
                
                if (nearest && nearestDist < 300) {
                    const dx = nearest.x - this.x;
                    this.facing = dx > 0 ? 1 : -1;
                    this.vx = this.facing * 3;
                    
                    if (nearestDist < 100 && this.attackCooldown <= 0) {
                        this.mimicMeleeAttack();
                    }
                } else {
                    this.vx *= 0.9;
                }
                
                // Physics
                this.vy += this.gravity;
                this.x += this.vx;
                this.y += this.vy;
                
                // Platform collision
                this.onGround = false;
                for (const platform of currentRoom.platforms) {
                    if (this.x + this.width / 2 > platform.x &&
                        this.x - this.width / 2 < platform.x + platform.width &&
                        this.y + this.height / 2 > platform.y &&
                        this.y + this.height / 2 < platform.y + 20 &&
                        this.vy >= 0) {
                        this.y = platform.y - this.height / 2;
                        this.vy = 0;
                        this.onGround = true;
                    }
                }
                
                if (this.y > canvas.height - 50 - this.height / 2) {
                    this.y = canvas.height - 50 - this.height / 2;
                    this.vy = 0;
                    this.onGround = true;
                }
                
                return this.life > 0;
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.facing, 1);
                ctx.globalAlpha = 0.6;
                
                // Shadow assassin appearance
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                
                ctx.fillStyle = '#0a0a0a';
                ctx.beginPath();
                ctx.arc(0, -this.height / 2 + 6, 10, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(2, -8, 3, 2);
                
                ctx.globalAlpha = 1;
                ctx.restore();
            }
        }

        // Player class
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 24;
                this.height = 32;
                this.vx = 0;
                this.vy = 0;
                this.speed = 5;
                this.jumpPower = 13;
                this.gravity = 0.6;
                this.onGround = false;
                this.health = 150;
                this.maxHealth = 150;
                this.facing = 1;
                
                // Combat
                this.attacking = false;
                this.attackFrame = 0;
                this.attackCooldown = 0;
                this.attackDamage = 25;
                this.attackRange = 50;
                
                // Dash
                this.dashing = false;
                this.dashFrame = 0;
                this.dashCooldown = 0;
                this.dashSpeed = 15;
                
                // Ranged with directional aiming
                this.rangedCooldown = 0;
                this.aimDirection = { x: 1, y: 0 };
                
                // Upgrades
                this.upgrades = {
                    // Basic stats
                    maxHealth: 0, damage: 0, attackSpeed: 0, speed: 0, critChance: 0, critDamage: 0,
                    // Combat
                    multishot: 0, rapidFire: 0, piercing: 0, explosiveKnives: 0, ricochet: 0, magneticKnives: 0,
                    // Defense
                    lifesteal: 0, thorns: 0, bloodArmor: 0, lastStand: 0, ironSkin: 0, evasion: 0,
                    // Mobility
                    dashAttack: 0, ghostWalk: 0, shadowStep: 0, doubleJump: 0, airDash: 0, swiftness: 0,
                    // Effects
                    poisonDagger: 0, frozenTouch: 0, chainLightning: 0, vampiricAura: 0, bloodRage: 0,
                    // Special abilities
                    shadowClone: 0, timeSlowOnKill: 0, berserker: 0, executeThreshold: 0, backstab: 0,
                    frostNova: 0, knifeStorm: 0, vortex: 0, armorPierce: 0, necromancy: 0, flurry: 0,
                    // NEW UPGRADES
                    lifeLink: 0, deathMark: 0, voidWalk: 0, soulHarvest: 0, reflection: 0,
                    arcaneShield: 0, regeneration: 0, multiStrike: 0, bladeDance: 0, berserkerRage: 0,
                    assassination: 0, execution: 0, rage: 0, berserk: 0, whirlwind: 0,
                    teleportStrike: 0, shadowBurst: 0, deathWave: 0, criticalMass: 0, bloodShield: 0,
                    phantomStrike: 0, timeWarp: 0, meteorStrike: 0, phaseShift: 0, divineIntervention: 0,
                    bloodPact: 0, dimensionalRift: 0, soulReaper: 0
                };
                this.usedLastStand = false;
                this.bloodRageStacks = 0;
                this.shield = 0;
                this.hasDoubleJumped = false;
                
                // Special ability slots
                this.special1 = null;
                this.special2 = null;
                this.special1Cooldown = 0;
                this.special2Cooldown = 0;
                
                // Ability effects
                this.invincible = false;
                this.damageMultiplier = 1;
                
                // Animation
                this.animFrame = 0;
                this.animCounter = 0;
                
                // NEW: Status effect tracking
                this.poisonedEnemies = new Set();
                this.frozenEnemies = new Set();
                this.markedEnemies = new Set();
                this.regenTimer = 0;
            }

            attack() {
                if (this.attackCooldown <= 0 && !this.attacking && !this.dashing) {
                    this.attacking = true;
                    this.attackFrame = 0;
                    
                    const baseAttackSpeed = 30;
                    const attackSpeedMultiplier = 1 + (this.upgrades.attackSpeed * 0.15);
                    this.attackCooldown = Math.floor(baseAttackSpeed / attackSpeedMultiplier);
                    
                    // Calculate attack direction based on WASD keys (same as knife throwing)
                    let dirX = 0;
                    let dirY = 0;
                    
                    if (keys['w'] || keys['arrowup']) dirY = -1;
                    if (keys['s'] || keys['arrowdown']) dirY = 1;
                    if (keys['a'] || keys['arrowleft']) dirX = -1;
                    if (keys['d'] || keys['arrowright']) dirX = 1;
                    
                    // If no direction key pressed, use facing direction
                    if (dirX === 0 && dirY === 0) {
                        dirX = this.facing;
                    }
                    
                    // Normalize direction
                    const magnitude = Math.sqrt(dirX * dirX + dirY * dirY);
                    if (magnitude > 0) {
                        dirX /= magnitude;
                        dirY /= magnitude;
                    }
                    
                    const attackAngle = Math.atan2(dirY, dirX);
                    
                    // Store attack direction for animation
                    this.attackDirection = attackAngle;
                    
                    // Multi-strike
                    const strikes = 1 + (this.upgrades.multiStrike || 0);
                    
                    for (let s = 0; s < strikes; s++) {
                        setTimeout(() => {
                            // Check for hits on enemies
                            const attackRange = 70;
                            const attackWidth = 45;
                            
                            // Calculate attack position in the attack direction
                            const attackX = this.x + dirX * attackRange;
                            const attackY = this.y + dirY * attackRange;
                            
                            // Check collision with enemies
                            for (let i = currentRoom.enemies.length - 1; i >= 0; i--) {
                                const enemy = currentRoom.enemies[i];
                                const dx = enemy.x - attackX;
                                const dy = enemy.y - attackY;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                
                                if (dist < attackWidth) {
                                    const baseDamage = this.attackDamage * (1 + this.upgrades.damage * 0.15);
                                    const damageMultiplier = this.damageMultiplier * (mythicMode ? 5 : 1);
                                    let finalDamage = baseDamage * damageMultiplier;
                                    
                                    // Critical hit
                                    const critChance = 0.1 + (this.upgrades.critChance * 0.05);
                                    if (Math.random() < critChance) {
                                        const critDamage = 2 + (this.upgrades.critDamage * 0.3);
                                        finalDamage *= critDamage;
                                        
                                        // Crit particles
                                        for (let j = 0; j < 20; j++) {
                                            particles.push(new Particle(
                                                enemy.x, enemy.y, '#ffff00',
                                                (Math.random() - 0.5) * 10,
                                                (Math.random() - 0.5) * 10,
                                                30
                                            ));
                                        }
                                    }
                                    
                                    // Apply damage
                                    enemy.health -= finalDamage;
                                    
                                    // Lifesteal
                                    if (this.upgrades.lifesteal > 0) {
                                        this.health = Math.min(this.maxHealth, this.health + this.upgrades.lifesteal * 2);
                                    }
                                    
                                    // Check if enemy died
                                    if (enemy.health <= 0) {
                                        // Soul Harvest
                                        if (this.upgrades.soulHarvest > 0) {
                                            this.health = Math.min(this.maxHealth, this.health + this.upgrades.soulHarvest * 3);
                                        }
                                        
                                        // Death particles
                                        for (let j = 0; j < 30; j++) {
                                            particles.push(new Particle(
                                                enemy.x, enemy.y, '#ff0000',
                                                (Math.random() - 0.5) * 12,
                                                (Math.random() - 0.5) * 12,
                                                40
                                            ));
                                        }
                                        
                                        currentRoom.enemies.splice(i, 1);
                                    } else {
                                        // Damage particles
                                        for (let j = 0; j < 15; j++) {
                                            particles.push(new Particle(
                                                enemy.x, enemy.y, '#ff0000',
                                                (Math.random() - 0.5) * 8,
                                                (Math.random() - 0.5) * 8,
                                                25
                                            ));
                                        }
                                    }
                                }
                            }
                            
                            // Check collision with boss
                            if (currentRoom.boss && currentRoom.boss.health > 0) {
                                const dx = currentRoom.boss.x - attackX;
                                const dy = currentRoom.boss.y - attackY;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                
                                if (dist < attackWidth + 25) {
                                    const baseDamage = this.attackDamage * (1 + this.upgrades.damage * 0.15);
                                    const damageMultiplier = this.damageMultiplier * (mythicMode ? 5 : 1);
                                    let finalDamage = baseDamage * damageMultiplier;
                                    
                                    // Critical hit
                                    const critChance = 0.1 + (this.upgrades.critChance * 0.05);
                                    if (Math.random() < critChance) {
                                        const critDamage = 2 + (this.upgrades.critDamage * 0.3);
                                        finalDamage *= critDamage;
                                        
                                        // Crit particles
                                        for (let j = 0; j < 20; j++) {
                                            particles.push(new Particle(
                                                currentRoom.boss.x, currentRoom.boss.y, '#ffff00',
                                                (Math.random() - 0.5) * 10,
                                                (Math.random() - 0.5) * 10,
                                                30
                                            ));
                                        }
                                    }
                                    
                                    currentRoom.boss.health -= finalDamage;
                                    currentRoom.boss.health = Math.max(0, currentRoom.boss.health);
                                    
                                    // Boss damage particles
                                    for (let j = 0; j < 20; j++) {
                                        particles.push(new Particle(
                                            currentRoom.boss.x, currentRoom.boss.y, currentRoom.boss.color,
                                            (Math.random() - 0.5) * 10,
                                            (Math.random() - 0.5) * 10,
                                            35
                                        ));
                                    }
                                    
                                    // Lifesteal
                                    if (this.upgrades.lifesteal > 0) {
                                        this.health = Math.min(this.maxHealth, this.health + this.upgrades.lifesteal * 2);
                                    }
                                }
                            }
                            
                            // Trigger clone attacks
                            for (const clone of shadowClones) {
                                clone.mimicMeleeAttack();
                            }
                            
                            // Attack particles in the attack direction
                            for (let i = 0; i < 15; i++) {
                                const angle = attackAngle + (Math.random() - 0.5) * Math.PI * 0.5;
                                const speed = Math.random() * 5 + 3;
                                particles.push(new Particle(
                                    attackX,
                                    attackY,
                                    Math.random() > 0.5 ? '#1a1a1a' : '#4a4a4a',
                                    Math.cos(angle) * speed,
                                    Math.sin(angle) * speed,
                                    20 + Math.random() * 10
                                ));
                            }
                            
                            // Whirlwind
                            if (this.upgrades.whirlwind > 0) {
                                const bladeCount = 8 + this.upgrades.whirlwind * 4;
                                for (let i = 0; i < bladeCount; i++) {
                                    const angle = (Math.PI * 2 / bladeCount) * i;
                                    projectiles.push(new Projectile(
                                        this.x,
                                        this.y,
                                        angle,
                                        8,
                                        'player'
                                    ));
                                }
                            }
                            
                            // Shadow Burst
                            if (this.upgrades.shadowBurst > 0 && Math.random() < 0.25) {
                                const burstCount = 12;
                                for (let i = 0; i < burstCount; i++) {
                                    const angle = (Math.PI * 2 / burstCount) * i;
                                    projectiles.push(new Projectile(
                                        this.x,
                                        this.y,
                                        angle,
                                        10,
                                        'player'
                                    ));
                                }
                            }
                        }, s * 100);
                    }
                    
                    setTimeout(() => {
                        this.attacking = false;
                        this.attackDirection = null;
                    }, 150);
                }
            }

            dash() {
                if (this.dashCooldown <= 0 && !this.dashing) {
                    this.dashing = true;
                    this.dashFrame = 0;
                    this.dashCooldown = 60 - (this.upgrades.shadowStep * 10);
                    this.vy = 0;
                    
                    // Shadow clone on dash
                    if (this.upgrades.shadowClone > 0 && Math.random() < 0.4) {
                        shadowClones.push(new ShadowClone(this.x, this.y));
                    }
                    
                    // Void Walk damage
                    if (this.upgrades.voidWalk > 0) {
                        for (const enemy of currentRoom.enemies) {
                            const dist = Math.sqrt((enemy.x - this.x)**2 + (enemy.y - this.y)**2);
                            if (dist < 100) {
                                const damage = this.attackDamage * (1 + this.upgrades.damage * 0.15) * 0.8;
                                enemy.takeDamage(damage);
                            }
                        }
                    }
                }
            }

            shootRanged() {
                if (this.rangedCooldown <= 0) {
                    // Calculate direction based on WASD keys
                    let dirX = 0;
                    let dirY = 0;
                    
                    if (keys['w'] || keys['arrowup']) dirY = -1;
                    if (keys['s'] || keys['arrowdown']) dirY = 1;
                    if (keys['a'] || keys['arrowleft']) dirX = -1;
                    if (keys['d'] || keys['arrowright']) dirX = 1;
                    
                    // If no direction key pressed, use facing direction
                    if (dirX === 0 && dirY === 0) {
                        dirX = this.facing;
                    }
                    
                    // Normalize direction
                    const magnitude = Math.sqrt(dirX * dirX + dirY * dirY);
                    if (magnitude > 0) {
                        dirX /= magnitude;
                        dirY /= magnitude;
                    }
                    
                    const angle = Math.atan2(dirY, dirX);
                    const cooldown = Math.max(5, 20 - this.upgrades.rapidFire * 3);
                    const knifeCount = 1 + this.upgrades.multishot;
                    const spreadAngle = 0.3;
                    
                    // Spawn knives ahead of player in the direction they're shooting
                    const spawnDistance = 25;
                    const spawnX = this.x + Math.cos(angle) * spawnDistance;
                    const spawnY = this.y + Math.sin(angle) * spawnDistance;
                    
                    for (let i = 0; i < knifeCount; i++) {
                        const offset = (i - (knifeCount - 1) / 2) * spreadAngle;
                        const proj = new Projectile(
                            spawnX,
                            spawnY,
                            angle + offset,
                            12,
                            'player'
                        );
                        proj.explosive = this.upgrades.explosiveKnives > 0;
                        proj.homing = this.upgrades.magneticKnives > 0;
                        projectiles.push(proj);
                    }
                    
                    this.rangedCooldown = cooldown;
                    
                    // Trigger clone ranged attacks
                    for (const clone of shadowClones) {
                        clone.mimicRangedAttack();
                    }
                    
                    // Muzzle flash at spawn position
                    for (let i = 0; i < 10; i++) {
                        particles.push(new Particle(
                            spawnX,
                            spawnY,
                            '#1a1a1a',
                            (Math.random() - 0.5) * 4 + Math.cos(angle) * 3,
                            (Math.random() - 0.5) * 4 + Math.sin(angle) * 3,
                            15
                        ));
                    }
                }
            }

            useSpecial1() {
                if (this.special1 && this.special1Cooldown <= 0) {
                    const ability = upgradeDefinitions[this.special1];
                    const cooldown = ability.cooldown || 300;
                    this.special1Cooldown = cooldown;
                    this.executeSpecialAbility(this.special1);
                }
            }

            useSpecial2() {
                if (this.special2 && this.special2Cooldown <= 0) {
                    const ability = upgradeDefinitions[this.special2];
                    const cooldown = ability.cooldown || 300;
                    this.special2Cooldown = cooldown;
                    this.executeSpecialAbility(this.special2);
                }
            }
            
            executeSpecialAbility(abilityName) {
                switch(abilityName) {
                    case 'shadowClone':
                        shadowClones.push(new ShadowClone(this.x, this.y));
                        for (let i = 0; i < 30; i++) {
                            particles.push(new Particle(
                                this.x, this.y, '#2a2a2a',
                                (Math.random() - 0.5) * 10,
                                (Math.random() - 0.5) * 10,
                                50
                            ));
                        }
                        break;
                        
                    case 'fireStorm':
                        for (let i = 0; i < 12; i++) {
                            setTimeout(() => {
                                const x = this.x + (Math.random() - 0.5) * 200;
                                projectiles.push(new Projectile(x, 50, Math.PI / 2, 8, 'player'));
                            }, i * 100);
                        }
                        break;
                        
                    case 'bladeDance':
                        for (let i = 0; i < 16; i++) {
                            const angle = (Math.PI * 2 / 16) * i;
                            projectiles.push(new Projectile(this.x, this.y, angle, 12, 'player'));
                        }
                        break;
                        
                    case 'timeWarp':
                        for (const enemy of currentRoom.enemies) {
                            enemy.frozen = true;
                            setTimeout(() => enemy.frozen = false, 2000);
                        }
                        if (currentRoom.boss) {
                            currentRoom.boss.frozen = true;
                            setTimeout(() => currentRoom.boss.frozen = false, 2000);
                        }
                        break;
                        
                    case 'teleportStrike':
                        let nearestTele = null;
                        let nearestTeleDist = Infinity;
                        for (const enemy of currentRoom.enemies) {
                            const dist = Math.sqrt((enemy.x - this.x)**2 + (enemy.y - this.y)**2);
                            if (dist < nearestTeleDist && dist < 500) {
                                nearestTeleDist = dist;
                                nearestTele = enemy;
                            }
                        }
                        if (nearestTele) {
                            this.x = nearestTele.x - nearestTele.facing * 50;
                            this.y = nearestTele.y;
                            nearestTele.takeDamage(150);
                            for (let i = 0; i < 30; i++) {
                                particles.push(new Particle(
                                    this.x, this.y, '#00ffff',
                                    (Math.random() - 0.5) * 12,
                                    (Math.random() - 0.5) * 12,
                                    40
                                ));
                            }
                        }
                        break;
                        
                    case 'deathWave':
                        for (let i = 0; i < 8; i++) {
                            const angle = (Math.PI * 2 / 8) * i;
                            for (let j = 0; j < 3; j++) {
                                setTimeout(() => {
                                    projectiles.push(new Projectile(this.x, this.y, angle, 8 + j * 2, 'player'));
                                }, j * 150);
                            }
                        }
                        break;
                        
                    case 'meteorStrike':
                        for (let i = 0; i < 20; i++) {
                            setTimeout(() => {
                                const x = Math.random() * canvas.width;
                                const proj = new Projectile(x, 0, Math.PI / 2, 12, 'player');
                                projectiles.push(proj);
                            }, i * 75);
                        }
                        break;
                        
                    case 'timeStop':
                        for (const enemy of currentRoom.enemies) {
                            enemy.frozen = true;
                            setTimeout(() => enemy.frozen = false, 3000);
                        }
                        if (currentRoom.boss) {
                            currentRoom.boss.frozen = true;
                            setTimeout(() => currentRoom.boss.frozen = false, 3000);
                        }
                        break;
                        
                    case 'phantomStrike':
                        let nearest = null;
                        let nearestDist = Infinity;
                        for (const enemy of currentRoom.enemies) {
                            const dist = Math.sqrt((enemy.x - this.x)**2 + (enemy.y - this.y)**2);
                            if (dist < nearestDist && dist < 500) {
                                nearestDist = dist;
                                nearest = enemy;
                            }
                        }
                        if (nearest) {
                            this.x = nearest.x - nearest.facing * 50;
                            this.y = nearest.y;
                            nearest.takeDamage(100);
                        }
                        break;
                        
                    case 'omniSlash':
                        for (const enemy of currentRoom.enemies) {
                            enemy.takeDamage(80);
                        }
                        if (currentRoom.boss) currentRoom.boss.takeDamage(80);
                        break;
                        
                    case 'godMode':
                        this.invincible = true;
                        this.damageMultiplier = 10;
                        setTimeout(() => {
                            this.invincible = false;
                            this.damageMultiplier = 1;
                        }, 5000);
                        break;
                        
                    case 'armageddon':
                        for (let i = 0; i < 30; i++) {
                            setTimeout(() => {
                                const x = Math.random() * canvas.width;
                                projectiles.push(new Projectile(x, 0, Math.PI / 2, 15, 'player'));
                            }, i * 50);
                        }
                        break;
                        
                    case 'infinityEdge':
                        for (let i = 0; i < 20; i++) {
                            setTimeout(() => {
                                const angle = Math.random() * Math.PI * 2;
                                const proj = new Projectile(this.x, this.y, angle, 10, 'player');
                                proj.homing = true;
                                projectiles.push(proj);
                            }, i * 50);
                        }
                        break;
                        
                    case 'divineShield':
                        this.invincible = true;
                        setTimeout(() => {
                            this.invincible = false;
                        }, 4000);
                        break;
                        
                    case 'stormCaller':
                        for (const enemy of currentRoom.enemies) {
                            enemy.takeDamage(100);
                            for (let i = 0; i < 20; i++) {
                                particles.push(new Particle(
                                    enemy.x, enemy.y, '#ffff00',
                                    (Math.random() - 0.5) * 10,
                                    (Math.random() - 0.5) * 10,
                                    30
                                ));
                            }
                        }
                        if (currentRoom.boss) {
                            currentRoom.boss.takeDamage(100);
                        }
                        break;
                        
                    case 'timestrike':
                        for (const enemy of currentRoom.enemies) {
                            enemy.frozen = true;
                            setTimeout(() => enemy.frozen = false, 5000);
                        }
                        if (currentRoom.boss) {
                            currentRoom.boss.frozen = true;
                            setTimeout(() => currentRoom.boss.frozen = false, 5000);
                        }
                        break;
                        
                    case 'soulReaper':
                        for (const enemy of currentRoom.enemies) {
                            enemy.health = 0;
                            for (let i = 0; i < 30; i++) {
                                particles.push(new Particle(
                                    enemy.x, enemy.y, '#8b008b',
                                    (Math.random() - 0.5) * 15,
                                    (Math.random() - 0.5) * 15,
                                    40
                                ));
                            }
                        }
                        break;
                        
                    case 'ragnarok':
                        for (const enemy of currentRoom.enemies) {
                            enemy.takeDamage(200);
                        }
                        if (currentRoom.boss) {
                            currentRoom.boss.takeDamage(200);
                        }
                        for (let i = 0; i < 200; i++) {
                            particles.push(new Particle(
                                Math.random() * canvas.width,
                                Math.random() * canvas.height,
                                ['#ff0000', '#ff8800', '#ffff00'][Math.floor(Math.random() * 3)],
                                (Math.random() - 0.5) * 20,
                                (Math.random() - 0.5) * 20,
                                50
                            ));
                        }
                        break;
                }
            }

            update() {
                // Cooldowns
                if (this.attackCooldown > 0) this.attackCooldown--;
                if (this.dashCooldown > 0) this.dashCooldown--;
                if (this.rangedCooldown > 0) this.rangedCooldown--;
                if (this.special1Cooldown > 0) this.special1Cooldown--;
                if (this.special2Cooldown > 0) this.special2Cooldown--;
                
                // Regeneration
                if (this.upgrades.regeneration > 0) {
                    this.regenTimer++;
                    if (this.regenTimer >= 60) {
                        this.health = Math.min(this.maxHealth, this.health + this.upgrades.regeneration * 0.5);
                        this.regenTimer = 0;
                    }
                }
                
                // Vampiric Aura
                if (this.upgrades.vampiricAura > 0) {
                    for (const enemy of currentRoom.enemies) {
                        const dist = Math.sqrt((enemy.x - this.x)**2 + (enemy.y - this.y)**2);
                        if (dist < 150) {
                            if (Math.random() < 0.02) {
                                this.health = Math.min(this.maxHealth, this.health + 1);
                            }
                        }
                    }
                }
                
                // Dash movement
                if (this.dashing) {
                    this.dashFrame++;
                    this.vx = this.facing * this.dashSpeed;
                    
                    // Dash trail
                    for (let i = 0; i < 3; i++) {
                        particles.push(new Particle(
                            this.x, this.y,
                            '#1a1a1a',
                            (Math.random() - 0.5) * 2,
                            (Math.random() - 0.5) * 2,
                            20
                        ));
                    }
                    
                    if (this.dashFrame > 10) {
                        this.dashing = false;
                        this.dashFrame = 0;
                    }
                }
                
                // Physics
                this.vy += this.gravity;
                this.x += this.vx;
                this.y += this.vy;
                
                // Platform collision
                this.onGround = false;
                for (const platform of currentRoom.platforms) {
                    if (this.x + this.width / 2 > platform.x &&
                        this.x - this.width / 2 < platform.x + platform.width &&
                        this.y + this.height / 2 > platform.y &&
                        this.y + this.height / 2 < platform.y + 20 &&
                        this.vy >= 0) {
                        this.y = platform.y - this.height / 2;
                        this.vy = 0;
                        this.onGround = true;
                        this.hasDoubleJumped = false;
                    }
                }
                
                // Ground collision
                if (this.y > canvas.height - 50 - this.height / 2) {
                    this.y = canvas.height - 50 - this.height / 2;
                    this.vy = 0;
                    this.onGround = true;
                    this.hasDoubleJumped = false;
                }
                
                // Bounds
                if (this.x < this.width / 2) this.x = this.width / 2;
                if (this.x > canvas.width - this.width / 2) this.x = canvas.width - this.width / 2;
                
                // Animation
                this.animCounter++;
                if (this.animCounter > 8) {
                    this.animFrame = (this.animFrame + 1) % 4;
                    this.animCounter = 0;
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.facing, 1);
                
                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.ellipse(0, this.height / 2 + 5, this.width / 2, 5, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Dash effect
                if (this.dashing) {
                    ctx.globalAlpha = 0.5;
                    for (let i = 0; i < 3; i++) {
                        ctx.fillStyle = '#1a1a1a';
                        ctx.fillRect(-this.width / 2 - i * 10, -this.height / 2, this.width, this.height);
                    }
                    ctx.globalAlpha = 1;
                }
                
                // Mythic mode aura
                if (mythicMode) {
                    const mythicGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.width * 2);
                    mythicGradient.addColorStop(0, 'rgba(255, 0, 255, 0.3)');
                    mythicGradient.addColorStop(1, 'rgba(255, 0, 255, 0)');
                    ctx.fillStyle = mythicGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width * 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Body (assassin in dark cloak)
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                
                // Hood
                ctx.fillStyle = '#0a0a0a';
                ctx.beginPath();
                ctx.arc(0, -this.height / 2 + 6, 10, 0, Math.PI * 2);
                ctx.fill();
                
                // Face shadow
                ctx.fillStyle = '#2a2a2a';
                ctx.fillRect(-this.width / 2 + 6, -this.height / 2 + 8, this.width - 12, 8);
                
                // Eyes (glowing)
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(2, -8, 3, 2);
                
                // Cloak
                ctx.fillStyle = '#0a0a0a';
                ctx.beginPath();
                ctx.moveTo(-this.width / 2, -this.height / 2 + 12);
                ctx.lineTo(-this.width / 2 - 6, -this.height / 2 + 20 + Math.sin(Date.now() / 100) * 3);
                ctx.lineTo(-this.width / 2 - 4, this.height / 2);
                ctx.lineTo(-this.width / 2, this.height / 2);
                ctx.fill();
                
                // Belt
                ctx.fillStyle = '#4a2511';
                ctx.fillRect(-this.width / 2, 0, this.width, 4);
                
                // Weapon (dagger)
                if (this.attacking && this.attackDirection !== null) {
                    ctx.save();
                    ctx.rotate(this.attackDirection);
                    
                    // Dagger blade
                    ctx.fillStyle = '#c0c0c0';
                    ctx.beginPath();
                    ctx.moveTo(40, 0);
                    ctx.lineTo(10, -3);
                    ctx.lineTo(10, 3);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Blade shine
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.moveTo(35, 0);
                    ctx.lineTo(20, -1);
                    ctx.lineTo(20, 1);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Handle
                    ctx.fillStyle = '#8b4513';
                    ctx.fillRect(8, -2, 8, 4);
                    
                    // Pommel
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.arc(8, 0, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                }
                
                ctx.restore();
            }

            takeDamage(amount) {
                if (this.invincible) return;
                
                // Evasion
                if (this.upgrades.evasion > 0 && Math.random() < this.upgrades.evasion * 0.1) {
                    return;
                }
                
                // Blood Shield
                if (this.upgrades.bloodShield > 0 && Math.random() < 0.15 * this.upgrades.bloodShield) {
                    amount *= 0.5;
                }
                
                // Iron Skin
                if (this.upgrades.ironSkin > 0) {
                    amount *= (1 - this.upgrades.ironSkin * 0.1);
                }
                
                // Thorns
                if (this.upgrades.thorns > 0) {
                    for (const enemy of currentRoom.enemies) {
                        const dx = enemy.x - this.x;
                        const dy = enemy.y - this.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 100) {
                            enemy.takeDamage(amount * 0.3 * this.upgrades.thorns);
                        }
                    }
                }
                
                // Reflection
                if (this.upgrades.reflection > 0) {
                    for (const enemy of currentRoom.enemies) {
                        const dist = Math.sqrt((enemy.x - this.x)**2 + (enemy.y - this.y)**2);
                        if (dist < 200) {
                            enemy.health -= amount * this.upgrades.reflection * 0.3;
                        }
                    }
                }
                
                this.health -= amount;
                this.health = Math.max(0, Math.min(this.health, this.maxHealth));
                
                // Damage particles
                for (let i = 0; i < 20; i++) {
                    particles.push(new Particle(
                        this.x,
                        this.y,
                        '#ff0066',
                        (Math.random() - 0.5) * 8,
                        (Math.random() - 0.5) * 8,
                        30
                    ));
                }
            }
        }

        // Enemy class (keeping original visuals)
        class Enemy {
            constructor(x, y, type = 'basic') {
                this.x = x;
                this.y = y;
                this.width = 28;
                this.height = 32;
                this.vx = 0;
                this.vy = 0;
                this.gravity = 0.6;
                
                const enemyStats = {
                    'basic': { health: 35, speed: 2, color: '#808080', damage: 8 },
                    'advanced': { health: 40, speed: 2.5, color: '#8b4513', damage: 10 },
                    'heavy': { health: 70, speed: 1, color: '#4a4a4a', damage: 12 },
                    'assassin': { health: 25, speed: 4, color: '#1a1a1a', damage: 6 },
                    'mage': { health: 25, speed: 1.5, color: '#4b0082', damage: 6 }
                };
                
                const stats = enemyStats[type] || enemyStats['basic'];
                this.health = stats.health;
                this.maxHealth = stats.health;
                this.speed = stats.speed;
                this.color = stats.color;
                this.baseDamage = stats.damage;
                this.type = type;
                this.facing = -1;
                this.onGround = false;
                
                this.attackCooldown = 0;
                this.shootCooldown = 0;
                this.teleportCooldown = 0;
                this.state = 'idle';
                this.stateTimer = 0;
                this.frozen = false;
                
                this.animFrame = 0;
                this.animCounter = 0;
            }

            update() {
                // Pause during upgrade selection
                if (showingUpgrade) return;
                
                if (this.frozen) {
                    this.vy += this.gravity;
                    this.y += this.vy;
                    if (this.y > canvas.height - 50 - this.height / 2) {
                        this.y = canvas.height - 50 - this.height / 2;
                        this.vy = 0;
                    }
                    return;
                }
                
                this.vy += this.gravity;
                this.x += this.vx;
                this.y += this.vy;
                
                // Platform collision
                this.onGround = false;
                for (const platform of currentRoom.platforms) {
                    if (this.x + this.width / 2 > platform.x &&
                        this.x - this.width / 2 < platform.x + platform.width &&
                        this.y + this.height / 2 > platform.y &&
                        this.y + this.height / 2 < platform.y + 20 &&
                        this.vy >= 0) {
                        this.y = platform.y - this.height / 2;
                        this.vy = 0;
                        this.onGround = true;
                    }
                }
                
                if (this.y > canvas.height - 50 - this.height / 2) {
                    this.y = canvas.height - 50 - this.height / 2;
                    this.vy = 0;
                    this.onGround = true;
                }
                
                // AI
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                this.facing = dx > 0 ? 1 : -1;
                
                if (this.attackCooldown > 0) this.attackCooldown--;
                if (this.shootCooldown > 0) this.shootCooldown--;
                if (this.teleportCooldown > 0) this.teleportCooldown--;
                
                switch(this.type) {
                    case 'basic':
                    case 'heavy':
                        // Melee enemies
                        if (dist > 50) {
                            this.vx = this.facing * this.speed;
                        } else {
                            this.vx = 0;
                            if (this.attackCooldown <= 0) {
                                this.attackCooldown = 60;
                                player.takeDamage(this.baseDamage);
                            }
                        }
                        break;
                        
                    case 'advanced':
                        // Archer - keep distance and shoot
                        if (dist < 100) {
                            this.vx = -this.facing * this.speed;
                        } else if (dist > 300) {
                            this.vx = this.facing * this.speed;
                        } else {
                            this.vx *= 0.9;
                        }
                        
                        if (this.shootCooldown <= 0 && dist < 400) {
                            this.shootCooldown = 90;
                            const angle = Math.atan2(dy, dx);
                            projectiles.push(new Projectile(this.x, this.y, angle, 8, 'enemy'));
                        }
                        break;
                        
                    case 'assassin':
                        // Fast melee
                        if (dist > 40) {
                            this.vx = this.facing * this.speed;
                        } else {
                            this.vx = 0;
                            if (this.attackCooldown <= 0) {
                                this.attackCooldown = 45;
                                player.takeDamage(this.baseDamage);
                            }
                        }
                        break;
                        
                    case 'mage':
                        // Teleporting ranged
                        if (dist > 150 && dist < 350) {
                            this.vx *= 0.95;
                            
                            if (this.shootCooldown <= 0) {
                                this.shootCooldown = 100;
                                const angle = Math.atan2(dy, dx);
                                for (let i = -1; i <= 1; i++) {
                                    projectiles.push(new Projectile(
                                        this.x,
                                        this.y,
                                        angle + i * 0.2,
                                        8,
                                        'enemy'
                                    ));
                                }
                            }
                        } else if (dist < 150 && this.teleportCooldown <= 0) {
                            this.teleportCooldown = 200;
                            const teleAngle = Math.random() * Math.PI * 2;
                            let newX = this.x + Math.cos(teleAngle) * 150;
                            let newY = this.y + Math.sin(teleAngle) * 100;
                            
                            newX = Math.max(50, Math.min(canvas.width - 50, newX));
                            newY = Math.max(100, Math.min(canvas.height - 100, newY));
                            
                            this.x = newX;
                            this.y = newY;
                            
                            for (let i = 0; i < 20; i++) {
                                particles.push(new Particle(
                                    this.x, this.y, '#4b0082',
                                    (Math.random() - 0.5) * 10,
                                    (Math.random() - 0.5) * 10,
                                    30
                                ));
                            }
                        } else if (dist > 400) {
                            this.vx = this.facing * this.speed * 0.7;
                        } else {
                            this.vx *= 0.9;
                        }
                        break;
                }
                
                // Animation
                this.animCounter++;
                if (this.animCounter > 10) {
                    this.animFrame = (this.animFrame + 1) % 3;
                    this.animCounter = 0;
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.facing, 1);
                
                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.ellipse(0, this.height / 2 + 5, this.width / 2, 5, 0, 0, Math.PI * 2);
                ctx.fill();
                
                switch(this.type) {
                    case 'basic':
                        // Sword Knight
                        ctx.fillStyle = '#808080';
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        ctx.fillStyle = '#a0a0a0';
                        ctx.fillRect(-this.width / 2 + 4, -this.height / 2 + 4, this.width - 8, this.height / 2);
                        
                        ctx.fillStyle = '#696969';
                        ctx.beginPath();
                        ctx.arc(0, -this.height / 2 + 6, 10, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = '#000000';
                        ctx.fillRect(-6, -this.height / 2 + 4, 12, 3);
                        
                        // Shield
                        ctx.fillStyle = '#8b0000';
                        ctx.beginPath();
                        ctx.arc(-8, 0, 8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#ffd700';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        // Sword
                        ctx.strokeStyle = '#c0c0c0';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(8, -4);
                        ctx.lineTo(8, -16);
                        ctx.stroke();
                        
                        ctx.fillStyle = '#8b4513';
                        ctx.fillRect(6, -6, 4, 6);
                        break;
                        
                    case 'advanced':
                        // Archer Knight
                        ctx.fillStyle = '#8b4513';
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        ctx.fillStyle = '#654321';
                        ctx.fillRect(-this.width / 2 + 4, -this.height / 2 + 8, this.width - 8, this.height - 12);
                        
                        ctx.fillStyle = '#a0a0a0';
                        ctx.beginPath();
                        ctx.arc(0, -this.height / 2 + 6, 9, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = '#ffe0bd';
                        ctx.fillRect(-4, -this.height / 2 + 4, 8, 6);
                        
                        ctx.fillStyle = '#000000';
                        ctx.fillRect(-3, -this.height / 2 + 5, 2, 2);
                        ctx.fillRect(1, -this.height / 2 + 5, 2, 2);
                        
                        // Bow
                        ctx.strokeStyle = '#8b4513';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(10, 0, 12, -Math.PI/3, Math.PI/3);
                        ctx.stroke();
                        
                        ctx.strokeStyle = '#d3d3d3';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(10 + Math.cos(-Math.PI/3) * 12, Math.sin(-Math.PI/3) * 12);
                        ctx.lineTo(10 + Math.cos(Math.PI/3) * 12, Math.sin(Math.PI/3) * 12);
                        ctx.stroke();
                        
                        ctx.fillStyle = '#654321';
                        ctx.fillRect(-10, this.height / 4, 4, 8);
                        break;
                        
                    case 'heavy':
                        // Tank
                        ctx.fillStyle = '#4a4a4a';
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        ctx.fillStyle = '#5a5a5a';
                        ctx.fillRect(-this.width / 2 + 2, -this.height / 2 + 2, this.width - 4, 8);
                        ctx.fillRect(-this.width / 2 + 2, 0, this.width - 4, 6);
                        
                        ctx.fillStyle = '#3a3a3a';
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, 10);
                        
                        // Spikes
                        ctx.fillStyle = '#8b4513';
                        for (let i = -1; i <= 1; i++) {
                            ctx.beginPath();
                            ctx.moveTo(i * 8, -this.height / 2);
                            ctx.lineTo(i * 8 - 3, -this.height / 2 - 6);
                            ctx.lineTo(i * 8 + 3, -this.height / 2 - 6);
                            ctx.fill();
                        }
                        
                        ctx.fillStyle = '#ff0000';
                        ctx.fillRect(-8, -this.height / 2 + 12, 16, 3);
                        
                        // Hammer
                        ctx.fillStyle = '#696969';
                        ctx.fillRect(8, -8, 4, 16);
                        ctx.fillRect(6, -12, 8, 8);
                        break;
                        
                    case 'assassin':
                        // Fast assassin
                        ctx.fillStyle = '#1a1a1a';
                        ctx.fillRect(-this.width / 2 + 4, -this.height / 2, this.width - 8, this.height);
                        
                        ctx.fillStyle = '#0a0a0a';
                        ctx.beginPath();
                        ctx.arc(0, -this.height / 2 + 4, 8, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = '#ff0000';
                        ctx.fillRect(-3, -this.height / 2 + 6, 2, 2);
                        ctx.fillRect(1, -this.height / 2 + 6, 2, 2);
                        
                        // Daggers
                        ctx.fillStyle = '#c0c0c0';
                        ctx.fillRect(8, -2, 8, 2);
                        ctx.fillRect(8, 2, 8, 2);
                        break;
                        
                    case 'mage':
                        // Mage
                        ctx.fillStyle = '#4b0082';
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        ctx.fillStyle = '#6a0dad';
                        ctx.fillRect(-this.width / 2 + 4, -this.height / 2 + 8, this.width - 8, this.height - 12);
                        
                        ctx.fillStyle = '#3a2a5a';
                        ctx.beginPath();
                        ctx.arc(0, -this.height / 2 + 4, 10, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Hat
                        ctx.fillStyle = '#2a1a4a';
                        ctx.beginPath();
                        ctx.moveTo(0, -this.height / 2 - 8);
                        ctx.lineTo(-8, -this.height / 2 + 4);
                        ctx.lineTo(8, -this.height / 2 + 4);
                        ctx.fill();
                        
                        // Staff
                        ctx.strokeStyle = '#8b4513';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(10, 0);
                        ctx.lineTo(10, -18);
                        ctx.stroke();
                        
                        ctx.fillStyle = '#9400d3';
                        ctx.beginPath();
                        ctx.arc(10, -20, 4, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                }
                
                ctx.restore();
                
                // Health bar
                const barWidth = this.width + 10;
                const barHeight = 4;
                const barY = this.y - this.height / 2 - 10;
                
                ctx.fillStyle = '#222';
                ctx.fillRect(this.x - barWidth / 2, barY, barWidth, barHeight);
                
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(this.x - barWidth / 2, barY, barWidth * (this.health / this.maxHealth), barHeight);
            }

            takeDamage(amount) {
                const baseDamage = player.attackDamage * (1 + player.upgrades.damage * 0.15);
                const damageMultiplier = player.damageMultiplier * (mythicMode ? 5 : 1);
                let finalDamage = amount * damageMultiplier;
                
                // Critical hit
                const critChance = 0.1 + (player.upgrades.critChance * 0.05);
                if (Math.random() < critChance) {
                    const critDamage = 2 + (player.upgrades.critDamage * 0.3);
                    finalDamage *= critDamage;
                    
                    // Critical Mass
                    if (player.upgrades.criticalMass > 0) {
                        for (let i = 0; i < 8; i++) {
                            const angle = (Math.PI * 2 / 8) * i;
                            projectiles.push(new Projectile(
                                this.x,
                                this.y,
                                angle,
                                6,
                                'player'
                            ));
                        }
                    }
                }
                
                // Death Mark bonus
                if (player.markedEnemies.has(this)) {
                    finalDamage *= 1.5;
                }
                
                // Berserker Rage bonus
                if (player.upgrades.berserkerRage > 0 && player.health < player.maxHealth * 0.3) {
                    finalDamage *= (1 + player.upgrades.berserkerRage * 0.15);
                }
                
                this.health -= finalDamage;
                this.health = Math.max(0, this.health);
                
                // Lifesteal
                if (player.upgrades.lifesteal > 0) {
                    player.health = Math.min(player.maxHealth, player.health + player.upgrades.lifesteal);
                }
                
                // Soul Harvest on kill
                if (this.health <= 0 && player.upgrades.soulHarvest > 0) {
                    player.health = Math.min(player.maxHealth, player.health + player.upgrades.soulHarvest * 3);
                }
                
                // Status effects
                if (player.upgrades.poisonDagger > 0) {
                    player.poisonedEnemies.add(this);
                }
                if (player.upgrades.frozenTouch > 0) {
                    player.frozenEnemies.add(this);
                    this.speed *= 0.5;
                }
                if (player.upgrades.deathMark > 0 && Math.random() < 0.3) {
                    player.markedEnemies.add(this);
                }
                
                // Damage particles
                for (let i = 0; i < 15; i++) {
                    particles.push(new Particle(
                        this.x,
                        this.y,
                        '#ff0000',
                        (Math.random() - 0.5) * 6,
                        (Math.random() - 0.5) * 6,
                        25
                    ));
                }
            }
        }

        // Boss class with UNIQUE ATTACK PATTERNS
        class Boss {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.width = 50;
                this.height = 60;
                this.vx = 0;
                this.vy = 0;
                this.gravity = 0.6;
                this.type = type;
                this.facing = -1;
                this.onGround = false;
                
                const bossStats = {
                    'Crimson Knight': { health: 250, speed: 1.5, color: '#8b0000', damage: 10 },
                    'Shadow Lord': { health: 200, speed: 2, color: '#2a2a2a', damage: 8 },
                    'Frost Warden': { health: 220, speed: 1.2, color: '#00bfff', damage: 9 },
                    'Flame Tyrant': { health: 210, speed: 1.8, color: '#ff4500', damage: 10 },
                    'Stone Golem': { health: 300, speed: 0.8, color: '#696969', damage: 12 },
                    'Toxic Assassin': { health: 180, speed: 2.5, color: '#228b22', damage: 8 },
                    'Thunder King': { health: 240, speed: 1.5, color: '#ffd700', damage: 10 },
                    'Necromancer': { health: 190, speed: 1.3, color: '#4b0082', damage: 9 },
                    'Blood Reaper': { health: 230, speed: 1.7, color: '#dc143c', damage: 10 },
                    'Void Walker': { health: 220, speed: 2, color: '#483d8b', damage: 9 }
                };
                
                const stats = bossStats[type];
                this.health = stats.health;
                this.maxHealth = stats.health;
                this.speed = stats.speed;
                this.color = stats.color;
                this.baseDamage = stats.damage;
                
                this.attackCooldown = 0;
                this.specialCooldown = 0;
                this.phase = 1;
                this.animFrame = 0;
                this.isBoss = true;
                this.frozen = false;
                
                // NEW: Attack pattern variables
                this.patternPhase = 0;
                this.patternTimer = 0;
                this.attackPattern = 0;
            }

            update() {
                // Pause during upgrade selection
                if (showingUpgrade) return;
                
                if (this.frozen) {
                    this.vy += this.gravity;
                    this.y += this.vy;
                    if (this.y > canvas.height - 50 - this.height / 2) {
                        this.y = canvas.height - 50 - this.height / 2;
                        this.vy = 0;
                    }
                    return;
                }
                
                this.vy += this.gravity;
                this.x += this.vx;
                this.y += this.vy;
                
                // Platform collision
                this.onGround = false;
                for (const platform of currentRoom.platforms) {
                    if (this.x + this.width / 2 > platform.x &&
                        this.x - this.width / 2 < platform.x + platform.width &&
                        this.y + this.height / 2 > platform.y &&
                        this.y + this.height / 2 < platform.y + 20 &&
                        this.vy >= 0) {
                        this.y = platform.y - this.height / 2;
                        this.vy = 0;
                        this.onGround = true;
                    }
                }
                
                if (this.y > canvas.height - 50 - this.height / 2) {
                    this.y = canvas.height - 50 - this.height / 2;
                    this.vy = 0;
                    this.onGround = true;
                }
                
                // Phase transition at 50% HP
                if (this.health < this.maxHealth / 2 && this.phase === 1) {
                    this.phase = 2;
                    this.speed *= 1.15; // Reduced from 1.4
                    this.baseDamage *= 1.1; // Reduced from 1.2
                    
                    for (let i = 0; i < 80; i++) {
                        particles.push(new Particle(
                            this.x, this.y, this.color,
                            (Math.random() - 0.5) * 20,
                            (Math.random() - 0.5) * 20,
                            50
                        ));
                    }
                }
                
                // AI with UNIQUE ATTACK PATTERNS
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                this.facing = dx > 0 ? 1 : -1;
                
                if (this.attackCooldown > 0) this.attackCooldown--;
                if (this.specialCooldown > 0) this.specialCooldown--;
                
                this.patternTimer++;
                if (this.patternTimer > 300) {
                    this.patternTimer = 0;
                    this.attackPattern = (this.attackPattern + 1) % 3;
                }
                
                // Boss-specific attack patterns
                this.executeAttackPattern(dx, dy, dist);
                
                this.animFrame++;
            }
            
            executeAttackPattern(dx, dy, dist) {
                switch(this.type) {
                    case 'Crimson Knight':
                        // Keep distance, use sword attacks
                        if (dist > 120) {
                            this.vx = this.facing * this.speed * 0.6;
                        } else {
                            this.vx *= 0.8;
                        }
                        
                        if (this.attackPattern === 0) {
                            // Sword slash wave - telegraphed
                            if (this.patternTimer % 100 === 0) {
                                // Visual telegraph
                                for (let i = 0; i < 20; i++) {
                                    particles.push(new Particle(
                                        this.x + this.facing * 30, this.y,
                                        '#ffd700',
                                        this.facing * (Math.random() * 2 + 2),
                                        (Math.random() - 0.5) * 4,
                                        30
                                    ));
                                }
                                // Actual attack after delay
                                setTimeout(() => {
                                    for (let i = -1; i <= 1; i++) {
                                        const angle = (this.facing > 0 ? 0 : Math.PI) + i * 0.3;
                                        projectiles.push(new Projectile(this.x, this.y, angle, 7, 'enemy'));
                                    }
                                }, 400);
                            }
                        } else if (this.attackPattern === 1) {
                            // Shield spin - circular projectiles
                            if (this.patternTimer % 120 === 0) {
                                for (let i = 0; i < 8; i++) {
                                    setTimeout(() => {
                                        const angle = (Math.PI * 2 / 8) * i;
                                        projectiles.push(new Projectile(this.x, this.y, angle, 5, 'enemy'));
                                    }, i * 60);
                                }
                            }
                        } else {
                            // Ground pound shockwave
                            if (this.onGround && this.patternTimer % 140 === 0) {
                                // Jump warning
                                this.vy = -8;
                                setTimeout(() => {
                                    if (this.onGround) {
                                        // Shockwave on landing
                                        for (let i = 0; i < 30; i++) {
                                            particles.push(new Particle(
                                                this.x, this.y + this.height/2,
                                                '#8b4513',
                                                (Math.random() - 0.5) * 10,
                                                -Math.random() * 5,
                                                40
                                            ));
                                        }
                                        projectiles.push(new Projectile(this.x, this.y, 0, 6, 'enemy'));
                                        projectiles.push(new Projectile(this.x, this.y, Math.PI, 6, 'enemy'));
                                    }
                                }, 800);
                            }
                        }
                        break;
                        
                    case 'Shadow Lord':
                        // Stay at medium range, teleport around
                        if (dist < 150 || dist > 300) {
                            this.vx *= 0.9;
                        } else {
                            this.vx = this.facing * this.speed * 0.5;
                        }
                        
                        if (this.attackPattern === 0) {
                            // Shadow clone barrage
                            if (this.patternTimer % 150 === 0) {
                                // Create shadow clones that shoot
                                for (let i = 0; i < 3; i++) {
                                    setTimeout(() => {
                                        const cloneX = this.x + (Math.random() - 0.5) * 200;
                                        const cloneY = this.y - 100;
                                        
                                        // Clone particles
                                        for (let j = 0; j < 15; j++) {
                                            particles.push(new Particle(
                                                cloneX, cloneY, '#000000',
                                                (Math.random() - 0.5) * 6,
                                                (Math.random() - 0.5) * 6,
                                                40
                                            ));
                                        }
                                        
                                        // Clone shoots
                                        setTimeout(() => {
                                            const angle = Math.atan2(player.y - cloneY, player.x - cloneX);
                                            projectiles.push(new Projectile(cloneX, cloneY, angle, 7, 'enemy'));
                                        }, 500);
                                    }, i * 400);
                                }
                            }
                        } else if (this.attackPattern === 1) {
                            // Shadow dash (telegraphed)
                            if (this.patternTimer % 120 === 0) {
                                // Show dash direction
                                for (let i = 0; i < 20; i++) {
                                    particles.push(new Particle(
                                        this.x, this.y,
                                        '#ff0000',
                                        this.facing * i * 0.5,
                                        0,
                                        25
                                    ));
                                }
                                
                                // Dash after delay
                                setTimeout(() => {
                                    this.vx = this.facing * this.speed * 8;
                                    setTimeout(() => {
                                        this.vx *= 0.3;
                                    }, 200);
                                }, 600);
                            }
                        } else {
                            // Dark nova - expanding ring
                            if (this.patternTimer % 180 === 0) {
                                for (let wave = 1; wave <= 3; wave++) {
                                    setTimeout(() => {
                                        for (let i = 0; i < 12; i++) {
                                            const angle = (Math.PI * 2 / 12) * i;
                                            projectiles.push(new Projectile(this.x, this.y, angle, 4 + wave, 'enemy'));
                                        }
                                    }, wave * 400);
                                }
                            }
                        }
                        break;
                        
                    case 'Frost Warden':
                        // Slow and methodical, uses ice magic
                        this.vx *= 0.9; // Stay mostly still
                        
                        if (this.attackPattern === 0) {
                            // Ice spike line (telegraphed)
                            if (this.patternTimer % 110 === 0) {
                                const angle = Math.atan2(dy, dx);
                                
                                // Show ice forming
                                for (let i = 0; i < 10; i++) {
                                    setTimeout(() => {
                                        const distance = i * 40;
                                        particles.push(new Particle(
                                            this.x + Math.cos(angle) * distance,
                                            this.y + Math.sin(angle) * distance,
                                            '#00ffff',
                                            0, 0, 40
                                        ));
                                    }, i * 50);
                                }
                                
                                // Ice spike attack
                                setTimeout(() => {
                                    for (let i = 0; i < 5; i++) {
                                        projectiles.push(new Projectile(this.x, this.y, angle + (Math.random() - 0.5) * 0.2, 8, 'enemy'));
                                    }
                                }, 600);
                            }
                        } else if (this.attackPattern === 1) {
                            // Blizzard - random ice from above
                            if (this.patternTimer % 30 === 0 && this.patternTimer % 180 > 0) {
                                const x = Math.random() * canvas.width;
                                projectiles.push(new Projectile(x, 0, Math.PI / 2, 6, 'enemy'));
                            }
                        } else {
                            // Ice wall - horizontal wave
                            if (this.patternTimer % 140 === 0) {
                                setTimeout(() => {
                                    for (let i = -2; i <= 2; i++) {
                                        projectiles.push(new Projectile(
                                            this.x + i * 40,
                                            this.y - 50,
                                            Math.PI / 2,
                                            5,
                                            'enemy'
                                        ));
                                    }
                                }, 500);
                            }
                        }
                        break;
                        
                    case 'Flame Tyrant':
                        // Medium range, uses fire attacks
                        if (dist > 180) {
                            this.vx = this.facing * this.speed * 0.7;
                        } else {
                            this.vx *= 0.85;
                        }
                        
                        if (this.attackPattern === 0) {
                            // Fireball volley
                            if (this.patternTimer % 90 === 0) {
                                for (let i = 0; i < 3; i++) {
                                    setTimeout(() => {
                                        const angle = Math.atan2(dy, dx) + (Math.random() - 0.5) * 0.4;
                                        projectiles.push(new Projectile(this.x, this.y, angle, 7, 'enemy'));
                                    }, i * 200);
                                }
                            }
                        } else if (this.attackPattern === 1) {
                            // Flame pillar (telegraphed)
                            if (this.patternTimer % 120 === 0) {
                                const targetX = player.x;
                                
                                // Show target zone
                                for (let i = 0; i < 30; i++) {
                                    particles.push(new Particle(
                                        targetX + (Math.random() - 0.5) * 50,
                                        canvas.height - 50,
                                        '#ff8c00',
                                        0, -Math.random() * 3,
                                        50
                                    ));
                                }
                                
                                // Flame eruption
                                setTimeout(() => {
                                    for (let i = 0; i < 8; i++) {
                                        projectiles.push(new Projectile(
                                            targetX + (Math.random() - 0.5) * 60,
                                            canvas.height - 50,
                                            -Math.PI / 2 + (Math.random() - 0.5) * 0.5,
                                            8 + Math.random() * 3,
                                            'enemy'
                                        ));
                                    }
                                }, 800);
                            }
                        } else {
                            // Fire ring
                            if (this.patternTimer % 100 === 0) {
                                for (let i = 0; i < 10; i++) {
                                    const angle = (Math.PI * 2 / 10) * i;
                                    projectiles.push(new Projectile(this.x, this.y, angle, 5, 'enemy'));
                                }
                            }
                        }
                        break;
                        
                    case 'Stone Golem':
                        // Very slow, powerful but telegraphed attacks
                        if (dist > 100) {
                            this.vx = this.facing * this.speed * 0.8;
                        } else {
                            this.vx *= 0.7;
                        }
                        
                        if (this.attackPattern === 0) {
                            // Boulder toss (highly telegraphed)
                            if (this.patternTimer % 150 === 0) {
                                // Windup
                                for (let i = 0; i < 40; i++) {
                                    particles.push(new Particle(
                                        this.x, this.y - 20,
                                        '#8b4513',
                                        (Math.random() - 0.5) * 3,
                                        -Math.random() * 5,
                                        50
                                    ));
                                }
                                
                                // Throw boulder
                                setTimeout(() => {
                                    const angle = Math.atan2(dy, dx);
                                    for (let i = 0; i < 5; i++) {
                                        setTimeout(() => {
                                            projectiles.push(new Projectile(this.x, this.y, angle, 6, 'enemy'));
                                        }, i * 100);
                                    }
                                }, 1000);
                            }
                        } else if (this.attackPattern === 1) {
                            // Ground slam - shockwave
                            if (this.onGround && this.patternTimer % 160 === 0) {
                                this.vy = -10;
                                
                                setTimeout(() => {
                                    if (this.onGround) {
                                        // Massive shockwave
                                        for (let i = 0; i < 50; i++) {
                                            particles.push(new Particle(
                                                this.x + (Math.random() - 0.5) * 100,
                                                this.y + this.height/2,
                                                '#696969',
                                                (Math.random() - 0.5) * 15,
                                                -Math.random() * 8,
                                                60
                                            ));
                                        }
                                        
                                        for (let i = 0; i < 6; i++) {
                                            const angle = i * (Math.PI / 3);
                                            projectiles.push(new Projectile(this.x, this.y, angle, 5, 'enemy'));
                                        }
                                    }
                                }, 1200);
                            }
                        } else {
                            // Rock spray
                            if (this.patternTimer % 100 === 0) {
                                for (let i = -2; i <= 2; i++) {
                                    const angle = (this.facing > 0 ? 0 : Math.PI) + i * 0.25;
                                    projectiles.push(new Projectile(this.x, this.y, angle, 6, 'enemy'));
                                }
                            }
                        }
                        break;
                        
                    case 'Toxic Assassin':
                        // Fast hit and run, poison attacks
                        if (dist > 200) {
                            this.vx = this.facing * this.speed;
                        } else if (dist < 100) {
                            this.vx = -this.facing * this.speed;
                        } else {
                            this.vx *= 0.9;
                        }
                        
                        if (this.attackPattern === 0) {
                            // Poison dart spray
                            if (this.patternTimer % 80 === 0) {
                                const angle = Math.atan2(dy, dx);
                                for (let i = -1; i <= 1; i++) {
                                    projectiles.push(new Projectile(this.x, this.y, angle + i * 0.3, 9, 'enemy'));
                                }
                            }
                        } else if (this.attackPattern === 1) {
                            // Poison cloud (area denial)
                            if (this.patternTimer % 130 === 0) {
                                const cloudX = player.x;
                                const cloudY = player.y;
                                
                                // Create poison cloud
                                for (let i = 0; i < 80; i++) {
                                    setTimeout(() => {
                                        particles.push(new Particle(
                                            cloudX + (Math.random() - 0.5) * 100,
                                            cloudY + (Math.random() - 0.5) * 100,
                                            '#00ff00',
                                            (Math.random() - 0.5) * 2,
                                            (Math.random() - 0.5) * 2,
                                            80
                                        ));
                                    }, i * 10);
                                }
                            }
                        } else {
                            // Blink strike
                            if (this.patternTimer % 110 === 0 && dist < 250) {
                                const oldX = this.x;
                                this.x = player.x + this.facing * 60;
                                
                                for (let i = 0; i < 20; i++) {
                                    particles.push(new Particle(
                                        oldX, this.y, '#228b22',
                                        (Math.random() - 0.5) * 8,
                                        (Math.random() - 0.5) * 8,
                                        30
                                    ));
                                }
                            }
                        }
                        break;
                        
                    case 'Thunder King':
                        // Mid range, lightning attacks
                        if (dist > 160) {
                            this.vx = this.facing * this.speed * 0.6;
                        } else {
                            this.vx *= 0.85;
                        }
                        
                        if (this.attackPattern === 0) {
                            // Lightning bolt (targeted)
                            if (this.patternTimer % 100 === 0) {
                                const targetX = player.x;
                                
                                // Warning flash
                                for (let i = 0; i < 20; i++) {
                                    particles.push(new Particle(
                                        targetX, 0,
                                        '#ffff00',
                                        (Math.random() - 0.5) * 4,
                                        Math.random() * 5,
                                        40
                                    ));
                                }
                                
                                // Lightning strike
                                setTimeout(() => {
                                    for (let i = 0; i < 3; i++) {
                                        projectiles.push(new Projectile(
                                            targetX + (Math.random() - 0.5) * 40,
                                            0,
                                            Math.PI / 2,
                                            12,
                                            'enemy'
                                        ));
                                    }
                                }, 600);
                            }
                        } else if (this.attackPattern === 1) {
                            // Electric orb
                            if (this.patternTimer % 90 === 0) {
                                const angle = Math.atan2(dy, dx);
                                projectiles.push(new Projectile(this.x, this.y, angle, 6, 'enemy'));
                            }
                        } else {
                            // Chain lightning
                            if (this.patternTimer % 120 === 0) {
                                for (let i = 0; i < 8; i++) {
                                    setTimeout(() => {
                                        const randomAngle = Math.random() * Math.PI * 2;
                                        projectiles.push(new Projectile(this.x, this.y, randomAngle, 7, 'enemy'));
                                    }, i * 80);
                                }
                            }
                        }
                        break;
                        
                    case 'Necromancer':
                        // Stay back, summon attacks
                        if (dist < 250) {
                            this.vx = -this.facing * this.speed;
                        } else {
                            this.vx *= 0.9;
                        }
                        
                        if (this.attackPattern === 0) {
                            // Soul missiles
                            if (this.patternTimer % 70 === 0) {
                                const angle = Math.atan2(dy, dx);
                                projectiles.push(new Projectile(this.x, this.y, angle, 5, 'enemy'));
                            }
                        } else if (this.attackPattern === 1) {
                            // Curse circle (telegraphed danger zone)
                            if (this.patternTimer % 140 === 0) {
                                const curseX = player.x;
                                const curseY = player.y;
                                
                                // Show curse forming
                                for (let i = 0; i < 60; i++) {
                                    setTimeout(() => {
                                        const angle = (Math.PI * 2 / 20) * (i % 20);
                                        particles.push(new Particle(
                                            curseX + Math.cos(angle) * 60,
                                            curseY + Math.sin(angle) * 60,
                                            '#8b008b',
                                            0, 0, 60
                                        ));
                                    }, i * 20);
                                }
                                
                                // Curse activates
                                setTimeout(() => {
                                    for (let i = 0; i < 12; i++) {
                                        const angle = (Math.PI * 2 / 12) * i;
                                        projectiles.push(new Projectile(
                                            curseX + Math.cos(angle) * 60,
                                            curseY + Math.sin(angle) * 60,
                                            angle + Math.PI,
                                            4,
                                            'enemy'
                                        ));
                                    }
                                }, 1200);
                            }
                        } else {
                            // Skull barrage
                            if (this.patternTimer % 100 === 0) {
                                for (let i = 0; i < 4; i++) {
                                    setTimeout(() => {
                                        const angle = Math.atan2(dy, dx) + (Math.random() - 0.5) * 0.6;
                                        projectiles.push(new Projectile(this.x, this.y, angle, 6, 'enemy'));
                                    }, i * 150);
                                }
                            }
                        }
                        break;
                        
                    case 'Blood Reaper':
                        // Aggressive but predictable
                        if (dist > 140) {
                            this.vx = this.facing * this.speed * 0.8;
                        } else {
                            this.vx *= 0.9;
                        }
                        
                        if (this.attackPattern === 0) {
                            // Blood scythe swing (arc of projectiles)
                            if (this.patternTimer % 90 === 0) {
                                for (let i = -3; i <= 3; i++) {
                                    const angle = (this.facing > 0 ? 0 : Math.PI) + i * 0.2;
                                    projectiles.push(new Projectile(this.x, this.y, angle, 7, 'enemy'));
                                }
                            }
                        } else if (this.attackPattern === 1) {
                            // Blood rain
                            if (this.patternTimer % 40 === 0 && this.patternTimer % 160 > 0) {
                                const x = player.x + (Math.random() - 0.5) * 150;
                                projectiles.push(new Projectile(x, 0, Math.PI / 2, 8, 'enemy'));
                            }
                        } else {
                            // Reaper dash (telegraphed)
                            if (this.patternTimer % 130 === 0) {
                                // Show intent
                                for (let i = 0; i < 15; i++) {
                                    particles.push(new Particle(
                                        this.x, this.y,
                                        '#dc143c',
                                        this.facing * (i + 5),
                                        (Math.random() - 0.5) * 3,
                                        35
                                    ));
                                }
                                
                                // Dash attack
                                setTimeout(() => {
                                    this.vx = this.facing * this.speed * 10;
                                    setTimeout(() => this.vx *= 0.2, 250);
                                }, 500);
                            }
                        }
                        break;
                        
                    case 'Void Walker':
                        // Unpredictable teleporting
                        if (this.patternTimer % 60 === 0) {
                            this.vx *= 0.5; // Slow down
                        }
                        
                        if (this.attackPattern === 0) {
                            // Void rift - creates portals that shoot
                            if (this.patternTimer % 120 === 0) {
                                for (let i = 0; i < 2; i++) {
                                    const riftX = Math.random() * (canvas.width - 100) + 50;
                                    const riftY = Math.random() * (canvas.height - 200) + 100;
                                    
                                    // Portal particles
                                    for (let j = 0; j < 30; j++) {
                                        particles.push(new Particle(
                                            riftX, riftY, '#9370db',
                                            (Math.random() - 0.5) * 4,
                                            (Math.random() - 0.5) * 4,
                                            60
                                        ));
                                    }
                                    
                                    // Portal shoots
                                    setTimeout(() => {
                                        const angle = Math.atan2(player.y - riftY, player.x - riftX);
                                        projectiles.push(new Projectile(riftX, riftY, angle, 7, 'enemy'));
                                    }, 700);
                                }
                            }
                        } else if (this.attackPattern === 1) {
                            // Void beam (sweeping)
                            if (this.patternTimer % 150 === 0) {
                                const startAngle = Math.atan2(dy, dx);
                                for (let i = 0; i < 7; i++) {
                                    setTimeout(() => {
                                        const angle = startAngle + (i - 3) * 0.15;
                                        projectiles.push(new Projectile(this.x, this.y, angle, 8, 'enemy'));
                                    }, i * 100);
                                }
                            }
                        } else {
                            // Void collapse (pulls toward center then explodes)
                            if (this.patternTimer % 180 === 0) {
                                setTimeout(() => {
                                    for (let i = 0; i < 16; i++) {
                                        const angle = (Math.PI * 2 / 16) * i;
                                        projectiles.push(new Projectile(this.x, this.y, angle, 6, 'enemy'));
                                    }
                                }, 800);
                            }
                        }
                        
                        // Random teleport
                        if (this.patternTimer % 80 === 0 && Math.random() < 0.4) {
                            const angle = Math.random() * Math.PI * 2;
                            this.x = player.x + Math.cos(angle) * 200;
                            this.y = Math.max(150, Math.min(canvas.height - 150, player.y + Math.sin(angle) * 150));
                            
                            for (let i = 0; i < 25; i++) {
                                particles.push(new Particle(
                                    this.x, this.y, '#483d8b',
                                    (Math.random() - 0.5) * 8,
                                    (Math.random() - 0.5) * 8,
                                    40
                                ));
                            }
                        }
                        break;
                }
            }

            draw() {
                // Boss aura/glow effect
                const pulseIntensity = 0.7 + Math.sin(Date.now() / 300) * 0.3;
                ctx.globalAlpha = 0.2 * pulseIntensity;
                const auraGradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.width * 2);
                auraGradient.addColorStop(0, this.color);
                auraGradient.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = auraGradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.width * 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.facing, 1);
                
                const wobble = Math.sin(this.animFrame / 10) * 2;
                
                // Detailed boss designs with textures
                switch(this.type) {
                    case 'Crimson Knight':
                        // Armor body with metallic texture
                        const armorGrad = ctx.createLinearGradient(-this.width/2, 0, this.width/2, 0);
                        armorGrad.addColorStop(0, '#8b0000');
                        armorGrad.addColorStop(0.5, '#b22222');
                        armorGrad.addColorStop(1, '#8b0000');
                        ctx.fillStyle = armorGrad;
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        // Armor plates
                        ctx.strokeStyle = '#4a0000';
                        ctx.lineWidth = 2;
                        for (let i = 0; i < 5; i++) {
                            ctx.strokeRect(-this.width/2 + 2, -this.height/2 + i * 12, this.width - 4, 10);
                        }
                        
                        // Golden trim
                        ctx.fillStyle = '#ffd700';
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, 6);
                        ctx.fillRect(-this.width / 2, this.height / 2 - 6, this.width, 6);
                        ctx.fillRect(-this.width / 2, -this.height / 4, this.width, 3);
                        
                        // Detailed crown
                        ctx.fillStyle = '#ffd700';
                        ctx.fillRect(-this.width/2, -this.height/2 - 12, this.width, 4);
                        for (let i = -2; i <= 2; i++) {
                            const crownX = i * 10;
                            ctx.fillRect(crownX - 3, -this.height / 2 - 12, 6, 16);
                            ctx.fillStyle = '#ff0000';
                            ctx.beginPath();
                            ctx.arc(crownX, -this.height/2 - 14, 3, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.fillStyle = '#ffd700';
                        }
                        
                        // Massive sword
                        ctx.fillStyle = '#696969';
                        ctx.fillRect(this.width / 2 - 2, -this.height / 2 - 10, 12, this.height + 20);
                        // Blade shine
                        ctx.fillStyle = '#c0c0c0';
                        ctx.fillRect(this.width / 2 + 2, -this.height / 2 - 10, 4, this.height + 20);
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(this.width / 2 + 4, -this.height / 2 - 10, 1, this.height + 20);
                        // Crossguard
                        ctx.fillStyle = '#ffd700';
                        ctx.fillRect(this.width / 2 - 10, -this.height / 2 + 10, 28, 8);
                        // Hilt
                        ctx.fillStyle = '#8b4513';
                        ctx.fillRect(this.width / 2 + 2, -this.height / 2, 4, 15);
                        
                        // Shield
                        ctx.fillStyle = '#696969';
                        ctx.beginPath();
                        ctx.arc(-this.width/2 - 10, 0, 18, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#ffd700';
                        ctx.beginPath();
                        ctx.moveTo(-this.width/2 - 10, -15);
                        ctx.lineTo(-this.width/2 - 5, -5);
                        ctx.lineTo(-this.width/2 - 10, 15);
                        ctx.lineTo(-this.width/2 - 15, -5);
                        ctx.closePath();
                        ctx.fill();
                        break;
                        
                    case 'Shadow Lord':
                        // Shadow trails
                        ctx.globalAlpha = 0.3;
                        ctx.fillStyle = '#000000';
                        for (let i = 0; i < 4; i++) {
                            const offset = i * 10;
                            ctx.fillRect(-this.width/2 - offset, -this.height/2, this.width, this.height);
                        }
                        ctx.globalAlpha = 1;
                        
                        // Dark cloak with texture
                        const cloakGrad = ctx.createLinearGradient(0, -this.height/2, 0, this.height/2);
                        cloakGrad.addColorStop(0, '#1a1a1a');
                        cloakGrad.addColorStop(0.5, '#2a2a2a');
                        cloakGrad.addColorStop(1, '#0a0a0a');
                        ctx.fillStyle = cloakGrad;
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        // Tattered cloak edges
                        ctx.fillStyle = '#000000';
                        for (let i = 0; i < 8; i++) {
                            const x = -this.width/2 + i * 7;
                            const length = 5 + Math.sin(Date.now()/100 + i) * 3;
                            ctx.fillRect(x, this.height/2, 5, length);
                        }
                        
                        // Glowing eyes
                        ctx.fillStyle = '#ff0000';
                        ctx.shadowColor = '#ff0000';
                        ctx.shadowBlur = 15;
                        ctx.globalAlpha = 0.9 + Math.sin(Date.now() / 200) * 0.1;
                        ctx.beginPath();
                        ctx.arc(-8, -this.height / 2 + 18, 6, 0, Math.PI * 2);
                        ctx.arc(8, -this.height / 2 + 18, 6, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                        ctx.globalAlpha = 1;
                        
                        // Shadow blades
                        ctx.fillStyle = '#4a4a4a';
                        for (let i = 0; i < 2; i++) {
                            const side = i === 0 ? -1 : 1;
                            const offset = side * (this.width/2 + 5);
                            ctx.save();
                            ctx.translate(offset, wobble);
                            ctx.rotate(side * Math.PI / 6);
                            ctx.fillRect(-3, -25, 6, 40);
                            ctx.fillStyle = '#6a6a6a';
                            ctx.fillRect(-1, -25, 2, 40);
                            ctx.restore();
                        }
                        break;
                        
                    case 'Frost Warden':
                        // Icy body
                        const iceBodyGrad = ctx.createLinearGradient(0, -this.height/2, 0, this.height/2);
                        iceBodyGrad.addColorStop(0, '#87ceeb');
                        iceBodyGrad.addColorStop(0.5, '#00bfff');
                        iceBodyGrad.addColorStop(1, '#4682b4');
                        ctx.fillStyle = iceBodyGrad;
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        // Ice crystal texture
                        ctx.strokeStyle = '#b0e0e6';
                        ctx.lineWidth = 1;
                        for (let i = 0; i < 6; i++) {
                            const x = -this.width/2 + Math.random() * this.width;
                            const y = -this.height/2 + Math.random() * this.height;
                            ctx.beginPath();
                            for (let j = 0; j < 6; j++) {
                                const angle = (Math.PI * 2 / 6) * j;
                                const px = x + Math.cos(angle) * 4;
                                const py = y + Math.sin(angle) * 4;
                                if (j === 0) ctx.moveTo(px, py);
                                else ctx.lineTo(px, py);
                            }
                            ctx.closePath();
                            ctx.stroke();
                        }
                        
                        // Ice crown with spikes
                        ctx.fillStyle = '#ffffff';
                        for (let i = 0; i < 7; i++) {
                            const x = (i - 3) * 8;
                            const height = 15 + (i % 2) * 5;
                            ctx.beginPath();
                            ctx.moveTo(x, -this.height / 2);
                            ctx.lineTo(x - 4, -this.height / 2 - height);
                            ctx.lineTo(x + 4, -this.height / 2 - height);
                            ctx.closePath();
                            ctx.fill();
                        }
                        
                        // Frost aura
                        ctx.globalAlpha = 0.4;
                        const frostAura = ctx.createRadialGradient(0, 0, 0, 0, 0, this.width);
                        frostAura.addColorStop(0, '#00ffff');
                        frostAura.addColorStop(1, 'rgba(0, 255, 255, 0)');
                        ctx.fillStyle = frostAura;
                        ctx.beginPath();
                        ctx.arc(0, 0, this.width * 1.2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                        
                        // Ice staff
                        ctx.fillStyle = '#87ceeb';
                        ctx.fillRect(-this.width/2 - 15, -this.height/2, 8, this.height + 15);
                        ctx.fillStyle = '#00ffff';
                        ctx.beginPath();
                        ctx.arc(-this.width/2 - 11, -this.height/2 - 10, 12, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        break;
                        
                    case 'Flame Tyrant':
                        // Molten armor
                        const lavaGrad = ctx.createLinearGradient(0, -this.height/2, 0, this.height/2);
                        lavaGrad.addColorStop(0, '#ff4500');
                        lavaGrad.addColorStop(0.5, '#ff6347');
                        lavaGrad.addColorStop(1, '#8b0000');
                        ctx.fillStyle = lavaGrad;
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        // Lava cracks
                        ctx.strokeStyle = '#ffff00';
                        ctx.lineWidth = 2;
                        for (let i = 0; i < 5; i++) {
                            const startY = -this.height/2 + i * 12;
                            ctx.beginPath();
                            ctx.moveTo(-this.width/2, startY);
                            ctx.lineTo(-this.width/2 + 10, startY + 6);
                            ctx.lineTo(-this.width/2 + 20, startY + 3);
                            ctx.lineTo(this.width/2, startY + 8);
                            ctx.stroke();
                        }
                        
                        // Flame crown/horns
                        ctx.fillStyle = '#ff0000';
                        for (let i = 0; i < 5; i++) {
                            const x = (i - 2) * 10;
                            const flameHeight = 15 + Math.sin(Date.now() / 100 + i) * 5;
                            ctx.beginPath();
                            ctx.moveTo(x, -this.height / 2);
                            ctx.lineTo(x - 6, -this.height / 2 - flameHeight);
                            ctx.lineTo(x, -this.height / 2 - flameHeight + 5);
                            ctx.lineTo(x + 6, -this.height / 2 - flameHeight);
                            ctx.closePath();
                            ctx.fill();
                        }
                        
                        // Demon horns
                        ctx.fillStyle = '#8b0000';
                        ctx.beginPath();
                        ctx.arc(-18, -this.height/2 + 8, 8, 0, Math.PI * 2);
                        ctx.arc(18, -this.height/2 + 8, 8, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Flame particles around boss
                        if (Math.random() < 0.3) {
                            particles.push(new Particle(
                                this.x + (Math.random() - 0.5) * this.width,
                                this.y + (Math.random() - 0.5) * this.height,
                                ['#ff4500', '#ff6347', '#ffff00'][Math.floor(Math.random() * 3)],
                                (Math.random() - 0.5) * 2,
                                -Math.random() * 3,
                                30
                            ));
                        }
                        break;
                        
                    case 'Stone Golem':
                        // Rocky body
                        ctx.fillStyle = '#696969';
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        // Stone blocks texture
                        ctx.strokeStyle = '#2f4f4f';
                        ctx.lineWidth = 3;
                        for (let y = 0; y < 4; y++) {
                            for (let x = 0; x < 2; x++) {
                                const bx = -this.width/2 + x * (this.width/2);
                                const by = -this.height/2 + y * (this.height/4);
                                ctx.strokeRect(bx, by, this.width/2, this.height/4);
                            }
                        }
                        
                        // Moss/cracks
                        ctx.fillStyle = '#228b22';
                        for (let i = 0; i < 8; i++) {
                            const x = -this.width/2 + Math.random() * this.width;
                            const y = -this.height/2 + Math.random() * this.height;
                            ctx.fillRect(x, y, 4, 6);
                        }
                        
                        // Glowing core
                        ctx.fillStyle = '#ff4500';
                        ctx.shadowColor = '#ff4500';
                        ctx.shadowBlur = 10;
                        ctx.beginPath();
                        ctx.arc(0, 0, 8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                        
                        // Massive fists
                        ctx.fillStyle = '#808080';
                        for (let i = 0; i < 2; i++) {
                            const side = i === 0 ? -1 : 1;
                            const fistX = side * (this.width/2 + 10);
                            ctx.fillRect(fistX - 8, 5 + wobble * side, 16, 20);
                            // Knuckles
                            ctx.fillStyle = '#696969';
                            for (let j = 0; j < 3; j++) {
                                ctx.fillRect(fistX - 6 + j * 4, 5 + wobble * side, 3, 8);
                            }
                            ctx.fillStyle = '#808080';
                        }
                        break;
                        
                    case 'Toxic Assassin':
                        // Toxic green body
                        const toxicGrad = ctx.createLinearGradient(0, -this.height/2, 0, this.height/2);
                        toxicGrad.addColorStop(0, '#32cd32');
                        toxicGrad.addColorStop(0.5, '#228b22');
                        toxicGrad.addColorStop(1, '#006400');
                        ctx.fillStyle = toxicGrad;
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        // Poison drips
                        ctx.fillStyle = '#00ff00';
                        ctx.globalAlpha = 0.7;
                        for (let i = 0; i < 6; i++) {
                            const x = -this.width/2 + i * 8;
                            const dripLength = 5 + Math.sin(Date.now()/150 + i) * 4;
                            ctx.fillRect(x, this.height/2, 4, dripLength);
                        }
                        ctx.globalAlpha = 1;
                        
                        // Mask/hood
                        ctx.fillStyle = '#0a0a0a';
                        ctx.fillRect(-this.width/2 + 5, -this.height/2, this.width - 10, 20);
                        
                        // Glowing toxic eyes
                        ctx.fillStyle = '#00ff00';
                        ctx.shadowColor = '#00ff00';
                        ctx.shadowBlur = 10;
                        ctx.beginPath();
                        ctx.arc(-8, -this.height/2 + 12, 4, 0, Math.PI * 2);
                        ctx.arc(8, -this.height/2 + 12, 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                        
                        // Poison daggers
                        for (let i = 0; i < 2; i++) {
                            const side = i === 0 ? -1 : 1;
                            ctx.fillStyle = '#c0c0c0';
                            ctx.save();
                            ctx.translate(side * (this.width/2 + 5), wobble * side);
                            ctx.rotate(side * -Math.PI / 4);
                            ctx.fillRect(-2, -15, 4, 25);
                            ctx.fillStyle = '#00ff00';
                            ctx.fillRect(-1, -15, 2, 10);
                            ctx.restore();
                        }
                        
                        // Toxic aura particles
                        if (Math.random() < 0.2) {
                            particles.push(new Particle(
                                this.x + (Math.random() - 0.5) * this.width * 1.5,
                                this.y + (Math.random() - 0.5) * this.height * 1.5,
                                '#00ff00',
                                (Math.random() - 0.5),
                                -Math.random() * 2,
                                40
                            ));
                        }
                        break;
                        
                    case 'Thunder King':
                        // Electric armor
                        const thunderGrad = ctx.createLinearGradient(0, -this.height/2, 0, this.height/2);
                        thunderGrad.addColorStop(0, '#ffd700');
                        thunderGrad.addColorStop(0.5, '#ffff00');
                        thunderGrad.addColorStop(1, '#daa520');
                        ctx.fillStyle = thunderGrad;
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        // Lightning bolts on armor
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 2;
                        ctx.shadowColor = '#ffff00';
                        ctx.shadowBlur = 5;
                        for (let i = 0; i < 3; i++) {
                            ctx.beginPath();
                            ctx.moveTo(-this.width/2 + i * 12, -this.height/2);
                            ctx.lineTo(-this.width/2 + i * 12 + 5, -this.height/2 + 15);
                            ctx.lineTo(-this.width/2 + i * 12 + 2, -this.height/2 + 20);
                            ctx.lineTo(-this.width/2 + i * 12 + 7, this.height/2);
                            ctx.stroke();
                        }
                        ctx.shadowBlur = 0;
                        
                        // Thunder crown
                        ctx.fillStyle = '#ffffff';
                        for (let i = -2; i <= 2; i++) {
                            ctx.beginPath();
                            ctx.moveTo(i * 8, -this.height/2);
                            ctx.lineTo(i * 8 - 4, -this.height/2 - 12);
                            ctx.lineTo(i * 8, -this.height/2 - 18);
                            ctx.lineTo(i * 8 + 4, -this.height/2 - 12);
                            ctx.closePath();
                            ctx.fill();
                        }
                        
                        // Electric orbs
                        ctx.fillStyle = '#ffffff';
                        ctx.shadowColor = '#ffff00';
                        ctx.shadowBlur = 15;
                        for (let i = 0; i < 2; i++) {
                            const side = i === 0 ? -1 : 1;
                            const orbX = side * (this.width/2 + 12);
                            const orbY = wobble * side;
                            ctx.beginPath();
                            ctx.arc(orbX, orbY, 8, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        ctx.shadowBlur = 0;
                        
                        // Lightning particles
                        if (Math.random() < 0.4) {
                            particles.push(new Particle(
                                this.x + (Math.random() - 0.5) * this.width * 2,
                                this.y + (Math.random() - 0.5) * this.height * 2,
                                ['#ffff00', '#ffffff'][Math.floor(Math.random() * 2)],
                                (Math.random() - 0.5) * 4,
                                (Math.random() - 0.5) * 4,
                                20
                            ));
                        }
                        break;
                        
                    case 'Necromancer':
                        // Dark robes
                        const robeGrad = ctx.createLinearGradient(0, -this.height/2, 0, this.height/2);
                        robeGrad.addColorStop(0, '#2f0f4f');
                        robeGrad.addColorStop(0.5, '#4b0082');
                        robeGrad.addColorStop(1, '#1a0033');
                        ctx.fillStyle = robeGrad;
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        // Skull patterns
                        ctx.fillStyle = '#ffffff';
                        for (let i = 0; i < 3; i++) {
                            const y = -this.height/2 + 10 + i * 15;
                            // Mini skulls
                            ctx.fillRect(-5, y, 10, 8);
                            ctx.fillStyle = '#000000';
                            ctx.fillRect(-4, y + 1, 2, 2);
                            ctx.fillRect(2, y + 1, 2, 2);
                            ctx.fillStyle = '#ffffff';
                        }
                        
                        // Hood
                        ctx.fillStyle = '#0a0a0a';
                        ctx.beginPath();
                        ctx.arc(0, -this.height/2 + 10, 20, Math.PI, 0);
                        ctx.fill();
                        
                        // Skull face
                        ctx.fillStyle = '#f0f0f0';
                        ctx.fillRect(-10, -this.height/2 + 10, 20, 15);
                        ctx.fillStyle = '#000000';
                        ctx.fillRect(-8, -this.height/2 + 14, 4, 4);
                        ctx.fillRect(4, -this.height/2 + 14, 4, 4);
                        ctx.fillRect(-3, -this.height/2 + 20, 6, 3);
                        
                        // Staff with skull
                        ctx.strokeStyle = '#4b0082';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.moveTo(-this.width/2 - 10, this.height/2);
                        ctx.lineTo(-this.width/2 - 10, -this.height/2 - 10);
                        ctx.stroke();
                        
                        ctx.fillStyle = '#f0f0f0';
                        ctx.fillRect(-this.width/2 - 18, -this.height/2 - 20, 16, 14);
                        ctx.fillStyle = '#000000';
                        ctx.fillRect(-this.width/2 - 16, -this.height/2 - 17, 4, 4);
                        ctx.fillRect(-this.width/2 - 8, -this.height/2 - 17, 4, 4);
                        
                        // Soul particles
                        if (Math.random() < 0.3) {
                            particles.push(new Particle(
                                this.x + (Math.random() - 0.5) * this.width * 2,
                                this.y + (Math.random() - 0.5) * this.height * 2,
                                '#8b008b',
                                (Math.random() - 0.5) * 2,
                                -Math.random() * 3,
                                50
                            ));
                        }
                        break;
                        
                    case 'Blood Reaper':
                        // Crimson armor
                        const bloodGrad = ctx.createLinearGradient(0, -this.height/2, 0, this.height/2);
                        bloodGrad.addColorStop(0, '#8b0000');
                        bloodGrad.addColorStop(0.5, '#dc143c');
                        bloodGrad.addColorStop(1, '#4a0000');
                        ctx.fillStyle = bloodGrad;
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        // Blood drips
                        ctx.fillStyle = '#dc143c';
                        ctx.globalAlpha = 0.8;
                        for (let i = 0; i < 8; i++) {
                            const x = -this.width/2 + i * 6;
                            const dripLength = 4 + Math.sin(Date.now()/100 + i) * 3;
                            ctx.fillRect(x, this.height/2, 3, dripLength);
                        }
                        ctx.globalAlpha = 1;
                        
                        // Skull helmet
                        ctx.fillStyle = '#696969';
                        ctx.fillRect(-15, -this.height/2, 30, 25);
                        ctx.fillStyle = '#000000';
                        ctx.fillRect(-12, -this.height/2 + 8, 8, 8);
                        ctx.fillRect(4, -this.height/2 + 8, 8, 8);
                        for (let i = 0; i < 5; i++) {
                            ctx.fillRect(-10 + i * 4, -this.height/2 + 18, 3, 5);
                        }
                        
                        // Giant scythe
                        ctx.strokeStyle = '#2f2f2f';
                        ctx.lineWidth = 5;
                        ctx.beginPath();
                        ctx.moveTo(this.width/2, this.height/2);
                        ctx.lineTo(this.width/2, -this.height/2 - 15);
                        ctx.stroke();
                        
                        ctx.fillStyle = '#c0c0c0';
                        ctx.beginPath();
                        ctx.arc(this.width/2, -this.height/2 - 15, 15, Math.PI, 1.5 * Math.PI);
                        ctx.lineTo(this.width/2 + 20, -this.height/2 - 10);
                        ctx.arc(this.width/2, -this.height/2 - 15, 12, 1.5 * Math.PI, Math.PI);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Blood on scythe
                        ctx.fillStyle = '#dc143c';
                        ctx.fillRect(this.width/2 + 10, -this.height/2 - 18, 8, 4);
                        break;
                        
                    case 'Void Walker':
                        // Void body - constantly shifting
                        ctx.globalAlpha = 0.8;
                        const voidGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, this.width);
                        voidGrad.addColorStop(0, '#483d8b');
                        voidGrad.addColorStop(0.5, '#2f2f4f');
                        voidGrad.addColorStop(1, '#191970');
                        ctx.fillStyle = voidGrad;
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        ctx.globalAlpha = 1;
                        
                        // Void distortion effect
                        ctx.globalAlpha = 0.3;
                        for (let i = 0; i < 3; i++) {
                            const offset = Math.sin(Date.now()/100 + i) * 5;
                            ctx.fillStyle = i % 2 === 0 ? '#6a5acd' : '#4b0082';
                            ctx.fillRect(-this.width/2 + offset, -this.height/2, this.width, this.height);
                        }
                        ctx.globalAlpha = 1;
                        
                        // Cosmic eyes
                        ctx.fillStyle = '#ffffff';
                        ctx.shadowColor = '#9370db';
                        ctx.shadowBlur = 20;
                        ctx.beginPath();
                        ctx.arc(-8, -this.height/2 + 15, 6, 0, Math.PI * 2);
                        ctx.arc(8, -this.height/2 + 15, 6, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                        
                        // Void tendrils
                        ctx.strokeStyle = '#483d8b';
                        ctx.lineWidth = 3;
                        for (let i = 0; i < 4; i++) {
                            const angle = (Math.PI * 2 / 4) * i + Date.now() / 500;
                            const length = 20 + Math.sin(Date.now()/200 + i) * 5;
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.quadraticCurveTo(
                                Math.cos(angle) * 15,
                                Math.sin(angle) * 15,
                                Math.cos(angle) * length,
                                Math.sin(angle) * length
                            );
                            ctx.stroke();
                        }
                        
                        // Void particles
                        if (Math.random() < 0.4) {
                            particles.push(new Particle(
                                this.x + (Math.random() - 0.5) * this.width * 2,
                                this.y + (Math.random() - 0.5) * this.height * 2,
                                ['#483d8b', '#6a5acd', '#9370db'][Math.floor(Math.random() * 3)],
                                (Math.random() - 0.5) * 3,
                                (Math.random() - 0.5) * 3,
                                45
                            ));
                        }
                        break;
                        
                    default:
                        ctx.fillStyle = this.color;
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        break;
                }
                
                ctx.restore();
                
                // Epic Boss Health Bar
                const barWidth = this.width * 2;
                const barHeight = 12;
                const barY = this.y - this.height / 2 - 35;
                
                // Background shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.fillRect(this.x - barWidth / 2 - 2, barY - 2, barWidth + 4, barHeight + 4);
                
                // Bar border
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 3;
                ctx.strokeRect(this.x - barWidth / 2, barY, barWidth, barHeight);
                
                // Dark background
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(this.x - barWidth / 2, barY, barWidth, barHeight);
                
                // Health fill with gradient
                const healthPercent = this.health / this.maxHealth;
                const healthGrad = ctx.createLinearGradient(this.x - barWidth/2, 0, this.x + barWidth/2, 0);
                if (healthPercent > 0.5) {
                    healthGrad.addColorStop(0, '#ff0000');
                    healthGrad.addColorStop(1, '#ff4500');
                } else if (healthPercent > 0.25) {
                    healthGrad.addColorStop(0, '#ff8c00');
                    healthGrad.addColorStop(1, '#ffa500');
                } else {
                    healthGrad.addColorStop(0, '#ffd700');
                    healthGrad.addColorStop(1, '#ff0000');
                }
                ctx.fillStyle = healthGrad;
                ctx.fillRect(this.x - barWidth / 2, barY, barWidth * healthPercent, barHeight);
                
                // Health shine effect
                ctx.globalAlpha = 0.4;
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(this.x - barWidth / 2, barY + 2, barWidth * healthPercent, 3);
                ctx.globalAlpha = 1;
                
                // Boss name with shadow
                ctx.fillStyle = '#000000';
                ctx.font = 'bold 18px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText(this.type, this.x + 1, barY - 13);
                ctx.fillStyle = '#ffd700';
                ctx.shadowColor = '#ff8c00';
                ctx.shadowBlur = 8;
                ctx.fillText(this.type, this.x, barY - 14);
                ctx.shadowBlur = 0;
                
                // Health text
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 10px Courier New';
                ctx.fillText(Math.floor(this.health) + ' / ' + this.maxHealth, this.x, barY + 10);
            }

            takeDamage(damage) {
                this.health -= damage;
                this.health = Math.max(0, this.health);
                
                for (let i = 0; i < 20; i++) {
                    particles.push(new Particle(
                        this.x,
                        this.y,
                        this.color,
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 10,
                        35
                    ));
                }
            }
        }

        // Room class (keeping original castle look)
        class Room {
            constructor(seed, isBossRoom = false, isSafeRoom = false) {
                this.seed = seed;
                this.isBossRoom = isBossRoom;
                this.isSafeRoom = isSafeRoom;
                this.enemies = [];
                this.boss = null;
                this.platforms = [];
                this.cleared = false;
                
                // Seeded random
                function rand() {
                    seed = (seed * 9301 + 49297) % 233280;
                    return seed / 233280;
                }
                
                // Generate platforms
                const platformCount = 3 + Math.floor(rand() * 4);
                for (let i = 0; i < platformCount; i++) {
                    this.platforms.push({
                        x: 100 + rand() * (canvas.width - 300),
                        y: 200 + rand() * 300,
                        width: 100 + rand() * 150,
                        height: 15
                    });
                }
                
                // Safe spawn/exit platforms
                this.platforms.push({
                    x: 50,
                    y: canvas.height - 150,
                    width: 200,
                    height: 15
                });
                
                this.platforms.push({
                    x: canvas.width - 250,
                    y: canvas.height - 150,
                    width: 200,
                    height: 15
                });
                
                // Safe rooms have no enemies
                if (this.isSafeRoom) {
                    // Empty room - safe zone!
                } else if (this.isBossRoom) {
                    const bossTypes = [
                        'Crimson Knight', 'Shadow Lord', 'Frost Warden', 'Flame Tyrant',
                        'Stone Golem', 'Toxic Assassin', 'Thunder King', 'Necromancer',
                        'Blood Reaper', 'Void Walker'
                    ];
                    const bossType = bossTypes[Math.floor(rand() * bossTypes.length)];
                    this.boss = new Boss(canvas.width / 2, canvas.height - 200, bossType);
                } else {
                    let baseEnemyCount = 2 + Math.floor(rand() * 4);
                    
                    if (this.seed < 3 * 12345) {
                        baseEnemyCount = 1 + Math.floor(rand() * 2);
                    } else if (this.seed < 5 * 12345) {
                        baseEnemyCount = 2 + Math.floor(rand() * 2);
                    }
                    
                    const enemyCount = Math.min(baseEnemyCount, this.platforms.length);
                    const usedPlatforms = [];
                    const enemyTypes = ['basic', 'advanced', 'heavy', 'assassin', 'mage'];
                    
                    for (let i = 0; i < enemyCount; i++) {
                        let platformIndex;
                        let attempts = 0;
                        do {
                            platformIndex = Math.floor(rand() * this.platforms.length);
                            attempts++;
                        } while (usedPlatforms.includes(platformIndex) && attempts < 20);
                        
                        if (!usedPlatforms.includes(platformIndex)) {
                            usedPlatforms.push(platformIndex);
                            const platform = this.platforms[platformIndex];
                            
                            const typeRoll = rand();
                            let type;
                            
                            if (this.seed < 3 * 12345) {
                                if (typeRoll < 0.6) type = 'basic';
                                else if (typeRoll < 0.9) type = 'advanced';
                                else type = 'assassin';
                            } else if (this.seed < 5 * 12345) {
                                if (typeRoll < 0.35) type = 'basic';
                                else if (typeRoll < 0.6) type = 'advanced';
                                else if (typeRoll < 0.75) type = 'heavy';
                                else if (typeRoll < 0.9) type = 'assassin';
                                else type = 'mage';
                            } else {
                                if (typeRoll < 0.3) type = 'basic';
                                else if (typeRoll < 0.55) type = 'advanced';
                                else if (typeRoll < 0.7) type = 'heavy';
                                else if (typeRoll < 0.85) type = 'assassin';
                                else type = 'mage';
                            }
                            
                            this.enemies.push(new Enemy(
                                platform.x + platform.width / 2,
                                platform.y - 40,
                                type
                            ));
                        }
                    }
                }
            }

            draw() {
                // Background gradient (castle stone walls)
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                
                // Safe rooms have green tint
                if (this.isSafeRoom) {
                    gradient.addColorStop(0, '#2a4a2a');
                    gradient.addColorStop(1, '#1a2a1a');
                } else {
                    gradient.addColorStop(0, '#3a3a3a');
                    gradient.addColorStop(1, '#1a1a1a');
                }
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Safe room healing aura
                if (this.isSafeRoom) {
                    ctx.globalAlpha = 0.1 + Math.sin(Date.now() / 500) * 0.05;
                    const auraGrad = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, canvas.width/2);
                    auraGrad.addColorStop(0, '#00ff00');
                    auraGrad.addColorStop(1, 'rgba(0, 255, 0, 0)');
                    ctx.fillStyle = auraGrad;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.globalAlpha = 1;
                }
                
                // Stone wall texture
                for (let i = 0; i < 20; i++) {
                    for (let j = 0; j < 15; j++) {
                        const x = i * 60 + (j % 2) * 30;
                        const y = j * 50;
                        ctx.strokeStyle = this.isSafeRoom ? '#3a5a3a' : '#2a2a2a';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x, y, 60, 50);
                    }
                }
                
                // Torches (green for safe rooms)
                for (let i = 0; i < 5; i++) {
                    const x = 150 + i * 220;
                    const y = 80;
                    
                    const torchColor = this.isSafeRoom ? 'rgba(0, 255, 100, 0.15)' : 'rgba(255, 140, 0, 0.15)';
                    const torchGradient = ctx.createRadialGradient(x, y, 0, x, y, 60);
                    torchGradient.addColorStop(0, torchColor);
                    torchGradient.addColorStop(1, torchColor.replace('0.15', '0'));
                    ctx.fillStyle = torchGradient;
                    ctx.fillRect(x - 60, y - 60, 120, 120);
                    
                    ctx.fillStyle = this.isSafeRoom ? '#00ff64' : '#ff8c00';
                    ctx.globalAlpha = 0.8 + Math.sin(Date.now() / 100 + i) * 0.2;
                    ctx.beginPath();
                    ctx.ellipse(x, y, 6, 10 + Math.sin(Date.now() / 150 + i) * 3, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
                
                // Platforms
                for (const platform of this.platforms) {
                    ctx.fillStyle = 'rgba(0,0,0,0.4)';
                    ctx.fillRect(platform.x + 5, platform.y + 5, platform.width, platform.height);
                    
                    const platformGradient = ctx.createLinearGradient(0, platform.y, 0, platform.y + platform.height);
                    platformGradient.addColorStop(0, '#5a5a5a');
                    platformGradient.addColorStop(1, '#3a3a3a');
                    ctx.fillStyle = platformGradient;
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                    
                    ctx.fillStyle = '#6a6a6a';
                    ctx.fillRect(platform.x, platform.y, platform.width, 3);
                    
                    ctx.strokeStyle = '#2a2a2a';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < 3; i++) {
                        const crackX = platform.x + (platform.width / 4) * (i + 0.5);
                        ctx.beginPath();
                        ctx.moveTo(crackX, platform.y);
                        ctx.lineTo(crackX + 5, platform.y + platform.height);
                        ctx.stroke();
                    }
                }
                
                // Ground
                ctx.fillStyle = '#2a2a2a';
                ctx.fillRect(0, canvas.height - 50, canvas.width, 50);
                
                ctx.strokeStyle = '#1a1a1a';
                ctx.lineWidth = 2;
                for (let i = 0; i < canvas.width / 60; i++) {
                    ctx.strokeRect(i * 60, canvas.height - 50, 60, 50);
                }
                
                ctx.fillStyle = '#4a4a4a';
                ctx.fillRect(0, canvas.height - 50, canvas.width, 3);
                
                // Door
                if (this.enemies.length === 0 && !this.cleared) {
                    this.cleared = true;
                }
                
                if (this.cleared || this.enemies.length === 0) {
                    const doorX = canvas.width - 60;
                    const doorY = canvas.height - 180;
                    
                    ctx.fillStyle = '#4a4a4a';
                    ctx.fillRect(doorX, doorY, 50, 130);
                    
                    ctx.beginPath();
                    ctx.arc(doorX + 25, doorY + 130, 25, Math.PI, 0);
                    ctx.fill();
                    
                    ctx.fillStyle = '#0a0a0a';
                    ctx.fillRect(doorX + 5, doorY + 20, 40, 110);
                    
                    const doorGradient = ctx.createRadialGradient(doorX + 25, doorY + 75, 0, doorX + 25, doorY + 75, 50);
                    doorGradient.addColorStop(0, 'rgba(255, 215, 0, 0.4)');
                    doorGradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                    ctx.fillStyle = doorGradient;
                    ctx.fillRect(doorX - 20, doorY, 90, 130);
                    
                    ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 300) * 0.3;
                    ctx.fillStyle = '#ffd700';
                    ctx.fillRect(doorX + 5, doorY + 20, 40, 110);
                    ctx.globalAlpha = 1;
                    
                    ctx.strokeStyle = '#6a6a6a';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(doorX, doorY, 50, 130);
                    
                    ctx.fillStyle = '#ffd700';
                    ctx.font = '20px Courier New';
                    ctx.textAlign = 'center';
                    ctx.globalAlpha = 0.7 + Math.sin(Date.now() / 300) * 0.3;
                    ctx.fillText('→', doorX + 25, doorY - 10);
                    ctx.globalAlpha = 1;
                }
                
                // Safe room indicator text
                if (this.isSafeRoom) {
                    ctx.fillStyle = '#00ff00';
                    ctx.font = 'bold 36px Courier New';
                    ctx.textAlign = 'center';
                    ctx.shadowColor = 'rgba(0, 255, 0, 0.8)';
                    ctx.shadowBlur = 15;
                    ctx.globalAlpha = 0.8 + Math.sin(Date.now() / 500) * 0.2;
                    ctx.fillText('🛡️ SAFE ROOM 🛡️', canvas.width / 2, 100);
                    ctx.font = '20px Courier New';
                    ctx.fillText('Checkpoint Saved', canvas.width / 2, 140);
                    ctx.globalAlpha = 1;
                    ctx.shadowBlur = 0;
                }
            }
        }

        // MASSIVE Upgrade system with 45+ upgrades including mythics
        const upgradeDefinitions = {
            // COMMON (Basic improvements)
            maxHealth: { name: 'Vitality', desc: 'Increase max health', rarity: 'common', maxLevel: 10, type: 'passive' },
            damage: { name: 'Power', desc: 'Increase base damage', rarity: 'common', maxLevel: 10, type: 'passive' },
            attackSpeed: { name: 'Swiftness', desc: 'Attack faster', rarity: 'common', maxLevel: 8, type: 'passive' },
            speed: { name: 'Agility', desc: 'Move faster', rarity: 'common', maxLevel: 6, type: 'passive' },
            lifesteal: { name: 'Blood Hunger', desc: 'Steal health on hit', rarity: 'common', maxLevel: 5, type: 'passive' },
            thorns: { name: 'Thorns', desc: 'Reflect damage', rarity: 'common', maxLevel: 5, type: 'passive' },
            
            // UNCOMMON (Enhanced abilities)
            multishot: { name: 'Multishot', desc: 'Fire multiple knives', rarity: 'uncommon', maxLevel: 4, type: 'passive' },
            rapidFire: { name: 'Rapid Fire', desc: 'Throw knives faster', rarity: 'uncommon', maxLevel: 5, type: 'passive' },
            critChance: { name: 'Precision', desc: 'Increase crit chance', rarity: 'uncommon', maxLevel: 8, type: 'passive' },
            critDamage: { name: 'Execution', desc: 'Increase crit damage', rarity: 'uncommon', maxLevel: 6, type: 'passive' },
            dashAttack: { name: 'Dash Attack', desc: 'Damage while dashing', rarity: 'uncommon', maxLevel: 3, type: 'passive' },
            vampiricAura: { name: 'Vampiric Aura', desc: 'Drain nearby enemies', rarity: 'uncommon', maxLevel: 4, type: 'passive' },
            ironSkin: { name: 'Iron Skin', desc: 'Reduce damage taken', rarity: 'uncommon', maxLevel: 5, type: 'passive' },
            swiftness: { name: 'Enhanced Swiftness', desc: 'Greatly increase speed', rarity: 'uncommon', maxLevel: 4, type: 'passive' },
            
            // RARE (Special effects)
            poisonDagger: { name: 'Poison Blade', desc: 'Poison enemies (DoT)', rarity: 'rare', maxLevel: 4, type: 'passive' },
            frozenTouch: { name: 'Frozen Touch', desc: 'Slow enemies on hit', rarity: 'rare', maxLevel: 4, type: 'passive' },
            explosiveKnives: { name: 'Explosive Knives', desc: 'Knives explode', rarity: 'rare', maxLevel: 3, type: 'passive' },
            chainLightning: { name: 'Chain Lightning', desc: 'Lightning chains', rarity: 'rare', maxLevel: 3, type: 'passive' },
            piercing: { name: 'Piercing Shot', desc: 'Shots pierce', rarity: 'rare', maxLevel: 1, type: 'passive' },
            doubleJump: { name: 'Double Jump', desc: 'Jump in mid-air', rarity: 'rare', maxLevel: 1, type: 'passive' },
            ghostWalk: { name: 'Ghost Walk', desc: 'Phase through attacks', rarity: 'rare', maxLevel: 3, type: 'passive' },
            bloodRage: { name: 'Blood Rage', desc: 'Gain speed on kill', rarity: 'rare', maxLevel: 4, type: 'passive' },
            executeThreshold: { name: 'Execute', desc: 'Instant kill low HP enemies', rarity: 'rare', maxLevel: 3, type: 'passive' },
            ricochet: { name: 'Ricochet', desc: 'Knives bounce', rarity: 'rare', maxLevel: 3, type: 'passive' },
            magneticKnives: { name: 'Magnetic Knives', desc: 'Knives seek enemies', rarity: 'rare', maxLevel: 2, type: 'passive' },
            
            // NEW RARE UPGRADES
            deathMark: { name: 'Death Mark', desc: 'Mark enemies for extra damage', rarity: 'rare', maxLevel: 4, type: 'passive' },
            voidWalk: { name: 'Void Walk', desc: 'Dash through enemies dealing damage', rarity: 'rare', maxLevel: 3, type: 'passive' },
            soulHarvest: { name: 'Soul Harvest', desc: 'Restore health on kill', rarity: 'rare', maxLevel: 5, type: 'passive' },
            reflection: { name: 'Reflection', desc: 'Deal damage back when hit', rarity: 'rare', maxLevel: 4, type: 'passive' },
            arcaneShield: { name: 'Arcane Shield', desc: 'Projectiles may miss', rarity: 'rare', maxLevel: 3, type: 'passive' },
            regeneration: { name: 'Regeneration', desc: 'Slowly restore health', rarity: 'rare', maxLevel: 6, type: 'passive' },
            evasion: { name: 'Evasion', desc: 'Chance to dodge attacks', rarity: 'rare', maxLevel: 4, type: 'passive' },
            bloodShield: { name: 'Blood Shield', desc: 'Chance to block 50% damage', rarity: 'rare', maxLevel: 4, type: 'passive' },
            
            // EPIC (Powerful abilities)
            multiStrike: { name: 'Multi-Strike', desc: 'Attack multiple times', rarity: 'epic', maxLevel: 3, type: 'passive' },
            bladeDance: { name: 'Blade Dance', desc: 'Move while attacking', rarity: 'epic', maxLevel: 3, type: 'passive' },
            berserkerRage: { name: 'Berserker Rage', desc: 'More damage at low health', rarity: 'epic', maxLevel: 4, type: 'passive' },
            assassination: { name: 'Assassination', desc: 'Massive first hit damage', rarity: 'epic', maxLevel: 3, type: 'passive' },
            execution: { name: 'Executioner', desc: 'Instantly kill low HP', rarity: 'epic', maxLevel: 3, type: 'passive' },
            rage: { name: 'Rage', desc: 'Gain damage on kills', rarity: 'epic', maxLevel: 5, type: 'passive' },
            berserk: { name: 'Berserk', desc: 'High risk high reward', rarity: 'epic', maxLevel: 3, type: 'passive' },
            whirlwind: { name: 'Whirlwind', desc: 'Spin projectiles around you', rarity: 'epic', maxLevel: 3, type: 'passive' },
            criticalMass: { name: 'Critical Mass', desc: 'Crits create explosions', rarity: 'epic', maxLevel: 3, type: 'passive' },
            shadowBurst: { name: 'Shadow Burst', desc: 'Attacks may burst outward', rarity: 'epic', maxLevel: 3, type: 'passive' },
            timeWarp: { name: 'Time Warp', desc: 'Special: Slow all enemies', rarity: 'epic', maxLevel: 3, type: 'special' },
            
            // LEGENDARY (Active abilities)
            shadowClone: { name: 'Shadow Clone', desc: 'Summon fighting clone', rarity: 'legendary', type: 'special', cooldown: 300 },
            fireStorm: { name: 'Fire Storm', desc: 'Rain fire from above', rarity: 'legendary', type: 'special', cooldown: 300 },
            timeStop: { name: 'Time Stop', desc: 'Freeze all enemies', rarity: 'legendary', type: 'special', cooldown: 300 },
            phantomStrike: { name: 'Phantom Strike', desc: 'Teleport to enemy', rarity: 'legendary', type: 'special', cooldown: 300 },
            teleportStrike: { name: 'Teleport Strike', desc: 'Teleport and strike', rarity: 'legendary', type: 'special', cooldown: 300 },
            deathWave: { name: 'Death Wave', desc: 'Send waves of death', rarity: 'legendary', type: 'special', cooldown: 300 },
            meteorStrike: { name: 'Meteor Strike', desc: 'Rain meteors', rarity: 'legendary', type: 'special', cooldown: 300 },
            
            // MYTHIC (Game-changing abilities) - OVERPOWERED!
            godMode: { name: '⚡ GOD MODE ⚡', desc: 'Invincible + 10x damage for 5s', rarity: 'mythic', type: 'special', cooldown: 300 },
            omniSlash: { name: '⚡ OMNI SLASH ⚡', desc: 'Dash through all enemies', rarity: 'mythic', type: 'special', cooldown: 300 },
            armageddon: { name: '⚡ ARMAGEDDON ⚡', desc: 'Meteor apocalypse', rarity: 'mythic', type: 'special', cooldown: 300 },
            infinityEdge: { name: '⚡ INFINITY EDGE ⚡', desc: 'Summon 20 homing blades', rarity: 'mythic', type: 'special', cooldown: 300 },
            divineShield: { name: '⚡ DIVINE SHIELD ⚡', desc: 'Invulnerable for 4s', rarity: 'mythic', type: 'special', cooldown: 300 },
            stormCaller: { name: '⚡ STORM CALLER ⚡', desc: 'Lightning strikes all', rarity: 'mythic', type: 'special', cooldown: 300 },
            timestrike: { name: '⚡ TIME STRIKE ⚡', desc: 'Stop time for 5s', rarity: 'mythic', type: 'special', cooldown: 300 },
            soulReaper: { name: '⚡ SOUL REAPER ⚡', desc: 'Instantly kill all normal enemies', rarity: 'mythic', type: 'special', cooldown: 300 },
            ragnarok: { name: '⚡ RAGNAROK ⚡', desc: 'Screen-wide explosion', rarity: 'mythic', type: 'special', cooldown: 300 }
        };

        function getRandomUpgrades(count = 3) {
            const available = [];
            
            // If mythic mode, ONLY show mythic upgrades!
            if (mythicMode) {
                for (const [key, upgrade] of Object.entries(upgradeDefinitions)) {
                    if (upgrade.rarity === 'mythic') {
                        const currentLevel = player.upgrades[key] || 0;
                        if (!upgrade.maxLevel || currentLevel < upgrade.maxLevel) {
                            available.push(key);
                        }
                    }
                }
            } else {
                // Normal mode - no mythics shown
                const rarityWeights = {
                    common: 40,
                    uncommon: 30,
                    rare: 15,
                    epic: 10,
                    legendary: 4
                };
                
                for (const [key, upgrade] of Object.entries(upgradeDefinitions)) {
                    if (upgrade.rarity === 'mythic') continue; // Skip mythics in normal mode
                    
                    const currentLevel = player.upgrades[key] || 0;
                    if (!upgrade.maxLevel || currentLevel < upgrade.maxLevel) {
                        const weight = rarityWeights[upgrade.rarity] || 1;
                        for (let i = 0; i < weight; i++) {
                            available.push(key);
                        }
                    }
                }
            }
            
            if (available.length === 0) return [];
            
            // Shuffle
            for (let i = available.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [available[i], available[j]] = [available[j], available[i]];
            }
            
            // Get unique upgrades
            const selected = [];
            const seen = new Set();
            for (const key of available) {
                if (!seen.has(key)) {
                    selected.push(key);
                    seen.add(key);
                }
                if (selected.length >= count) break;
            }
            
            return selected;
        }

        function showUpgradeScreen() {
            const upgradeScreen = document.getElementById('upgradeScreen');
            const upgradeOptions = document.getElementById('upgradeOptions');
            
            upgradeOptions.innerHTML = '';
            const selectedUpgrades = getRandomUpgrades(3);
            
            selectedUpgrades.forEach(upgradeKey => {
                const upgrade = upgradeDefinitions[upgradeKey];
                const currentLevel = player.upgrades[upgradeKey] || 0;
                
                const card = document.createElement('div');
                card.className = 'upgrade-card';
                if (upgrade.rarity === 'mythic') {
                    card.classList.add('mythic');
                }
                
                let levelText = '';
                if (upgrade.maxLevel) {
                    levelText = `<div class="level">Level ${currentLevel} → ${currentLevel + 1}</div>`;
                }
                
                card.innerHTML = `
                    <h3>${upgrade.name}</h3>
                    ${levelText}
                    <p>${upgrade.desc}</p>
                    <p style="color: ${
                        upgrade.rarity === 'mythic' ? '#ff00ff' :
                        upgrade.rarity === 'legendary' ? '#ff8c00' :
                        upgrade.rarity === 'epic' ? '#9400d3' :
                        upgrade.rarity === 'rare' ? '#4169e1' :
                        upgrade.rarity === 'uncommon' ? '#228b22' : '#808080'
                    }; font-size: 12px; margin-top: 8px;">${upgrade.rarity.toUpperCase()}</p>
                `;
                
                card.addEventListener('click', () => {
                    applyUpgrade(upgradeKey);
                    upgradeScreen.style.display = 'none';
                    showingUpgrade = false;
                    
                    // Upgrade particles
                    for (let i = 0; i < 50; i++) {
                        particles.push(new Particle(
                            player.x,
                            player.y,
                            upgrade.rarity === 'mythic' ? '#ff00ff' : '#ffd700',
                            (Math.random() - 0.5) * 12,
                            (Math.random() - 0.5) * 12,
                            40
                        ));
                    }
                });
                
                upgradeOptions.appendChild(card);
            });
            
            upgradeScreen.style.display = 'flex';
        }

        function applyUpgrade(upgradeKey) {
            const upgrade = upgradeDefinitions[upgradeKey];
            
            if (upgrade.maxLevel) {
                player.upgrades[upgradeKey] = (player.upgrades[upgradeKey] || 0) + 1;
            } else {
                player.upgrades[upgradeKey] = 1;
            }
            
            // Apply upgrade effects
            switch(upgradeKey) {
                case 'maxHealth':
                    player.maxHealth = 150 + player.upgrades.maxHealth * 25;
                    player.health = Math.min(player.health + 25, player.maxHealth);
                    break;
                case 'damage':
                    // Handled in takeDamage calculation
                    break;
                case 'speed':
                case 'swiftness':
                    player.speed = 5 + (player.upgrades.speed + player.upgrades.swiftness) * 0.8;
                    break;
                case 'doubleJump':
                    player.hasDoubleJump = true;
                    break;
            }
            
            // Special ability assignment
            if (upgrade.type === 'special') {
                if (!player.special1) {
                    player.special1 = upgradeKey;
                } else if (!player.special2) {
                    player.special2 = upgradeKey;
                } else {
                    // Replace special1 if both slots full
                    player.special1 = upgradeKey;
                }
                updateSpecialAbilitiesUI();
            }
        }
        
        function updateSpecialAbilitiesUI() {
            const listElement = document.getElementById('specialAbilitiesList');
            listElement.innerHTML = '';
            
            if (player.special1) {
                const ability1 = upgradeDefinitions[player.special1];
                const cooldown1 = player.special1Cooldown;
                const maxCooldown1 = ability1.cooldown || 300;
                const ready1 = cooldown1 <= 0;
                
                const div1 = document.createElement('div');
                div1.style.marginBottom = '5px';
                div1.style.color = ready1 ? '#00ff00' : '#ff6666';
                div1.innerHTML = `[Q] ${ability1.name}${ready1 ? ' ✓' : ' (' + Math.ceil(cooldown1/60) + 's)'}`;
                listElement.appendChild(div1);
            }
            
            if (player.special2) {
                const ability2 = upgradeDefinitions[player.special2];
                const cooldown2 = player.special2Cooldown;
                const maxCooldown2 = ability2.cooldown || 300;
                const ready2 = cooldown2 <= 0;
                
                const div2 = document.createElement('div');
                div2.style.color = ready2 ? '#00ff00' : '#ff6666';
                div2.innerHTML = `[E] ${ability2.name}${ready2 ? ' ✓' : ' (' + Math.ceil(cooldown2/60) + 's)'}`;
                listElement.appendChild(div2);
            }
            
            if (!player.special1 && !player.special2) {
                listElement.innerHTML = '<div style="color: #888;">None equipped</div>';
            }
            
            // Update keybinds display
            updateKeybindsDisplay();
        }
        
        function updateKeybindsDisplay() {
            const additionalKeybinds = document.getElementById('additionalKeybinds');
            additionalKeybinds.innerHTML = '';
            
            if (player.special1) {
                const ability1 = upgradeDefinitions[player.special1];
                const div = document.createElement('div');
                div.className = 'keybind-item';
                div.innerHTML = `
                    <span class="keybind-key">[Q]</span>
                    <span class="keybind-ability">${ability1.name}</span>
                `;
                additionalKeybinds.appendChild(div);
            }
            
            if (player.special2) {
                const ability2 = upgradeDefinitions[player.special2];
                const div = document.createElement('div');
                div.className = 'keybind-item';
                div.innerHTML = `
                    <span class="keybind-key">[E]</span>
                    <span class="keybind-ability">${ability2.name}</span>
                `;
                additionalKeybinds.appendChild(div);
            }
        }
        
        function initializeMythicPanel() {
            const panel = document.getElementById('mythicAbilityList');
            panel.innerHTML = '';
            
            // Add all possible abilities
            for (const [key, upgrade] of Object.entries(upgradeDefinitions)) {
                const abilityDiv = document.createElement('div');
                abilityDiv.className = 'mythic-ability';
                abilityDiv.dataset.ability = key;
                
                abilityDiv.innerHTML = `
                    <span class="mythic-ability-name">${upgrade.name}</span>
                    <div class="mythic-ability-toggle"></div>
                `;
                
                abilityDiv.addEventListener('click', () => {
                    toggleMythicAbility(key, abilityDiv);
                });
                
                panel.appendChild(abilityDiv);
            }
        }
        
        function toggleMythicAbility(abilityKey, element) {
            const upgrade = upgradeDefinitions[abilityKey];
            
            if (element.classList.contains('active')) {
                // Deactivate
                element.classList.remove('active');
                
                if (upgrade.type === 'special') {
                    // Remove from special slots
                    if (player.special1 === abilityKey) player.special1 = null;
                    if (player.special2 === abilityKey) player.special2 = null;
                } else {
                    // Remove upgrade
                    player.upgrades[abilityKey] = 0;
                }
            } else {
                // Activate
                element.classList.add('active');
                
                if (upgrade.type === 'special') {
                    // Add to special slot
                    if (!player.special1) {
                        player.special1 = abilityKey;
                    } else if (!player.special2) {
                        player.special2 = abilityKey;
                    } else {
                        player.special1 = abilityKey; // Replace special1
                    }
                } else {
                    // Max out upgrade
                    player.upgrades[abilityKey] = upgrade.maxLevel || 10;
                }
                
                // Apply special effects
                applyUpgrade(abilityKey);
            }
            
            // Update UI
            updateSpecialAbilitiesUI();
        }
        
        // Mythic panel toggle button
        document.getElementById('mythicToggleBtn').addEventListener('click', () => {
            const panel = document.getElementById('mythicPanel');
            if (panel.style.display === 'none' || panel.style.display === '') {
                panel.style.display = 'block';
            } else {
                panel.style.display = 'none';
            }
        });

        // Game state
        let player = new Player(100, 300);
        let currentRoom = new Room(1);
        let roomNumber = 1;
        let particles = [];
        let projectiles = [];
        let shadowClones = [];
        let gameStarted = false;
        let showingUpgrade = false;
        let gameOver = false;
        
        // SECRET CHEAT CODE SYSTEM
        let cheatCode = '';
        let mythicMode = false;
        
        // Input
        const keys = {};
        const mouse = { x: 0, y: 0 };
        
        // Event listeners
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            
            // CHEAT CODE DETECTION
            cheatCode += e.key.toLowerCase();
            if (cheatCode.length > 20) cheatCode = cheatCode.slice(-20);
            
            if (cheatCode.includes('goldengod')) {
                if (!mythicMode) {
                    mythicMode = true;
                    cheatCode = '';
                    
                    // MYTHIC MODE ACTIVATION!
                    for (let i = 0; i < 200; i++) {
                        particles.push(new Particle(
                            Math.random() * canvas.width,
                            Math.random() * canvas.height,
                            '#ff00ff',
                            (Math.random() - 0.5) * 20,
                            (Math.random() - 0.5) * 20,
                            60
                        ));
                    }
                    
                    // Show mythic toggle button
                    document.getElementById('mythicToggleBtn').style.display = 'block';
                    
                    // Initialize mythic panel
                    initializeMythicPanel();
                    
                    console.log('🔮 MYTHIC MODE ACTIVATED! 🔮');
                }
            }
            
            if (!gameStarted) {
                return;
            }
            
            // Jump
            if (e.key === ' ' || e.key === 'w' || e.key.toLowerCase() === 'arrowup') {
                if (player.onGround) {
                    player.vy = -player.jumpPower;
                } else if (player.upgrades.doubleJump && !player.hasDoubleJumped) {
                    player.vy = -player.jumpPower;
                    player.hasDoubleJumped = true;
                }
            }
            
            // Dash
            if (e.key === 'k') {
                player.dash();
            }
            
            // Specials
            if (e.key === 'q') {
                player.useSpecial1();
            }
            if (e.key === 'e') {
                player.useSpecial2();
            }
        });
        
        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });
        
        canvas.addEventListener('mousedown', () => {
            if (gameStarted && !gameOver) {
                player.attack();
            }
        });
        
        // Game loop
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Always draw the room (even during upgrade/safe room screens)
            if (gameStarted && !gameOver) {
                currentRoom.draw();
            }
            
            if (!gameStarted || gameOver || showingUpgrade) {
                requestAnimationFrame(gameLoop);
                return;
            }
            
            // Player input
            if (!player.dashing) {
                if (keys['a'] || keys['arrowleft']) {
                    player.vx = -player.speed;
                    player.facing = -1;
                } else if (keys['d'] || keys['arrowright']) {
                    player.vx = player.speed;
                    player.facing = 1;
                } else {
                    player.vx *= 0.8;
                }
            }
            
            // Ranged attack
            if (keys['l']) {
                player.shootRanged();
            }
            
            // Dagger attack (j)
            if (keys['j']) {
                player.attack();
            }
            
            // Update
            player.update();
            
            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                particles[i].draw();
                if (particles[i].life <= 0) {
                    particles.splice(i, 1);
                }
            }
            
            // Update projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                if (!projectiles[i].update()) {
                    projectiles.splice(i, 1);
                } else {
                    projectiles[i].draw();
                    
                    // Collision detection
                    const proj = projectiles[i];
                    
                    if (proj.owner === 'player') {
                        let hitSomething = false;
                        
                        // vs enemies
                        for (let j = currentRoom.enemies.length - 1; j >= 0; j--) {
                            const enemy = currentRoom.enemies[j];
                            const dist = Math.sqrt((proj.x - enemy.x)**2 + (proj.y - enemy.y)**2);
                            if (dist < enemy.width / 2 + 8) {
                                const damage = player.attackDamage * (1 + player.upgrades.damage * 0.15);
                                enemy.takeDamage(damage);
                                
                                // EXPLOSIVE KNIVES
                                if (proj.explosive) {
                                    // Create explosion particles
                                    for (let k = 0; k < 30; k++) {
                                        particles.push(new Particle(
                                            proj.x, proj.y,
                                            ['#ff4500', '#ff8c00', '#ffa500'][Math.floor(Math.random() * 3)],
                                            (Math.random() - 0.5) * 15,
                                            (Math.random() - 0.5) * 15,
                                            40
                                        ));
                                    }
                                    
                                    // Explosion damage to nearby enemies
                                    const explosionRadius = 80;
                                    for (let k = currentRoom.enemies.length - 1; k >= 0; k--) {
                                        if (k === j) continue;
                                        const eDist = Math.sqrt((proj.x - currentRoom.enemies[k].x)**2 + (proj.y - currentRoom.enemies[k].y)**2);
                                        if (eDist < explosionRadius) {
                                            currentRoom.enemies[k].takeDamage(damage * 0.5);
                                            if (currentRoom.enemies[k].health <= 0) {
                                                currentRoom.enemies.splice(k, 1);
                                                if (k < j) j--;
                                            }
                                        }
                                    }
                                }
                                
                                if (enemy.health <= 0) {
                                    currentRoom.enemies.splice(j, 1);
                                }
                                
                                hitSomething = true;
                                
                                // PIERCING - projectile continues
                                if (player.upgrades.piercing > 0) {
                                    // Don't remove projectile, let it pierce through
                                } else if (player.upgrades.ricochet > 0 && player.upgrades.ricochet <= 3) {
                                    // RICOCHET - bounce to another enemy
                                    let nearestEnemy = null;
                                    let nearestDist = Infinity;
                                    for (const e of currentRoom.enemies) {
                                        if (e === enemy) continue;
                                        const d = Math.sqrt((e.x - proj.x)**2 + (e.y - proj.y)**2);
                                        if (d < nearestDist && d < 300) {
                                            nearestDist = d;
                                            nearestEnemy = e;
                                        }
                                    }
                                    
                                    if (nearestEnemy) {
                                        const angle = Math.atan2(nearestEnemy.y - proj.y, nearestEnemy.x - proj.x);
                                        proj.vx = Math.cos(angle) * 12;
                                        proj.vy = Math.sin(angle) * 12;
                                        proj.life = 60; // Give it more life to reach target
                                    } else {
                                        projectiles.splice(i, 1);
                                    }
                                    break;
                                } else {
                                    projectiles.splice(i, 1);
                                    break;
                                }
                            }
                        }
                        
                        // vs boss
                        if (!hitSomething && currentRoom.boss && currentRoom.boss.health > 0) {
                            const dist = Math.sqrt((proj.x - currentRoom.boss.x)**2 + (proj.y - currentRoom.boss.y)**2);
                            if (dist < currentRoom.boss.width / 2 + 8) {
                                const damage = player.attackDamage * (1 + player.upgrades.damage * 0.15);
                                currentRoom.boss.takeDamage(damage);
                                
                                // EXPLOSIVE KNIVES on boss
                                if (proj.explosive) {
                                    for (let k = 0; k < 30; k++) {
                                        particles.push(new Particle(
                                            proj.x, proj.y,
                                            ['#ff4500', '#ff8c00', '#ffa500'][Math.floor(Math.random() * 3)],
                                            (Math.random() - 0.5) * 15,
                                            (Math.random() - 0.5) * 15,
                                            40
                                        ));
                                    }
                                }
                                
                                // Don't remove if piercing
                                if (!(player.upgrades.piercing > 0)) {
                                    projectiles.splice(i, 1);
                                }
                            }
                        }
                    } else {
                        // Enemy projectile vs player
                        const dist = Math.sqrt((proj.x - player.x)**2 + (proj.y - player.y)**2);
                        if (dist < player.width / 2 + 8) {
                            if (!player.dashing && !player.invincible) {
                                player.takeDamage(10);
                            }
                            projectiles.splice(i, 1);
                        }
                    }
                }
            }
            
            // Update shadow clones
            for (let i = shadowClones.length - 1; i >= 0; i--) {
                if (!shadowClones[i].update()) {
                    shadowClones.splice(i, 1);
                } else {
                    shadowClones[i].draw();
                }
            }
            
            // Update enemies
            for (const enemy of currentRoom.enemies) {
                enemy.update();
                enemy.draw();
            }
            
            // Update boss
            if (currentRoom.boss && currentRoom.boss.health > 0) {
                currentRoom.boss.update();
                currentRoom.boss.draw();
            }
            
            // Draw player
            player.draw();
            
            // Check for room transition
            const roomCleared = currentRoom.isSafeRoom || (currentRoom.boss ? 
                (currentRoom.boss.health <= 0) : 
                (currentRoom.enemies.length === 0));
                
            if (roomCleared && player.x > canvas.width - 60) {
                roomNumber++;
                
                const isSafeRoom = (roomNumber % 7 === 0);
                const isBossRoom = (roomNumber % 5 === 0) && !isSafeRoom;
                currentRoom = new Room(roomNumber * 12345, isBossRoom, isSafeRoom);
                
                player.x = 100;
                player.y = canvas.height - 200;
                player.vy = 0;
                player.vx = 0;
                
                if (isSafeRoom) {
                    // Full heal in safe room
                    player.health = player.maxHealth;
                } else {
                    // Small heal on normal room transition
                    player.health = Math.min(player.health + 20, player.maxHealth);
                }
                
                projectiles = [];
                particles = [];
                shadowClones = [];
                
                // Save checkpoint at safe rooms (every 7 rooms)
                if (isSafeRoom) {
                    const checkpoint = {
                        room: roomNumber,
                        health: player.health,
                        maxHealth: player.maxHealth,
                        upgrades: {...player.upgrades},
                        special1: player.special1,
                        special2: player.special2,
                        hasDoubleJump: player.hasDoubleJump,
                        mythicMode: mythicMode
                    };
                    localStorage.setItem('shadowAssassinCheckpoint', JSON.stringify(checkpoint));
                    
                    // Show safe room screen
                    document.getElementById('safeRoomScreen').style.display = 'flex';
                    showingUpgrade = true;
                } else if (!isBossRoom) {
                    // Show upgrade screen for normal rooms
                    showingUpgrade = true;
                    showUpgradeScreen();
                }
            }
            
            // Update UI
            document.getElementById('health').textContent = Math.floor(player.health);
            document.getElementById('healthBar').style.width = (player.health / player.maxHealth * 100) + '%';
            document.getElementById('room').textContent = roomNumber;
            const enemyCount = currentRoom.enemies.length + (currentRoom.boss && currentRoom.boss.health > 0 ? 1 : 0);
            document.getElementById('enemies').textContent = enemyCount;
            
            // Update special abilities UI
            updateSpecialAbilitiesUI();
            
            // Mythic mode indicator
            if (mythicMode) {
                ctx.fillStyle = '#ff00ff';
                ctx.font = 'bold 24px Courier New';
                ctx.textAlign = 'center';
                ctx.shadowColor = 'rgba(255, 0, 255, 0.8)';
                ctx.shadowBlur = 10;
                const pulse = 0.8 + Math.sin(Date.now() / 200) * 0.2;
                ctx.globalAlpha = pulse;
                ctx.fillText('✨ MYTHIC MODE ✨', canvas.width / 2, 30);
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
            }
            
            // Game over
            if (player.health <= 0 && !gameOver) {
                gameOver = true;
                document.getElementById('finalRoom').textContent = roomNumber;
                document.getElementById('gameOverScreen').style.display = 'flex';
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        // Menu button event listeners
        document.getElementById('playBtn').addEventListener('click', () => {
            document.getElementById('mainMenu').style.display = 'none';
            gameStarted = true;
            mythicMode = false; // Reset mythic mode
            player = new Player(100, 300);
            currentRoom = new Room(1);
            roomNumber = 1;
            particles = [];
            projectiles = [];
            shadowClones = [];
            gameOver = false;
        });

        document.getElementById('settingsBtn').addEventListener('click', () => {
            document.getElementById('settingsMenu').style.display = 'flex';
        });

        document.getElementById('backBtn').addEventListener('click', () => {
            document.getElementById('settingsMenu').style.display = 'none';
        });

        // Settings toggles
        function setupToggle(toggleId, valueId, settingKey) {
            document.getElementById(toggleId).addEventListener('click', function() {
                this.classList.toggle('active');
                const isActive = this.classList.contains('active');
                document.getElementById(valueId).textContent = isActive ? 'ON' : 'OFF';
            });
        }

        setupToggle('particlesToggle', 'particlesValue', 'particlesEnabled');
        setupToggle('screenShakeToggle', 'screenShakeValue', 'screenShakeEnabled');
        setupToggle('damageNumbersToggle', 'damageNumbersValue', 'damageNumbersEnabled');
        setupToggle('fpsToggle', 'fpsValue', 'showFPS');

        document.getElementById('volumeSlider').addEventListener('input', (e) => {
            document.getElementById('volumeValue').textContent = e.target.value + '%';
        });

        document.getElementById('musicSlider').addEventListener('input', (e) => {
            document.getElementById('musicValue').textContent = e.target.value + '%';
        });

        document.getElementById('sfxSlider').addEventListener('input', (e) => {
            document.getElementById('sfxValue').textContent = e.target.value + '%';
        });
        
        // Game over buttons
        document.getElementById('playAgainBtn').addEventListener('click', () => {
            mythicMode = false; // Reset mythic mode
            player = new Player(100, 300);
            currentRoom = new Room(1);
            roomNumber = 1;
            particles = [];
            projectiles = [];
            shadowClones = [];
            gameStarted = true;
            gameOver = false;
            document.getElementById('gameOverScreen').style.display = 'none';
        });
        
        document.getElementById('loadCheckpointBtn').addEventListener('click', () => {
            // Try to load saved checkpoint
            const saved = localStorage.getItem('shadowAssassinCheckpoint');
            if (saved) {
                const checkpoint = JSON.parse(saved);
                
                mythicMode = checkpoint.mythicMode || false;
                player = new Player(100, 300);
                player.health = checkpoint.health;
                player.maxHealth = checkpoint.maxHealth;
                player.upgrades = checkpoint.upgrades;
                
                // Restore special abilities
                player.special1 = checkpoint.special1;
                player.special2 = checkpoint.special2;
                player.hasDoubleJump = checkpoint.hasDoubleJump;
                
                roomNumber = checkpoint.room;
                
                // Determine if returning to safe room or continuing
                const isSafeRoom = (roomNumber % 7 === 0);
                const isBossRoom = (roomNumber % 5 === 0) && !isSafeRoom;
                currentRoom = new Room(roomNumber * 12345, isBossRoom, isSafeRoom);
                
                player.x = 100;
                player.y = canvas.height - 200;
            } else {
                // No checkpoint, just restart
                mythicMode = false;
                player = new Player(100, 300);
                currentRoom = new Room(1);
                roomNumber = 1;
            }
            
            particles = [];
            projectiles = [];
            shadowClones = [];
            gameStarted = true;
            gameOver = false;
            document.getElementById('gameOverScreen').style.display = 'none';
        });
        
        // Safe room continue button
        document.getElementById('safeRoomContinueBtn').addEventListener('click', () => {
            document.getElementById('safeRoomScreen').style.display = 'none';
            showingUpgrade = false;
        });
        
        // Start game loop
        gameLoop();
    </script>
</body>
</html>
