<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Valorant Proto: Multiplayer</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background-color: #0f1923; color: white; user-select: none; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: none; } /* Hidden by default */
        
        /* HUD */
        #top-hud { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); display: flex; gap: 20px; background: rgba(15, 25, 35, 0.8); padding: 5px 30px; border-bottom: 2px solid #ff4655; clip-path: polygon(0 0, 100% 0, 95% 100%, 5% 100%); }
        #timer { font-size: 32px; font-weight: bold; }
        #round-state { font-size: 14px; color: #ff4655; font-weight: bold; padding-top: 10px; }
        
        #crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        .ch-h { position: absolute; width: 14px; height: 2px; background: #00ffaa; top: 50%; left: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 2px black; }
        .ch-v { position: absolute; width: 2px; height: 14px; background: #00ffaa; top: 50%; left: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 2px black; }

        #hud-bottom { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 40px; align-items: flex-end; }
        .hud-val { font-size: 48px; font-weight: bold; text-shadow: 0 2px 4px rgba(0,0,0,0.5); }
        .hud-lbl { font-size: 12px; color: #ccc; letter-spacing: 1px; text-transform: uppercase; }
        #health-val { color: #ff4655; }
        
        /* MENUS COMMON */
        .menu-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #0f1923; z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; }
        .val-btn { padding: 15px 40px; font-size: 18px; background: #ff4655; color: white; border: none; cursor: pointer; font-weight: bold; text-transform: uppercase; transition: 0.2s; margin: 10px; }
        .val-btn:hover { background: #d13644; }
        .val-btn:disabled { background: #555; cursor: not-allowed; }
        .val-input { padding: 12px; font-size: 16px; background: #333; border: 1px solid #555; color: white; margin: 5px; text-align: center; width: 250px; }

        /* LOBBY BROWSER */
        #browser-screen { display: flex; }
        #room-list { width: 500px; height: 300px; background: rgba(0,0,0,0.3); border: 1px solid #444; overflow-y: auto; margin: 20px; padding: 10px; }
        .room-item { background: #1f2b35; padding: 15px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; border-left: 3px solid #ff4655; }
        .room-item:hover { background: #2a3b47; }
        .room-name { font-weight: bold; font-size: 18px; }
        .room-count { color: #aaa; font-size: 14px; }
        .join-btn { padding: 8px 20px; background: #00ffaa; color: #0f1923; border: none; font-weight: bold; cursor: pointer; text-transform: uppercase; }

        /* WAITING ROOM */
        #waiting-screen { display: none; }
        .player-list { display: flex; gap: 20px; margin: 30px; }
        .player-slot { width: 100px; height: 150px; background: #1f2b35; border: 2px solid #333; display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative; }
        .player-slot.host { border-color: #ff4655; }
        .player-slot.me { border-color: #00ffaa; }
        .player-name { margin-top: 10px; font-weight: bold; font-size: 14px; }
        .agent-icon { font-size: 40px; }

        .agent-select-mini { display: flex; gap: 10px; margin-bottom: 20px; }
        .agent-opt { opacity: 0.5; cursor: pointer; border: 2px solid transparent; padding: 5px; }
        .agent-opt.selected { opacity: 1; border-color: #00ffaa; }

        #status-msg { margin-top: 20px; color: #888; font-size: 14px; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; text-align: center; max-width: 80%; }
        h1 { color:#ff4655; margin:0; font-size:60px; font-style:italic; margin-bottom: 10px; }
        h2 { color: white; text-transform: uppercase; letter-spacing: 2px; font-size: 24px; margin-bottom: 20px; }
    </style>

    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "firebase/app": "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js",
                "firebase/firestore": "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js",
                "firebase/auth": "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js"
            }
        }
    </script>
</head>
<body>
    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div id="top-hud">
            <div id="round-state">MATCH LIVE</div>
            <div id="timer">100</div>
        </div>
        <div id="alert-msg">MATCH START</div>
        <div id="crosshair"><div class="ch-h"></div><div class="ch-v"></div></div>
        <div id="hud-bottom">
            <div><div class="hud-val" id="health-val">100</div><div class="hud-lbl">Health</div></div>
            <div><div class="hud-val" id="ammo-val">25</div><div class="hud-lbl">Ammo</div></div>
        </div>
    </div>

    <!-- 1. BROWSER SCREEN -->
    <div id="browser-screen" class="menu-overlay">
        <h1>VALORANT<span style="color:white; font-size:30px;">CLONE</span></h1>
        
        <div style="display:flex; flex-direction:row; gap: 40px; align-items: flex-start;">
            <!-- Create Room -->
            <div style="display:flex; flex-direction:column; align-items:center; background: rgba(255,255,255,0.05); padding: 20px; border-radius: 10px;">
                <h2>Create Lobby</h2>
                <input type="text" id="create-room-name" class="val-input" placeholder="Room Name" value="New Room">
                <input type="text" id="player-name-input" class="val-input" placeholder="Your Username" value="Player 1">
                <button class="val-btn" onclick="createRoom()">Create Room</button>
            </div>

            <!-- Room List -->
            <div style="display:flex; flex-direction:column; align-items:center;">
                <h2>Server Browser</h2>
                <div id="room-list">
                    <div style="text-align:center; padding:20px; color:#888;">Loading rooms...</div>
                </div>
                <button class="val-btn" style="background:#444;" onclick="fetchRooms()">Refresh List</button>
            </div>
        </div>
        <div id="status-msg">Connecting to Firebase...</div>
    </div>

    <!-- 2. WAITING ROOM SCREEN -->
    <div id="waiting-screen" class="menu-overlay">
        <h1 id="lobby-title">LOBBY</h1>
        <h2 style="color:#00ffaa;" id="lobby-status">WAITING FOR PLAYERS...</h2>

        <div style="margin-bottom: 10px; color: #ccc;">SELECT AGENT</div>
        <div class="agent-select-mini">
            <div class="agent-opt selected" onclick="selectAgentInLobby('jett', this)">üí® Jett</div>
            <div class="agent-opt" onclick="selectAgentInLobby('phoenix', this)">üî• Phoenix</div>
            <div class="agent-opt" onclick="selectAgentInLobby('sage', this)">üßä Sage</div>
        </div>

        <div class="player-list" id="lobby-player-list">
            <!-- Populated by JS -->
        </div>

        <button id="host-start-btn" class="val-btn" style="display:none;" onclick="hostStartGame()">START MATCH</button>
        <div id="client-wait-msg" style="color:#888; margin-top:20px;">Waiting for Host to start...</div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { initializeApp } from 'firebase/app';
        import { getFirestore, collection, doc, setDoc, getDoc, updateDoc, onSnapshot, query, where, getDocs, arrayUnion } from 'firebase/firestore';
        import { getAuth, signInAnonymously, onAuthStateChanged } from 'firebase/auth';

        // --- FIREBASE CONFIGURATION ---
        const firebaseConfig = {
            apiKey: "AIzaSyCx72zwsJ-IaVH1N7AnX9lDHgL10eDuNKY",
            authDomain: "valorant-48fd8.firebaseapp.com",
            projectId: "valorant-48fd8",
            storageBucket: "valorant-48fd8.firebasestorage.app",
            messagingSenderId: "462060216514",
            appId: "1:462060216514:web:ca192f3fc7d542b9391b5b",
            measurementId: "G-HD9MC806HG"
        };

        // --- SYSTEM VARIABLES ---
        let db, auth, userId;
        // Generate a random session ID for THIS tab so multiple tabs don't conflict
        const mySessionId = 'sess_' + Math.random().toString(36).substr(2, 9);
        
        let currentLobbyId = null;
        let isHost = false;
        let selectedAgent = 'jett';
        let myUsername = 'Player';
        let remotePlayers = {}; 
        let isPlaying = false;
        let lobbyUnsubscribe = null; // Listener for lobby updates

        const statusEl = document.getElementById('status-msg');

        // --- INIT FIREBASE ---
        async function initFirebase() {
            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        statusEl.innerText = "ONLINE: Connected. Ready to play.";
                        statusEl.style.color = "#00ffaa";
                        fetchRooms(); // Load rooms on connect
                    }
                });

                await signInAnonymously(auth);
            } catch (e) {
                console.error(e);
                statusEl.innerText = "OFFLINE: " + e.message;
                statusEl.style.color = "#ff4655";
            }
        }
        initFirebase();

        // --- GLOBAL FUNCTIONS (Exposed to HTML) ---
        window.fetchRooms = async () => {
            if (!db) return;
            const listDiv = document.getElementById('room-list');
            listDiv.innerHTML = '<div style="text-align:center; color:#888;">Refreshing...</div>';
            
            try {
                const q = query(collection(db, "lobbies"), where("status", "==", "waiting"));
                const querySnapshot = await getDocs(q);
                
                listDiv.innerHTML = ""; // Clear
                if (querySnapshot.empty) {
                    listDiv.innerHTML = '<div style="text-align:center; padding:20px; color:#888;">No rooms found. Create one!</div>';
                    return;
                }

                querySnapshot.forEach((doc) => {
                    const room = doc.data();
                    const roomId = doc.id;
                    const playerCount = room.players ? room.players.length : 0;
                    
                    const item = document.createElement('div');
                    item.className = 'room-item';
                    item.innerHTML = `
                        <div>
                            <div class="room-name">${room.name}</div>
                            <div class="room-count">${playerCount}/10 Players</div>
                        </div>
                        <button class="join-btn" onclick="joinRoom('${roomId}')">JOIN</button>
                    `;
                    listDiv.appendChild(item);
                });
            } catch (e) {
                console.error("Fetch error", e);
                listDiv.innerHTML = '<div style="color:red; text-align:center;">Error fetching rooms. DB might not exist yet.</div>';
            }
        };

        window.createRoom = async () => {
            if (!userId) return alert("Not connected yet!");
            const roomName = document.getElementById('create-room-name').value;
            myUsername = document.getElementById('player-name-input').value || "Host";
            
            const newRoomRef = doc(collection(db, "lobbies"));
            const roomData = {
                name: roomName,
                hostId: userId,
                status: 'waiting',
                createdAt: Date.now(),
                players: [{
                    uid: mySessionId, // Use Session ID for player entry
                    authId: userId,   // Keep auth ID for checks
                    name: myUsername,
                    agent: selectedAgent,
                    isHost: true
                }]
            };

            await setDoc(newRoomRef, roomData);
            enterLobby(newRoomRef.id, true);
        };

        window.joinRoom = async (roomId) => {
            if (!userId) return;
            myUsername = document.getElementById('player-name-input').value || "Guest";
            
            const roomRef = doc(db, "lobbies", roomId);
            
            // Add self to players array
            await updateDoc(roomRef, {
                players: arrayUnion({
                    uid: mySessionId,
                    authId: userId,
                    name: myUsername,
                    agent: selectedAgent,
                    isHost: false
                })
            });

            enterLobby(roomId, false);
        };

        window.selectAgentInLobby = (agent, el) => {
            selectedAgent = agent;
            document.querySelectorAll('.agent-opt').forEach(e => e.classList.remove('selected'));
            el.classList.add('selected');
        };

        window.hostStartGame = async () => {
            if (!currentLobbyId || !isHost) return;
            // Update room status to playing
            const roomRef = doc(db, "lobbies", currentLobbyId);
            await updateDoc(roomRef, { status: 'playing' });
        };

        function enterLobby(roomId, hostStatus) {
            currentLobbyId = roomId;
            isHost = hostStatus;
            
            // Switch Screens
            document.getElementById('browser-screen').style.display = 'none';
            document.getElementById('waiting-screen').style.display = 'flex';
            
            if (isHost) {
                document.getElementById('host-start-btn').style.display = 'block';
                document.getElementById('client-wait-msg').style.display = 'none';
            } else {
                document.getElementById('host-start-btn').style.display = 'none';
                document.getElementById('client-wait-msg').style.display = 'block';
            }

            // Listen to Room Updates
            lobbyUnsubscribe = onSnapshot(doc(db, "lobbies", roomId), (doc) => {
                if (!doc.exists()) return; // Room deleted
                const data = doc.data();
                
                // 1. Update Player List UI
                renderLobbyPlayers(data.players || []);

                // 2. Check for Start
                if (data.status === 'playing' && !isPlaying) {
                    launchGame();
                }
            });
        }

        function renderLobbyPlayers(players) {
            const container = document.getElementById('lobby-player-list');
            container.innerHTML = "";
            
            players.forEach(p => {
                // Check using session ID for "me"
                const el = document.createElement('div');
                el.className = `player-slot ${p.isHost ? 'host' : ''} ${p.uid === mySessionId ? 'me' : ''}`;
                
                let icon = '‚ùì';
                if (p.agent === 'jett') icon = 'üí®';
                if (p.agent === 'phoenix') icon = 'üî•';
                if (p.agent === 'sage') icon = 'üßä';
                
                el.innerHTML = `
                    <div class="agent-icon">${icon}</div>
                    <div class="player-name">${p.name}</div>
                `;
                container.appendChild(el);
            });
        }

        function launchGame() {
            // Cleanup UI
            document.getElementById('waiting-screen').style.display = 'none';
            document.getElementById('ui-layer').style.display = 'block'; // Show HUD
            
            isPlaying = true;
            create3DScene();
            initGameMultiplayer(); // Start syncing positions
        }

        // --- 3D GAME ENGINE (THREE.JS) ---
        const MOVEMENT_SPEED = 10.0;
        const JUMP_FORCE = 12.0;
        const GRAVITY = 30.0;
        const PLAYER_HEIGHT = 1.6;
        const PLAYER_RADIUS = 0.5;

        const agents = {
            'jett': { color: 0xaaccff },
            'phoenix': { color: 0xffaa00 },
            'sage': { color: 0x00ffaa }
        };

        let camera, scene, renderer, controls;
        let walls = [];

        function create3DScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 10, 60);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 100, -50);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            controls = new PointerLockControls(camera, document.body);
            
            // Map
            createMap();
            
            // Gun Model
            const gun = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.15, 0.5), new THREE.MeshStandardMaterial({color:0x333333}));
            gun.position.set(0.2, -0.2, -0.4);
            camera.add(gun);
            scene.add(camera);

            // Spawn
            camera.position.set(-30, 2, 0);
            camera.lookAt(0, 2, 0);

            // Click to lock
            document.addEventListener('click', () => {
                if(isPlaying) controls.lock();
            });

            animate();
        }

        function createBox(x, y, z, w, h, d, color) {
            const geo = new THREE.BoxGeometry(w, h, d);
            const mat = new THREE.MeshStandardMaterial({ color: color });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, y + h/2, z); 
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.geometry.computeBoundingBox();
            scene.add(mesh);
            walls.push(mesh);
        }

        function createMap() {
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), new THREE.MeshStandardMaterial({ color: 0x444444 }));
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);
            
            const C_WALL = 0xd6cba8; 
            const C_BOX = 0x2e4a3d;

            // Simple Layout
            createBox(-35, 0, 5, 30, 6, 1, C_WALL);
            createBox(-35, 0, -5, 30, 6, 1, C_WALL);
            createBox(0, 0, -20, 40, 8, 1, C_WALL); 
            createBox(0, 0, 20, 40, 8, 1, C_WALL);
            createBox(20, 0, 0, 1, 8, 40, C_WALL); 
            createBox(-5, 0, 0, 3, 3, 3, C_BOX);
            createBox(10, 0, -10, 8, 4, 8, C_WALL); 
            createBox(5, 0, 15, 10, 2, 8, C_WALL); 
        }

        // --- GAMEPLAY MULTIPLAYER LOGIC ---
        function initGameMultiplayer() {
            // Collection: valorant_game_data
            // We filter by currentLobbyId so we only see players in THIS room
            const playersRef = collection(db, 'valorant_game_data');
            const q = query(playersRef, where("lobbyId", "==", currentLobbyId));
            
            onSnapshot(q, (snapshot) => {
                snapshot.docChanges().forEach((change) => {
                    const data = change.doc.data();
                    const pid = change.doc.id;
                    
                    // Filter out SELF by Session ID
                    if (pid === mySessionId) return; 

                    if (change.type === "added" || change.type === "modified") {
                        updateRemotePlayer(pid, data);
                    }
                    if (change.type === "removed") {
                        removeRemotePlayer(pid);
                    }
                });
            });

            setInterval(broadcastPosition, 50); // Faster updates
            
            window.addEventListener('beforeunload', () => {
               deleteDoc(doc(db, 'valorant_game_data', mySessionId));
            });
        }

        function broadcastPosition() {
            if (!isPlaying || !userId) return;
            // Write to a doc named after SESSION ID, not User ID
            const myDoc = doc(db, 'valorant_game_data', mySessionId);
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            const yaw = Math.atan2(dir.x, dir.z);

            setDoc(myDoc, {
                lobbyId: currentLobbyId,
                x: camera.position.x,
                y: camera.position.y,
                z: camera.position.z,
                yaw: yaw,
                agent: selectedAgent,
                lastUpdate: Date.now()
            }, { merge: true });
        }

        function updateRemotePlayer(id, data) {
            if (!remotePlayers[id]) {
                const group = new THREE.Group();
                const color = agents[data.agent] ? agents[data.agent].color : 0xffffff;
                const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.4, 1.6, 4, 8), new THREE.MeshStandardMaterial({ color: color }));
                body.position.y = 0.8;
                group.add(body);
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.3), new THREE.MeshStandardMaterial({color: 0xffffff}));
                head.position.y = 1.6;
                group.add(head);
                scene.add(group);
                remotePlayers[id] = group;
            }
            const p = remotePlayers[id];
            // Lerp could be added here for smoothness
            p.position.set(data.x, data.y - 1.6, data.z); 
            p.rotation.y = data.yaw;
        }

        function removeRemotePlayer(id) {
            if (remotePlayers[id]) {
                scene.remove(remotePlayers[id]);
                delete remotePlayers[id];
            }
        }

        // --- PHYSICS & LOOP ---
        const keys = { w: false, a: false, s: false, d: false, space: false };
        document.addEventListener('keydown', (e) => {
            if(e.code==='KeyW') keys.w=true; if(e.code==='KeyA') keys.a=true;
            if(e.code==='KeyS') keys.s=true; if(e.code==='KeyD') keys.d=true;
            if(e.code==='Space') keys.space=true;
        });
        document.addEventListener('keyup', (e) => {
            if(e.code==='KeyW') keys.w=false; if(e.code==='KeyA') keys.a=false;
            if(e.code==='KeyS') keys.s=false; if(e.code==='KeyD') keys.d=false;
            if(e.code==='Space') keys.space=false;
        });

        const playerBox = new THREE.Box3();
        function checkCollision(position) {
            const min = new THREE.Vector3(position.x - PLAYER_RADIUS, position.y - 1.5, position.z - PLAYER_RADIUS);
            const max = new THREE.Vector3(position.x + PLAYER_RADIUS, position.y + 0.5, position.z + PLAYER_RADIUS);
            playerBox.set(min, max);
            for (const wall of walls) {
                const wallBox = new THREE.Box3().setFromObject(wall);
                if (playerBox.intersectsBox(wallBox)) return true;
            }
            return false;
        }

        let prevTime = performance.now();
        let velocityY = 0;

        function animate() {
            requestAnimationFrame(animate);
            if (!isPlaying || !controls.isLocked) return;

            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            prevTime = time;

            const moveSpeed = MOVEMENT_SPEED * delta;
            const camDir = new THREE.Vector3();
            camera.getWorldDirection(camDir);
            camDir.y = 0; camDir.normalize();
            const camRight = new THREE.Vector3();
            camRight.crossVectors(camDir, new THREE.Vector3(0, 1, 0));
            camRight.normalize();

            const moveVec = new THREE.Vector3(0, 0, 0);
            if (keys.w) moveVec.add(camDir);
            if (keys.s) moveVec.sub(camDir);
            if (keys.d) moveVec.add(camRight);
            if (keys.a) moveVec.sub(camRight);

            if (moveVec.length() > 0) moveVec.normalize().multiplyScalar(moveSpeed);

            // Physics X
            const candidatePos = camera.position.clone();
            candidatePos.x += moveVec.x;
            if (!checkCollision(candidatePos)) camera.position.x += moveVec.x;

            // Physics Z
            candidatePos.copy(camera.position); 
            candidatePos.z += moveVec.z;
            if (!checkCollision(candidatePos)) camera.position.z += moveVec.z;

            // Gravity
            if (keys.space && camera.position.y <= PLAYER_HEIGHT + 0.1) velocityY = JUMP_FORCE;
            velocityY -= GRAVITY * delta;
            camera.position.y += velocityY * delta;
            if (camera.position.y < PLAYER_HEIGHT) {
                camera.position.y = PLAYER_HEIGHT;
                velocityY = 0;
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            if(camera) {
                camera.aspect = window.innerWidth/window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });
    </script>
</body>
</html>
