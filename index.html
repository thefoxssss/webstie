<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>GOONER TERMINAL V3 [MULTI]</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

<style>
    :root {
        --bg: #050505;
        --scanline: rgba(18, 16, 16, 0.5);
        --accent: #ff0606;
        --accent-dim: rgba(255, 6, 6, 0.2);
        --accent-glow: rgba(255, 6, 6, 0.6);
        --text: #ff3333;
    }

    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    
    html, body {
        height: 100%;
        margin: 0;
        background-color: var(--bg);
        font-family: "Press Start 2P", monospace;
        overflow: hidden;
        color: var(--accent);
        user-select: none;
        touch-action: none;
    }

    /* CRT Scanline Effect */
    body::before {
        content: " ";
        display: block;
        position: absolute;
        top: 0; left: 0; bottom: 0; right: 0;
        background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
        z-index: 99999;
        background-size: 100% 2px, 3px 100%;
        pointer-events: none;
        animation: flicker 0.15s infinite;
    }
    
    body::after {
        content: " ";
        display: block;
        position: absolute;
        top: 0; left: 0; bottom: 0; right: 0;
        background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,0,0,0.8) 100%);
        z-index: 99999;
        pointer-events: none;
    }

    @keyframes flicker {
        0% { opacity: 0.95; }
        50% { opacity: 0.85; }
        100% { opacity: 0.98; }
    }

    /* Main Layout */
    .wrap {
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        position: relative;
        z-index: 10;
        padding: 20px;
        width: 100%;
    }

    /* Top Right Menu */
    .top-menu {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 2000;
    }

    .menu-btn {
        background-color: rgba(0, 0, 0, 0.9);
        color: var(--accent);
        padding: 12px 20px;
        font-family: "Press Start 2P", monospace;
        font-size: 12px;
        border: 2px solid var(--accent);
        cursor: pointer;
        text-transform: uppercase;
        box-shadow: 0 0 10px var(--accent-dim);
        transition: 0.2s;
    }

    .menu-btn:hover {
        background-color: var(--accent-dim);
        box-shadow: 0 0 15px var(--accent-glow);
    }

    .dropdown-content {
        display: none;
        position: absolute;
        right: 0;
        top: 100%;
        background-color: #000;
        min-width: 200px;
        border: 2px solid var(--accent);
        border-top: none;
        box-shadow: 0 8px 16px rgba(0,0,0,0.5);
        z-index: 2001;
    }

    .dropdown-content.show { display: block; }

    .dropdown-content button {
        background: transparent;
        color: var(--accent);
        padding: 15px;
        display: block;
        width: 100%;
        text-align: left;
        border: none;
        border-bottom: 1px solid rgba(255, 6, 6, 0.2);
        font-family: "Press Start 2P", monospace;
        font-size: 10px;
        cursor: pointer;
        transition: 0.2s;
    }

    .dropdown-content button:hover {
        background-color: var(--accent);
        color: #000;
    }

    /* The Big Button */
    .gooner-btn {
        font-size: clamp(24px, 8vw, 72px);
        color: var(--accent);
        cursor: pointer;
        padding: 30px 40px;
        border: 4px solid var(--accent);
        background: rgba(0, 0, 0, 0.8);
        box-shadow: 0 0 15px var(--accent-dim), inset 0 0 20px var(--accent-dim);
        text-shadow: 0 0 10px var(--accent);
        transition: all 0.2s ease;
        position: relative;
        overflow: hidden;
        margin-bottom: 40px;
        text-transform: uppercase;
        z-index: 20;
    }

    .gooner-btn:hover {
        transform: scale(1.05);
        box-shadow: 0 0 30px var(--accent-glow), inset 0 0 30px var(--accent-glow);
        background: var(--accent);
        color: #000;
        text-shadow: none;
    }
    
    .gooner-btn:active { transform: scale(0.95); }

    .subtitle {
        color: var(--accent);
        font-size: 10px;
        opacity: 0.7;
        margin-top: -20px;
        text-transform: uppercase;
        letter-spacing: 2px;
        text-align: center;
    }

    /* Overlays (General) */
    .overlay {
        position: fixed;
        inset: 0;
        background: #000;
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        overflow: hidden;
    }
    
    .overlay.active { display: flex; }

    .overlay h1 {
        font-size: clamp(20px, 5vw, 40px);
        margin-bottom: 20px;
        text-shadow: 2px 2px 0px #4a0000;
        text-align: center;
    }

    .close-btn {
        position: absolute;
        top: 20px;
        right: 20px;
        background: transparent;
        border: 2px solid var(--accent);
        color: var(--accent);
        padding: 8px 12px;
        font-family: inherit;
        font-size: 12px;
        cursor: pointer;
        z-index: 1001;
        transition: 0.2s;
    }
    
    .close-btn:hover { background: var(--accent); color: #000; }

    /* Game Canvas Styles */
    canvas {
        border: 4px solid var(--accent);
        background: #000;
        box-shadow: 0 0 20px rgba(255, 6, 6, 0.2);
        max-width: 95vw;
        max-height: 70vh;
        image-rendering: pixelated;
    }

    /* Mobile Controls */
    .touch-controls {
        display: none;
        margin-top: 20px;
        gap: 10px;
        user-select: none;
    }
    
    .touch-controls.active {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        grid-gap: 10px;
    }

    .touch-btn {
        width: 50px;
        height: 50px;
        border: 2px solid var(--accent);
        color: var(--accent);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        background: rgba(255, 6, 6, 0.1);
        border-radius: 8px;
        cursor: pointer;
    }
    
    .touch-btn:active { background: var(--accent); color: #000; }

    .mobile-hint {
        display: none;
        font-size: 10px;
        color: #ff8888;
        margin-bottom: 10px;
        text-align: center;
    }
    
    .mobile-hint.active { display: block; }
    
    @media (pointer: coarse) {
        .touch-controls.active { display: grid; }
        .mobile-hint.active { display: block; }
    }

    /* Secret Visuals */
    .glitch-text {
        position: fixed;
        font-size: 14px;
        opacity: 0.8;
        pointer-events: none;
        font-weight: bold;
        z-index: 5;
    }
    
    .version-tag {
        position: fixed;
        top: 10px;
        left: 10px;
        font-size: 10px;
        color: rgba(255, 6, 6, 0.4);
        z-index: 1002;
    }

    /* --- TIC TAC TOE STYLES --- */
    .ttt-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
    }

    .menu-box {
        background: rgba(20,0,0,0.8);
        border: 2px solid var(--accent);
        padding: 20px;
        display: flex;
        flex-direction: column;
        gap: 15px;
        text-align: center;
        min-width: 300px;
    }

    .term-input {
        background: transparent;
        border: 2px solid var(--accent);
        color: var(--accent);
        padding: 10px;
        font-family: inherit;
        text-align: center;
        text-transform: uppercase;
        font-size: 16px;
    }

    .term-btn {
        background: var(--accent);
        color: black;
        border: none;
        padding: 12px;
        font-family: inherit;
        cursor: pointer;
        font-weight: bold;
    }

    .term-btn:hover { opacity: 0.8; }
    .term-btn:disabled { opacity: 0.3; cursor: not-allowed; }

    .ttt-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 5px;
        background: var(--accent);
        border: 5px solid var(--accent);
        margin-top: 10px;
    }

    .ttt-cell {
        width: 80px;
        height: 80px;
        background: black;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 40px;
        cursor: pointer;
        user-select: none;
    }

    .ttt-cell:active { background: #110000; }
    .ttt-status { font-size: 12px; margin-bottom: 10px; text-align: center; min-height: 20px; }
    .ttt-room-code { font-size: 24px; letter-spacing: 5px; margin: 10px 0; color: #fff; }

    /* --- BLACKJACK STYLES --- */
    .bj-table {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
        max-width: 600px;
        gap: 10px;
    }

    .bj-area {
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100px;
        width: 100%;
        border: 1px dashed var(--accent-dim);
        padding: 5px;
        position: relative;
    }
    
    /* New side area for other players */
    .bj-side-table {
        display: flex;
        gap: 10px;
        width: 100%;
        justify-content: center;
        margin: 5px 0;
    }
    
    .bj-small-seat {
        border: 1px dotted var(--accent-dim);
        padding: 5px;
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 30%;
        min-height: 60px;
    }
    
    .bj-small-hand {
        display: flex;
        gap: 2px;
        margin-top: 5px;
        flex-wrap: wrap;
        justify-content: center;
    }
    
    /* Active Turn Indicator */
    .active-seat {
        border: 2px solid yellow !important;
        box-shadow: 0 0 10px yellow;
    }

    .bj-label {
        position: absolute;
        top: -10px;
        background: #000;
        padding: 0 10px;
        font-size: 8px;
        color: var(--accent);
    }

    .bj-hand {
        display: flex;
        gap: 10px;
        margin-top: 10px;
        flex-wrap: wrap;
        justify-content: center;
        min-height: 80px;
    }

    @keyframes flyIn {
        0% { transform: translateY(-200px) rotate(10deg) scale(1.5); opacity: 0; }
        100% { transform: translateY(0) rotate(0) scale(1); opacity: 1; }
    }
    
    @keyframes fall {
        0% { transform: translateY(-100px) rotate(0deg); opacity: 1; }
        100% { transform: translateY(110vh) rotate(360deg); opacity: 0; }
    }

    .bj-card {
        width: 50px;
        height: 70px;
        border: 2px solid var(--accent);
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        padding: 4px;
        font-size: 12px;
        background: #000;
        box-shadow: 2px 2px 0px var(--accent-dim);
        user-select: none;
        animation: flyIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        position: relative;
    }
    
    /* Smaller cards for opponents */
    .bj-card.mini {
        width: 30px;
        height: 42px;
        font-size: 8px;
        border: 1px solid var(--accent);
    }
    
    .bj-card.hidden {
        background: repeating-linear-gradient(45deg, #000, #000 5px, var(--accent-dim) 5px, var(--accent-dim) 10px);
        justify-content: center;
        align-items: center;
    }

    .bj-score { margin-top: 5px; font-size: 10px; }
    .bj-controls { display: flex; gap: 20px; margin-top: 10px; }
    .bj-message { font-size: 12px; min-height: 20px; color: #fff; text-align: center; text-shadow: 0 0 5px var(--accent); }
    
    .bj-deck-container {
        width: 60px;
        height: 84px;
        border: 2px dashed var(--accent-dim);
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        margin: 5px;
        position: relative;
        transition: transform 0.1s;
    }
    .bj-deck-container:active { transform: scale(0.95); }
    
    .bj-deck-card {
        position: absolute;
        width: 45px;
        height: 63px;
        background: repeating-linear-gradient(45deg, #000, #000 5px, var(--accent) 5px, var(--accent) 6px);
        border: 2px solid var(--accent);
        box-shadow: -2px 2px 0px var(--accent-dim);
        top: 8px; left: 6px;
    }
    .bj-deck-card:nth-child(2) { top: 4px; left: 4px; }
    .bj-deck-card:nth-child(3) { top: 0px; left: 2px; }
    
    .bj-chip-rack {
        display: flex;
        gap: 10px;
        margin-top: 10px;
        justify-content: center;
        flex-wrap: wrap;
    }
    .bj-chip {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        border: 2px solid var(--accent);
        background: #000;
        color: var(--accent);
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 9px;
        cursor: pointer;
        box-shadow: 0 0 10px var(--accent-dim), inset 0 0 5px rgba(0,0,0,0.5);
        user-select: none;
        transition: all 0.2s;
        font-weight: bold;
    }
    .bj-chip:hover { 
        background: var(--accent); color: #000; 
        transform: translateY(-5px) scale(1.1); 
        box-shadow: 0 10px 15px var(--accent-dim);
    }
    
    .bj-all-in { width: auto; padding: 0 10px; border-radius: 20px; border-color: #ffcc00; color: #ffcc00; }
    .bj-bet-display { font-size: 14px; color: #fff; margin: 5px 0; text-align: center; text-shadow: 0 0 5px var(--accent); }

    /* Falling Cards Animation */
    .falling-card {
        position: fixed;
        width: 40px;
        height: 56px;
        background: repeating-linear-gradient(45deg, #000, #000 5px, var(--accent) 5px, var(--accent) 8px);
        border: 2px solid var(--accent);
        z-index: 9998;
        pointer-events: none;
        top: -60px;
    }

    ::-webkit-scrollbar { width: 8px; }
    ::-webkit-scrollbar-track { background: #111; }
    ::-webkit-scrollbar-thumb { background: #500; }
    ::-webkit-scrollbar-thumb:hover { background: #f00; }

    @media (max-width: 768px) {
        h1 { font-size: 24px; }
        .ttt-cell { width: 60px; height: 60px; font-size: 30px; }
        .bj-card { width: 40px; height: 56px; font-size: 10px; }
        .bj-deck-container { display: none; }
    }
</style>
</head>
<body>

<div class="version-tag">SYS.V.25.4 // NET_MULTI_4</div>
<div id="glitchContainer"></div>

<div class="top-menu">
    <button class="menu-btn" id="menuToggle">GAMES ▼</button>
    <div class="dropdown-content" id="menuDropdown">
        <button data-game-trigger="pong">PONG</button>
        <button data-game-trigger="snake">SNAKE</button>
        <button data-game-trigger="runner">RUNNER</button>
        <button data-game-trigger="blackjack" style="border-top: 2px solid var(--accent);">BLACKJACK</button>
        <button data-game-trigger="ttt">TIC TAC TOE</button>
    </div>
</div>

<div class="wrap">
    <div class="gooner-btn" id="mainBtn">GOONER</div>
    <div class="subtitle">SELECT GAME FROM MENU ↗</div>
</div>

<div class="overlay" id="overlayPong">
    <button class="close-btn" data-close="overlayPong">ABORT</button>
    <h1>PONG</h1>
    <div style="margin-bottom:10px; font-size:12px;" id="pongScore">0 : 0</div>
    <canvas id="pongCanvas" width="800" height="600"></canvas>
    
    <div style="margin-top:10px;">
        <button class="close-btn" style="position:static; display:inline-block;" onclick="window.setPongDiff('easy')">EASY</button>
        <button class="close-btn" style="position:static; display:inline-block;" onclick="window.setPongDiff('hard')">HARD</button>
    </div>

    <div class="mobile-hint" id="pongHint">TAP ARROWS TO MOVE</div>
    <div class="touch-controls" id="pongControls">
        <div></div>
        <div class="touch-btn" data-key="up">▲</div>
        <div></div>
        <div></div>
        <div></div>
        <div></div>
        <div></div>
        <div class="touch-btn" data-key="down">▼</div>
        <div></div>
    </div>
</div>

<div class="overlay" id="overlaySnake">
    <button class="close-btn" data-close="overlaySnake">ABORT</button>
    <h1>SNAKE</h1>
    <div style="margin-bottom:10px; font-size:12px;">SCORE: <span id="snakeScoreVal">0</span></div>
    <canvas id="snakeCanvas" width="600" height="400"></canvas>
    <div class="mobile-hint active" id="snakeHint">USE ARROW KEYS OR WASD</div>
    
    <div class="touch-controls active" id="snakeControls" style="margin-top:20px;">
        <div></div>
        <div class="touch-btn" data-snake-key="up">▲</div>
        <div></div>
        <div class="touch-btn" data-snake-key="left">◀</div>
        <div class="touch-btn" data-snake-key="down">▼</div>
        <div class="touch-btn" data-snake-key="right">▶</div>
    </div>
</div>

<div class="overlay" id="overlayRunner">
    <button class="close-btn" data-close="overlayRunner">ABORT</button>
    <h1>RUNNER</h1>
    <div style="margin-bottom:10px; font-size:12px;" id="runnerScoreBoard">SCORE: 0</div>
    <canvas id="runnerCanvas" width="800" height="400"></canvas>
    <div class="mobile-hint active" style="margin-top:10px;">TAP TO JUMP / SWIPE TO SWITCH LANES</div>
</div>

<div class="overlay" id="overlayTTT">
    <button class="close-btn" data-close="overlayTTT">DISCONNECT</button>
    <h1>TIC TAC TOE</h1>
    
    <div id="tttMenu" class="ttt-container">
        <div class="menu-box">
            <p>MULTIPLAYER LOBBY</p>
            <button class="term-btn" id="btnCreateRoom">CREATE ROOM</button>
            <p>- OR -</p>
            <input type="text" id="joinRoomCode" class="term-input" placeholder="4-DIGIT CODE" maxlength="4">
            <button class="term-btn" id="btnJoinRoom">JOIN ROOM</button>
        </div>
        <div style="font-size:10px; max-width:320px; text-align:center; line-height:1.5;">
            STATUS: <span id="authStatus" style="color:yellow;">CONNECTING...</span>
        </div>
    </div>

    <div id="tttGame" class="ttt-container" style="display:none;">
        <div class="ttt-status" id="tttStatus">WAITING FOR OPPONENT...</div>
        <div class="ttt-room-code" id="displayRoomCode">????</div>
        
        <div class="ttt-grid" id="tttGrid">
            <div class="ttt-cell" data-idx="0"></div>
            <div class="ttt-cell" data-idx="1"></div>
            <div class="ttt-cell" data-idx="2"></div>
            <div class="ttt-cell" data-idx="3"></div>
            <div class="ttt-cell" data-idx="4"></div>
            <div class="ttt-cell" data-idx="5"></div>
            <div class="ttt-cell" data-idx="6"></div>
            <div class="ttt-cell" data-idx="7"></div>
            <div class="ttt-cell" data-idx="8"></div>
        </div>
        
        <button class="term-btn" id="tttReset" style="display:none; margin-top:20px;">PLAY AGAIN</button>
    </div>
</div>

<div class="overlay" id="overlayBlackjack">
    <button class="close-btn" data-close="overlayBlackjack">ABORT</button>
    <h1>BLACKJACK</h1>
    
    <div id="bjModeSelect" class="menu-box">
        <p>SELECT MODE</p>
        <button class="term-btn" onclick="window.selectBjMode('solo')">SOLO RUN (VS AI)</button>
        <button class="term-btn" onclick="window.selectBjMode('multi')">NET RUN (4 PLAYER)</button>
    </div>

    <div id="bjLobby" class="menu-box" style="display:none;">
        <p>NET RUN LOBBY</p>
        <button class="term-btn" id="btnBjCreate">CREATE TABLE</button>
        <p>- OR -</p>
        <input type="text" id="joinBjCode" class="term-input" placeholder="CODE" maxlength="4">
        <button class="term-btn" id="btnBjJoin">JOIN TABLE</button>
    </div>

    <div id="bjTable" class="bj-table" style="display:none;">
        <div class="bj-area" id="bjSeat0">
            <span class="bj-label">DEALER (HOST)</span>
            <div class="bj-hand" id="bjDealerHand"></div>
            <div class="bj-score" id="bjDealerScore"></div>
        </div>

        <div class="bj-side-table" id="bjOtherPlayers">
            </div>
        
        <div style="display:flex; align-items:center; justify-content:center; gap:10px; margin: 5px 0;">
            <div class="bj-deck-container" id="bjDeck">
                <div class="bj-deck-card"></div>
                <div class="bj-deck-card"></div>
                <div class="bj-deck-card"></div>
                <div style="position:absolute; z-index:10; font-size:10px; background:#000; padding:4px;">DEAL</div>
            </div>
            <div class="bj-message" id="bjMessage">PLACE BET & CLICK DECK</div>
        </div>

        <div class="bj-area" id="bjMySeat">
            <span class="bj-label">YOU</span>
            <div class="bj-hand" id="bjPlayerHand"></div>
            <div class="bj-score" id="bjPlayerScore"></div>
        </div>
        
        <div class="bj-controls" id="bjGameControls" style="display:none;">
            <button class="term-btn" id="btnBjHit">HIT</button>
            <button class="term-btn" id="btnBjStand">STAND</button>
        </div>
        
        <div id="bjBettingControls">
            <div class="bj-bet-display">BET: $<span id="bjCurrentBet">0</span></div>
            <div class="bj-chip-rack">
                <div class="bj-chip" data-val="10">10</div>
                <div class="bj-chip" data-val="50">50</div>
                <div class="bj-chip" data-val="100">100</div>
                <div class="bj-chip bj-all-in" id="btnBjAllIn">ALL</div>
                <div class="bj-chip" id="btnBjClear" style="border-color:#fff; color:#fff;">CLR</div>
            </div>
        </div>
        
        <div style="font-size:10px; margin-top:10px;">BANK: $<span id="bjBalance">1000</span></div>
    </div>
</div>

<div class="overlay" id="modalGameOver" style="background:rgba(0,0,0,0.9); z-index:2000;">
    <h1 style="color:red; font-size:40px;">GAME OVER</h1>
    <p id="gameOverText" style="margin-bottom:20px; color:#fff;">SCORE: 0</p>
    <button class="gooner-btn" style="font-size:20px; padding:15px;" id="btnRestart">RESTART</button>
    <button class="close-btn" style="position:static; margin-top:20px;" id="btnExitGame">EXIT</button>
</div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
    import { getFirestore, collection, doc, setDoc, getDoc, updateDoc, onSnapshot, runTransaction } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

    // --- FIREBASE CONFIG ---
    const firebaseConfig = {
        apiKey: "AIzaSyAoXwDA6KtqSD4yfGprus8C8Mi_--1KwSw",
        authDomain: "funnys-18ff7.firebaseapp.com",
        projectId: "funnys-18ff7",
        storageBucket: "funnys-18ff7.firebasestorage.app",
        messagingSenderId: "368675604960",
        appId: "1:368675604960:web:24c5dcd6a5329c9fd94385",
        measurementId: "G-6PE47RLP8V"
    };
    
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    
    /* CORE */
    const mainBtn = document.getElementById('mainBtn');
    let currentGame = null; 
    let myUid = null;

    // Sound
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    function beep(freq=440, type='square', dur=0.1) {
        if(audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + dur);
    }

    // Auth
    const initAuth = async () => { try { await signInAnonymously(auth); } catch(e) { console.error(e); } };
    initAuth();
    onAuthStateChanged(auth, (user) => { 
        if (user) {
            myUid = user.uid;
            document.getElementById('authStatus').innerText = "ONLINE";
            document.getElementById('authStatus').style.color = "#0f0";
        }
    });

    /* VISUALS */
    const menuToggle = document.getElementById('menuToggle');
    const menuDropdown = document.getElementById('menuDropdown');
    menuToggle.addEventListener('click', (e) => { e.stopPropagation(); menuDropdown.classList.toggle('show'); });
    document.addEventListener('click', (e) => { if (!menuToggle.contains(e.target) && !menuDropdown.contains(e.target)) menuDropdown.classList.remove('show'); });

    document.querySelectorAll('[data-game-trigger]').forEach(btn => {
        btn.addEventListener('click', () => {
            const game = btn.dataset.gameTrigger;
            menuDropdown.classList.remove('show'); 
            if (game === 'pong') launchOverlay('overlayPong', initPong);
            else if (game === 'snake') launchOverlay('overlaySnake', initSnake);
            else if (game === 'runner') launchOverlay('overlayRunner', initRunner);
            else if (game === 'ttt') launchOverlay('overlayTTT', initTTT);
            else if (game === 'blackjack') launchOverlay('overlayBlackjack', initBlackjack);
        });
    });

    mainBtn.addEventListener('click', () => {
        beep(100, 'sawtooth', 0.3);
        const stamps = ['GOON', 'CODE', 'HACK', 'SYS', 'TERM'];
        const el = document.createElement('div');
        el.className = 'glitch-text';
        el.textContent = stamps[Math.floor(Math.random()*stamps.length)];
        el.style.left = Math.random() * (window.innerWidth - 50) + 'px';
        el.style.top = Math.random() * (window.innerHeight - 20) + 'px';
        el.style.color = Math.random() > 0.5 ? '#ff0000' : '#ffffff';
        document.body.appendChild(el);
        setTimeout(() => el.remove(), 2000);
    });

    document.querySelectorAll('[data-close]').forEach(btn => {
        btn.addEventListener('click', () => {
            document.getElementById(btn.dataset.close).classList.remove('active');
            stopAllGames();
        });
    });

    function launchOverlay(id, initFunc) { stopAllGames(); document.getElementById(id).classList.add('active'); if (initFunc) initFunc(); }
    function stopAllGames() { stopPong(); stopSnake(); stopRunner(); cleanupTTT(); cleanupBJ(); currentGame = null; }

    /* --- PONG --- */
    let pongAnim, pongCtx, pongCanvas;
    let ball = {x:400, y:300, dx:5, dy:5, r:8}, p1 = {y:250, h:80}, p2 = {y:250, h:80}, pScore=0, aiScore=0, pongDiff=0.08;
    window.setPongDiff = (l) => { pongDiff = l === 'hard' ? 0.15 : 0.08; resetBall(); beep(800, 'square', 0.1); };
    function initPong() { currentGame='pong'; pongCanvas=document.getElementById('pongCanvas'); pongCtx=pongCanvas.getContext('2d'); pScore=0; aiScore=0; resetBall(); loopPong(); }
    function stopPong() { cancelAnimationFrame(pongAnim); }
    function resetBall() { if(!pongCanvas)return; ball.x=400; ball.y=300; ball.dx=(Math.random()>.5?6:-6); ball.dy=(Math.random()*8-4); }
    function loopPong() {
        if(currentGame!=='pong')return;
        pongCtx.fillStyle='rgba(0,0,0,0.2)'; pongCtx.fillRect(0,0,800,600); 
        pongCtx.fillStyle='#f00'; pongCtx.fillRect(20,p1.y,10,p1.h); pongCtx.fillRect(770,p2.y,10,p2.h);
        pongCtx.beginPath(); pongCtx.arc(ball.x,ball.y,8,0,Math.PI*2); pongCtx.fill();
        ball.x+=ball.dx; ball.y+=ball.dy; if(ball.y<0||ball.y>600) ball.dy*=-1;
        if(ball.x<30 && ball.y>p1.y && ball.y<p1.y+p1.h) { ball.dx=Math.abs(ball.dx)+0.5; beep(600); }
        if(ball.x>770 && ball.y>p2.y && ball.y<p2.y+p2.h) { ball.dx=-(Math.abs(ball.dx)+0.5); beep(600); }
        if(ball.x<0) { aiScore++; resetBall(); beep(200,'sawtooth',0.3); } 
        if(ball.x>800) { pScore++; resetBall(); beep(800,'square',0.2); }
        document.getElementById('pongScore').innerText = `${pScore} : ${aiScore}`;
        p2.y += (ball.y-p2.h/2 - p2.y) * pongDiff; p2.y = Math.max(0, Math.min(600-p2.h, p2.y)); p1.y = Math.max(0, Math.min(600-p1.h, p1.y));
        pongAnim=requestAnimationFrame(loopPong);
    }
    document.addEventListener('keydown',e=>{ if(currentGame==='pong'){ if(e.key==='w'||e.key==='ArrowUp')p1.y-=25; if(e.key==='s'||e.key==='ArrowDown')p1.y+=25; }});
    document.querySelectorAll('#pongControls .touch-btn').forEach(b => {
        const handle = (e) => { e.preventDefault(); if(currentGame!=='pong') return; if(b.dataset.key==='up') p1.y-=40; if(b.dataset.key==='down') p1.y+=40; };
        b.addEventListener('click', handle); b.addEventListener('touchstart', handle);
    });

    /* --- SNAKE --- */
    let snakeAnim, snakeCtx, snakeCanvas, snake=[], food={}, sDir='RIGHT', lastProcessedDir='RIGHT', sScore=0;
    function initSnake() { currentGame='snake'; snakeCanvas=document.getElementById('snakeCanvas'); snakeCtx=snakeCanvas.getContext('2d'); snake=[{x:10,y:10}]; sDir='RIGHT'; lastProcessedDir='RIGHT'; sScore=0; document.getElementById('snakeScoreVal').innerText=sScore; placeFood(); loopSnake(); }
    function stopSnake() { clearTimeout(snakeAnim); }
    function placeFood() { food={x:Math.floor(Math.random()*30),y:Math.floor(Math.random()*20)}; }
    function loopSnake() {
        if(currentGame!=='snake')return;
        let h={x:snake[0].x,y:snake[0].y}; if(sDir==='RIGHT')h.x++; if(sDir==='LEFT')h.x--; if(sDir==='UP')h.y--; if(sDir==='DOWN')h.y++; lastProcessedDir=sDir;
        if(h.x<0||h.x>=30||h.y<0||h.y>=20||snake.some(s=>s.x===h.x&&s.y===h.y)) { window.triggerGameOver('snake',sScore); return; }
        snake.unshift(h); if(h.x===food.x&&h.y===food.y) { sScore+=10; document.getElementById('snakeScoreVal').innerText=sScore; placeFood(); beep(600); } else { snake.pop(); }
        snakeCtx.fillStyle='#000'; snakeCtx.fillRect(0,0,600,400); snakeCtx.fillStyle='#f00'; snake.forEach(s=>snakeCtx.fillRect(s.x*20,s.y*20,18,18)); snakeCtx.fillStyle='#fff'; snakeCtx.fillRect(food.x*20,food.y*20,18,18);
        snakeAnim=setTimeout(loopSnake,100);
    }
    const handleSnakeKey = (k) => { if(currentGame!=='snake') return; if((k==='ArrowUp'||k==='w')&&lastProcessedDir!=='DOWN')sDir='UP'; if((k==='ArrowDown'||k==='s')&&lastProcessedDir!=='UP')sDir='DOWN'; if((k==='ArrowLeft'||k==='a')&&lastProcessedDir!=='RIGHT')sDir='LEFT'; if((k==='ArrowRight'||k==='d')&&lastProcessedDir!=='LEFT')sDir='RIGHT'; };
    document.addEventListener('keydown', e => handleSnakeKey(e.key));
    document.querySelectorAll('[data-snake-key]').forEach(b => { const h=(e)=>{e.preventDefault(); let k=b.dataset.snakeKey; if(k==='up')handleSnakeKey('ArrowUp'); if(k==='down')handleSnakeKey('ArrowDown'); if(k==='left')handleSnakeKey('ArrowLeft'); if(k==='right')handleSnakeKey('ArrowRight');}; b.addEventListener('click', h); b.addEventListener('touchstart', h); });

    /* --- RUNNER --- */
    let runAnim, runCtx, runCanvas, runner={lane:1,y:0,jumping:false,jumpH:0}, obstacles=[], rScore=0, runFrame=0;
    function initRunner() { currentGame='runner'; runCanvas=document.getElementById('runnerCanvas'); runCtx=runCanvas.getContext('2d'); runner={lane:1,y:0,jumping:false,jumpH:0}; obstacles=[]; rScore=0; runFrame=0; document.getElementById('runnerScoreBoard').innerText='SCORE: 0'; loopRunner(); }
    function stopRunner() { cancelAnimationFrame(runAnim); }
    function loopRunner() {
        if(currentGame!=='runner')return;
        runFrame++; if(runFrame%100===0) obstacles.push({lane:Math.floor(Math.random()*3),z:100});
        runCtx.fillStyle='#0a0000'; runCtx.fillRect(0,0,800,400);
        runCtx.strokeStyle='#300'; runCtx.lineWidth=2; runCtx.beginPath(); runCtx.moveTo(400,200); runCtx.lineTo(0,400); runCtx.stroke(); runCtx.beginPath(); runCtx.moveTo(400,200); runCtx.lineTo(800,400); runCtx.stroke();
        for(let i=obstacles.length-1;i>=0;i--) {
            let o=obstacles[i]; o.z-=1.5; if(o.z<=0) { obstacles.splice(i,1); rScore++; document.getElementById('runnerScoreBoard').innerText='SCORE: '+rScore; }
            let s=100/(o.z+10), w=50*s, h=50*s, x=400+(o.lane-1)*(400*s)-w/2, y=400-(200*s)-h; runCtx.fillStyle='#f00'; runCtx.fillRect(x,y,w,h);
            if(o.z<10 && o.z>0 && o.lane===runner.lane && runner.jumpH<10) { window.triggerGameOver('runner',rScore); return; }
        }
        if(runner.jumping) { runner.jumpH+=2; if(runner.jumpH>40)runner.jumping=false; } else if(runner.jumpH>0) runner.jumpH-=2;
        let px=400+(runner.lane-1)*200-30, py=300-runner.jumpH-80; runCtx.fillStyle='#0f0'; runCtx.fillRect(px,py,60,80);
        runAnim=requestAnimationFrame(loopRunner);
    }
    document.addEventListener('keydown',e=>{ if(currentGame==='runner'){ if(e.key==='ArrowLeft'&&runner.lane>0)runner.lane--; if(e.key==='ArrowRight'&&runner.lane<2)runner.lane++; if(e.key===' '&&runner.jumpH===0)runner.jumping=true; } });
    document.getElementById('runnerCanvas').addEventListener('click', () => { if(currentGame==='runner' && runner.jumpH===0) runner.jumping=true; });

    /* --------------------------------------------------------
       BLACKJACK SYSTEM (MULTI 4-PLAYER & SOLO)
    -------------------------------------------------------- */
    const suits = ['♠', '♥', '♦', '♣'];
    const values = ['2','3','4','5','6','7','8','9','10','J','Q','K','A'];
    let bjState = 'menu'; 
    let bjMode = 'solo'; 
    let bjDeck = [], bjPlayerHand = [], bjDealerHand = [];
    let bjMoney = 1000;
    let bjCurrentBet = 0;
    let bjRoomCode = null;
    let bjRoomUnsub = null;
    let bjMySeatIdx = -1; // 0=Dealer/Host, 1,2,3=Players

    function initBlackjack() {
        currentGame = 'blackjack';
        bjState = 'menu';
        bjCurrentBet = 0;
        document.getElementById('bjModeSelect').style.display = 'flex';
        document.getElementById('bjLobby').style.display = 'none';
        document.getElementById('bjTable').style.display = 'none';
        document.getElementById('bjGameControls').style.display = 'none';
        updateBjUI();
    }

    function cleanupBJ() {
        if(bjRoomUnsub) bjRoomUnsub();
        bjRoomUnsub = null;
        bjRoomCode = null;
        bjMySeatIdx = -1;
    }

    window.selectBjMode = (mode) => {
        bjMode = mode;
        document.getElementById('bjModeSelect').style.display = 'none';
        if(mode === 'solo') {
            document.getElementById('bjTable').style.display = 'flex';
            document.getElementById('bjOtherPlayers').innerHTML = ''; // Clear side seats
            startSoloBetting();
        } else {
            document.getElementById('bjLobby').style.display = 'flex';
        }
        beep(400, 'square', 0.1);
    };

    function updateBjUI() {
        document.getElementById('bjBalance').innerText = bjMoney;
        document.getElementById('bjCurrentBet').innerText = bjCurrentBet;
    }

    // --- SOLO LOGIC ---
    function startSoloBetting() {
        bjState = 'betting';
        bjPlayerHand = []; bjDealerHand = []; bjCurrentBet = 0;
        document.getElementById('bjDealerHand').innerHTML = '';
        document.getElementById('bjPlayerHand').innerHTML = '';
        document.getElementById('bjDealerScore').innerText = '';
        document.getElementById('bjPlayerScore').innerText = '';
        document.getElementById('bjMessage').innerText = 'PLACE BET & CLICK DECK';
        document.getElementById('bjGameControls').style.display = 'none';
        document.getElementById('bjBettingControls').style.visibility = 'visible';
        document.getElementById('bjDeck').style.pointerEvents = 'auto';
        document.querySelector('#bjDeck div:last-child').innerText = "DEAL";
        updateBjUI();
    }

    async function startSoloRound() {
        if(bjCurrentBet <= 0) return beep(200, 'sawtooth', 0.5);
        bjState = 'playing';
        document.getElementById('bjBettingControls').style.visibility = 'hidden';
        bjDeck = createDeck();
        bjPlayerHand = [bjDeck.pop(), bjDeck.pop()];
        bjDealerHand = [bjDeck.pop(), bjDeck.pop()];
        renderHand(bjPlayerHand, 'bjPlayerHand');
        renderNewCard(bjDealerHand[0], 'bjDealerHand');
        renderNewCard(bjDealerHand[1], 'bjDealerHand', true); // Face down
        updateScore('bjPlayerScore', bjPlayerHand);
        document.getElementById('bjGameControls').style.display = 'flex';
        if(calculateHand(bjPlayerHand) === 21) handleSoloEnd();
    }

    // --- NET ROOMS ---
    function getBjRoomRef(code) { return doc(db, 'gooner_terminal_rooms', 'bj_' + code); }

    document.getElementById('btnBjCreate').addEventListener('click', async () => {
        if(!myUid) return alert("Offline");
        const code = Math.floor(1000 + Math.random()*9000).toString();
        // Initialize 4 Seats. Index 0 = Dealer/Host.
        const seats = [
            { uid: myUid, role: 'host', hand: [], status: 'waiting', bet: 0, ready: false },
            null, null, null
        ];
        
        await setDoc(getBjRoomRef(code), {
            seats: seats,
            deck: [], 
            phase: 'lobby', // lobby -> betting -> playing -> resolution
            activeSeat: 1, // Start with seat 1
        });
        joinBjRoom(code, 0);
    });

    document.getElementById('btnBjJoin').addEventListener('click', async () => {
        const code = document.getElementById('joinBjCode').value;
        const ref = getBjRoomRef(code);
        
        await runTransaction(db, async(t) => {
            const snap = await t.get(ref);
            if(!snap.exists()) throw "Room 404";
            const data = snap.data();
            
            // Find empty seat (1, 2, or 3)
            let seatIdx = -1;
            for(let i=1; i<4; i++) {
                if(data.seats[i] === null) { seatIdx = i; break; }
            }
            if(seatIdx === -1) throw "Room Full";

            const newSeats = [...data.seats];
            newSeats[seatIdx] = { uid: myUid, role: 'player', hand: [], status: 'waiting', bet: 0, ready: false };
            
            t.update(ref, { seats: newSeats });
            joinBjRoom(code, seatIdx);
        }).catch(e => alert(e));
    });

    function joinBjRoom(code, seatIdx) {
        bjRoomCode = code;
        bjMySeatIdx = seatIdx;
        
        document.getElementById('bjLobby').style.display = 'none';
        document.getElementById('bjTable').style.display = 'flex';
        
        // Clean start
        document.getElementById('bjDealerHand').innerHTML = '';
        document.getElementById('bjPlayerHand').innerHTML = '';
        bjCurrentBet = 0;
        updateBjUI();

        if(bjRoomUnsub) bjRoomUnsub();
        bjRoomUnsub = onSnapshot(getBjRoomRef(code), (snap) => {
            if(!snap.exists()) return;
            handleNetUpdate(snap.data());
        });
    }

    function handleNetUpdate(data) {
        const seats = data.seats;
        const mySeat = seats[bjMySeatIdx];
        
        // 1. Render Dealer (Seat 0)
        const dealer = seats[0];
        const dDiv = document.getElementById('bjDealerHand');
        // Only rerender if changed to reduce flickering
        if(dDiv.childElementCount !== dealer.hand.length) {
            dDiv.innerHTML = '';
            dealer.hand.forEach(c => renderNewCard(c, 'bjDealerHand', c.hidden));
        }
        document.getElementById('bjDealerScore').innerText = dealer.hand.length > 0 && !dealer.hand[1].hidden ? calculateHand(dealer.hand) : '';

        // 2. Render Me (Bottom)
        if(mySeat) {
            const pDiv = document.getElementById('bjPlayerHand');
            if(pDiv.childElementCount !== mySeat.hand.length) renderHand(mySeat.hand, 'bjPlayerHand');
            updateScore('bjPlayerScore', mySeat.hand);
        }

        // 3. Render Others (Side Row)
        const sideDiv = document.getElementById('bjOtherPlayers');
        sideDiv.innerHTML = '';
        seats.forEach((s, idx) => {
            if(idx === 0 || idx === bjMySeatIdx || s === null) return; // Skip dealer, me, and empty
            
            const seatDiv = document.createElement('div');
            seatDiv.className = 'bj-small-seat';
            if(data.activeSeat === idx && data.phase === 'playing') seatDiv.classList.add('active-seat');
            
            const name = document.createElement('div');
            name.style.fontSize = '8px';
            name.innerText = `P${idx} ` + (s.status === 'playing' ? '' : `(${s.status})`);
            
            const handDiv = document.createElement('div');
            handDiv.className = 'bj-small-hand';
            
            s.hand.forEach(c => {
                const card = document.createElement('div');
                card.className = 'bj-card mini';
                card.innerHTML = `<div>${c.value}</div><div>${c.suit}</div>`;
                card.style.color=['♥','♦'].includes(c.suit)?'red':'inherit';
                handDiv.appendChild(card);
            });
            
            seatDiv.appendChild(name);
            seatDiv.appendChild(handDiv);
            sideDiv.appendChild(seatDiv);
        });

        // 4. Game Phase Logic
        const deckLabel = document.querySelector('#bjDeck div:last-child');
        
        if(data.phase === 'lobby') {
            document.getElementById('bjMessage').innerText = "WAITING FOR PLAYERS...";
            document.getElementById('bjBettingControls').style.visibility = 'hidden';
            if(bjMySeatIdx === 0 && seats.filter(s=>s!==null).length > 1) {
                deckLabel.innerText = "START"; // Host can start
            } else {
                deckLabel.innerText = "WAIT";
            }
        }
        else if (data.phase === 'betting') {
            if(bjMySeatIdx === 0) {
                 // Host View
                 const readyCount = seats.filter(s => s && s.ready).length;
                 const playerCount = seats.filter(s => s).length - 1; // Exclude host
                 if(readyCount === playerCount && playerCount > 0) {
                     document.getElementById('bjMessage').innerText = "ALL READY - DEAL";
                     deckLabel.innerText = "DEAL";
                 } else {
                     document.getElementById('bjMessage').innerText = `WAITING FOR BETS (${readyCount}/${playerCount})`;
                     deckLabel.innerText = "WAIT";
                 }
                 document.getElementById('bjBettingControls').style.visibility = 'hidden';
            } else {
                // Player View
                if(!mySeat.ready) {
                    document.getElementById('bjBettingControls').style.visibility = 'visible';
                    document.getElementById('bjMessage').innerText = "PLACE BET & LOCK IN";
                    deckLabel.innerText = "LOCK";
                } else {
                    document.getElementById('bjBettingControls').style.visibility = 'hidden';
                    document.getElementById('bjMessage').innerText = "WAITING FOR OTHERS...";
                    deckLabel.innerText = "WAIT";
                }
            }
        }
        else if (data.phase === 'playing') {
            document.getElementById('bjBettingControls').style.visibility = 'hidden';
            deckLabel.innerText = "PLAY";
            
            if(data.activeSeat === bjMySeatIdx) {
                document.getElementById('bjGameControls').style.display = 'flex';
                document.getElementById('bjMessage').innerText = "YOUR TURN";
            } else {
                document.getElementById('bjGameControls').style.display = 'none';
                const active = data.activeSeat === 0 ? "DEALER" : `P${data.activeSeat}`;
                document.getElementById('bjMessage').innerText = `${active}'S TURN`;
            }
        }
        else if (data.phase === 'resolution') {
            document.getElementById('bjGameControls').style.display = 'none';
            document.getElementById('bjBettingControls').style.visibility = 'hidden';
            
            let result = "";
            let winAmt = 0;
            
            if(bjMySeatIdx !== 0) {
                if(mySeat.status === 'bust') result = "YOU BUST!";
                else if(mySeat.status === 'lose') result = "YOU LOSE";
                else if(mySeat.status === 'win') { result = "YOU WIN!"; winAmt = mySeat.bet * 2; }
                else if(mySeat.status === 'push') { result = "PUSH"; winAmt = mySeat.bet; }
                
                // Payout logic (only once)
                if(mySeat.bet > 0) {
                    bjMoney += winAmt;
                    bjCurrentBet = 0; 
                    // Need a way to ensure we don't add multiple times locally? 
                    // We reset bjCurrentBet to 0 immediately after adding.
                    updateBjUI();
                }
            } else {
                result = "ROUND OVER";
            }
            
            document.getElementById('bjMessage').innerText = result;
            
            if(bjMySeatIdx === 0) deckLabel.innerText = "RESET";
            else deckLabel.innerText = "WAIT";
        }
    }

    // --- INTERACTION HANDLERS ---
    
    document.getElementById('bjDeck').addEventListener('click', async () => {
        if(currentGame !== 'blackjack') return;

        // SOLO
        if(bjMode === 'solo') {
            if(bjState === 'betting') startSoloRound();
            else if(bjState === 'betting_over') startSoloBetting();
            return;
        }

        // NET
        const ref = getBjRoomRef(bjRoomCode);
        const snap = await getDoc(ref);
        const data = snap.data();
        
        // Host Start Game
        if(data.phase === 'lobby' && bjMySeatIdx === 0) {
            await updateDoc(ref, { phase: 'betting' });
            return;
        }

        // Betting Phase
        if(data.phase === 'betting') {
            if(bjMySeatIdx !== 0) {
                // Player Lock In
                if(bjCurrentBet === 0) return beep(200, 'sawtooth', 0.5);
                const newSeats = [...data.seats];
                newSeats[bjMySeatIdx].bet = bjCurrentBet;
                newSeats[bjMySeatIdx].ready = true;
                await updateDoc(ref, { seats: newSeats });
            } else {
                // Host Deal
                // Check if all players ready
                const players = data.seats.filter((s,i) => i>0 && s!==null);
                if(players.every(p => p.ready)) {
                    const deck = createDeck();
                    const newSeats = [...data.seats];
                    
                    // Deal 2 cards to everyone
                    newSeats.forEach((s, i) => {
                        if(s) {
                            s.hand = [deck.pop(), deck.pop()];
                            if(i===0) s.hand[1].hidden = true; // Hide Dealer 2nd card
                            s.status = 'playing';
                            // Check Instant Blackjack for player
                            if(i > 0 && calculateHand(s.hand) === 21) {
                                s.status = 'blackjack'; // Mark them
                            }
                        }
                    });
                    
                    // Determine first active player (Seat 1, or next if empty/BJ)
                    let startSeat = 1;
                    while(startSeat < 4 && (newSeats[startSeat] === null || newSeats[startSeat].status === 'blackjack')) {
                        startSeat++;
                    }
                    // If everyone has BJ or empty, go straight to Dealer (0)
                    if(startSeat === 4) startSeat = 0;
                    
                    await updateDoc(ref, { 
                        seats: newSeats, 
                        deck: deck, 
                        phase: 'playing', 
                        activeSeat: startSeat 
                    });
                }
            }
        }
        
        // Reset Round
        if(data.phase === 'resolution' && bjMySeatIdx === 0) {
             const newSeats = data.seats.map((s, i) => {
                 if(!s) return null;
                 return { ...s, hand: [], bet: 0, ready: false, status: 'waiting' };
             });
             await updateDoc(ref, { seats: newSeats, phase: 'betting' });
        }
    });

    document.querySelectorAll('.bj-chip').forEach(chip => {
        chip.addEventListener('click', () => {
            if(currentGame !== 'blackjack') return;
            if(chip.id === 'btnBjClear') { bjMoney += bjCurrentBet; bjCurrentBet = 0; }
            else if (chip.id === 'btnBjAllIn') { bjCurrentBet += bjMoney; bjMoney = 0; }
            else { const val = parseInt(chip.dataset.val); if(bjMoney >= val) { bjMoney -= val; bjCurrentBet += val; } }
            updateBjUI();
        });
    });

    // Hit/Stand
    document.getElementById('btnBjHit').addEventListener('click', () => handleGameAction('hit'));
    document.getElementById('btnBjStand').addEventListener('click', () => handleGameAction('stand'));

    async function handleGameAction(action) {
        if(bjMode === 'solo') {
            if(action === 'hit') {
                const c = bjDeck.pop(); bjPlayerHand.push(c); renderNewCard(c, 'bjPlayerHand'); updateScore('bjPlayerScore', bjPlayerHand);
                if(calculateHand(bjPlayerHand) > 21) handleSoloEnd();
            } else handleSoloEnd();
            return;
        }

        const ref = getBjRoomRef(bjRoomCode);
        const snap = await getDoc(ref);
        const data = snap.data();
        
        if(data.activeSeat !== bjMySeatIdx) return; // Not my turn

        const deck = [...data.deck];
        const newSeats = [...data.seats];
        const mySeat = newSeats[bjMySeatIdx];

        if(action === 'hit') {
            const card = deck.pop();
            mySeat.hand.push(card);
            
            if(calculateHand(mySeat.hand) > 21) {
                mySeat.status = 'bust';
                // End Turn
                await passTurn(ref, data.activeSeat, newSeats, deck);
            } else {
                // Still turn
                await updateDoc(ref, { seats: newSeats, deck: deck });
            }
        } else {
            // Stand
            mySeat.status = 'stand';
            await passTurn(ref, data.activeSeat, newSeats, deck);
        }
    }

    async function passTurn(ref, currentIdx, seats, deck) {
        // Find next player
        let nextIdx = currentIdx + 1;
        // Skip empty seats
        while(nextIdx < 4 && seats[nextIdx] === null) nextIdx++;
        
        // If > 3, it's Dealer's turn (Seat 0)
        if(nextIdx >= 4) {
            // DEALER AI TURN logic runs immediately here since Dealer is Host-controlled essentially
            // But we treat it as an update.
            // Reveal Dealer Card
            seats[0].hand[1].hidden = false;
            let dScore = calculateHand(seats[0].hand);
            
            // Dealer hits until 17
            while(dScore < 17) {
                seats[0].hand.push(deck.pop());
                dScore = calculateHand(seats[0].hand);
            }
            
            // Resolution
            for(let i=1; i<4; i++) {
                const p = seats[i];
                if(p && p.status !== 'bust') {
                     const pScore = calculateHand(p.hand);
                     if(dScore > 21 || pScore > dScore) p.status = 'win';
                     else if (pScore === dScore) p.status = 'push';
                     else p.status = 'lose';
                } else if (p && p.status === 'bust') {
                    p.status = 'lose';
                }
            }
            
            await updateDoc(ref, { seats: seats, deck: deck, phase: 'resolution', activeSeat: -1 });
            
        } else {
            // Next Player's Turn
            await updateDoc(ref, { seats: seats, deck: deck, activeSeat: nextIdx });
        }
    }

    // --- SOLO RESOLUTION ---
    async function handleSoloEnd() {
        document.getElementById('bjGameControls').style.display = 'none';
        bjState = 'betting_over';
        renderHand(bjDealerHand, 'bjDealerHand'); 
        
        let pScore = calculateHand(bjPlayerHand);
        let dScore = calculateHand(bjDealerHand);
        
        if(pScore > 21) { finalizeSoloResult("YOU BUST!", 0); return; }

        while(dScore < 17) {
            await new Promise(r=>setTimeout(r,600)); 
            const c = bjDeck.pop(); bjDealerHand.push(c); renderNewCard(c, 'bjDealerHand');
            dScore = calculateHand(bjDealerHand); updateScore('bjDealerScore', bjDealerHand);
        }

        if(dScore > 21) finalizeSoloResult("DEALER BUST! YOU WIN", bjCurrentBet * 2);
        else if(pScore > dScore) finalizeSoloResult("YOU WIN!", bjCurrentBet * 2);
        else if(pScore < dScore) finalizeSoloResult("YOU LOSE", 0);
        else finalizeSoloResult("PUSH", bjCurrentBet);
    }

    function finalizeSoloResult(msg, payout) {
        document.getElementById('bjMessage').innerText = msg + " - CLICK DECK";
        bjMoney += payout; updateBjUI(); bjCurrentBet = 0;
        document.querySelector('#bjDeck div:last-child').innerText = "AGAIN";
        if(payout === 0) createCardRain();
    }

    /* UTILS */
    function createDeck() { let d = []; for(let s of suits) for(let v of values) d.push({suit: s, value: v, hidden:false}); return d.sort(()=>Math.random()-.5); }
    function renderHand(hand, elId) { const el = document.getElementById(elId); el.innerHTML = ''; hand.forEach(c => renderNewCard(c, elId, c.hidden)); }
    function renderNewCard(c, tid, h=false) {
        const d=document.createElement('div'); d.className='bj-card'+(h?' hidden':'');
        if(!h){ d.innerHTML=`<div>${c.value}</div><div>${c.suit}</div><div>${c.value}</div>`; d.style.color=['♥','♦'].includes(c.suit)?'red':'inherit'; }
        document.getElementById(tid).appendChild(d);
    }
    function calculateHand(hand) {
        let sum=0, aces=0;
        hand.forEach(c=>{ if(c.hidden) return; if(['J','Q','K'].includes(c.value)) sum+=10; else if(c.value==='A') {sum+=11; aces++;} else sum+=parseInt(c.value); });
        while(sum>21 && aces>0) { sum-=10; aces--; }
        return sum;
    }
    function updateScore(elId, hand) { document.getElementById(elId).innerText = calculateHand(hand); }
    function createCardRain() { for(let i=0; i<30; i++) { const card = document.createElement('div'); card.className = 'falling-card'; card.style.left = Math.random() * window.innerWidth + 'px'; card.style.animation = `fall ${1+Math.random()}s linear forwards`; document.body.appendChild(card); setTimeout(() => card.remove(), 2000); } }
    
    // TIC TAC TOE (Legacy Support)
    let tttRoomUnsub;
    function getTTTRoomRef(c) { return doc(db, 'gooner_terminal_rooms', c); }
    function initTTT() { currentGame='ttt'; document.getElementById('tttMenu').style.display='flex'; document.getElementById('tttGame').style.display='none'; }
    function cleanupTTT() { if(tttRoomUnsub)tttRoomUnsub(); }
    document.getElementById('btnCreateRoom').addEventListener('click',async()=>{ if(!myUid)return alert("Offline"); const c=Math.floor(1000+Math.random()*9000).toString(); await setDoc(getTTTRoomRef(c),{board:Array(9).fill(null),turn:'X',playerX:myUid,playerO:null,status:'waiting'}); joinTTTLobby(c,'X'); });
    document.getElementById('btnJoinRoom').addEventListener('click',async()=>{ const c=document.getElementById('joinRoomCode').value; const r=getTTTRoomRef(c); const s=await getDoc(r); if(!s.exists())return alert("No Room"); if(!s.data().playerO) { await updateDoc(r,{playerO:myUid,status:'playing'}); joinTTTLobby(c,'O'); } });
    function joinTTTLobby(c,side) {
        document.getElementById('tttMenu').style.display='none'; document.getElementById('tttGame').style.display='flex'; document.getElementById('displayRoomCode').innerText="CODE: "+c;
        tttRoomUnsub=onSnapshot(getTTTRoomRef(c),d=>{ if(!d.exists())return; const data=d.data(); const cells=document.getElementById('tttGrid').children; data.board.forEach((v,i)=>{ cells[i].innerText=v||''; cells[i].style.color=v==='X'?'#f00':'#fff'; }); document.getElementById('tttStatus').innerText = data.status==='playing'?(data.turn===side?"YOUR TURN":"ENEMY TURN"):(data.status==='finished'?"GAME OVER":data.status); });
        document.getElementById('tttGrid').onclick = async(e) => { const i=e.target.dataset.idx; if(!i && i!=='0')return; await runTransaction(db,async(t)=>{ const r = getTTTRoomRef(c); const s=await t.get(r); if(!s.exists()) return; const d=s.data(); if(d.turn!==side || d.board[i] || d.status!=='playing') return; const nb=[...d.board]; nb[i]=side; let w=null; const wins=[[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]]; wins.forEach(combo=>{ if(nb[combo[0]]&&nb[combo[0]]===nb[combo[1]]&&nb[combo[0]]===nb[combo[2]]) w=nb[combo[0]]; }); let nextStatus = w ? 'finished' : (!nb.includes(null) ? 'finished' : 'playing'); t.update(r,{board:nb,turn:side==='X'?'O':'X',status:nextStatus}); }); };
    }
    
    /* GLOBAL */
    window.triggerGameOver = (g,s) => { stopAllGames(); document.getElementById('gameOverText').innerText='SCORE: '+s; document.getElementById('modalGameOver').classList.add('active'); document.getElementById('btnRestart').onclick = () => { document.getElementById('modalGameOver').classList.remove('active'); if(g === 'snake') initSnake(); if(g === 'runner') initRunner(); if(g === 'pong') initPong(); }; };
    document.getElementById('btnExitGame').onclick=()=>{ document.getElementById('modalGameOver').classList.remove('active'); stopAllGames(); document.querySelectorAll('.overlay').forEach(o=>o.classList.remove('active')); };
</script>
</body>
</html>
