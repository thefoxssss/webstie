<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shadow Assassin - Castle Infiltration</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0a;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }

        #gameCanvas {
            border: 2px solid #8b4513;
            box-shadow: 0 0 30px rgba(139, 69, 19, 0.5);
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
        }

        #keybinds {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #fff;
            font-size: 13px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border: 2px solid #8b4513;
            border-radius: 5px;
            min-width: 200px;
        }

        #keybinds h3 {
            color: #ffd700;
            margin-bottom: 10px;
            font-size: 16px;
            text-align: center;
        }

        .keybind-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 3px 0;
            border-bottom: 1px solid rgba(139, 69, 19, 0.3);
        }

        .keybind-key {
            color: #ffd700;
            font-weight: bold;
        }

        .keybind-ability {
            color: #ccc;
        }

        #mythicPanel {
            position: absolute;
            top: 20px;
            left: 250px;
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #ffd700;
            padding: 15px;
            border-radius: 5px;
            max-height: 80vh;
            min-width: 400px;
            max-width: 500px;
            overflow-y: auto;
            display: none;
            z-index: 100;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.6);
        }

        #mythicPanel h2 {
            color: #ffd700;
            text-align: center;
            margin-bottom: 15px;
            font-size: 18px;
            text-shadow: 0 0 15px #ffd700;
            animation: mythicPulse 2s ease-in-out infinite;
        }

        .mythic-ability {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin: 5px 0;
            background: rgba(139, 69, 19, 0.3);
            border: 1px solid #8b4513;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .mythic-ability:hover {
            background: rgba(139, 69, 19, 0.5);
            border-color: #ffd700;
        }

        .mythic-ability.active {
            background: rgba(255, 215, 0, 0.2);
            border-color: #ffd700;
        }

        .mythic-ability-name {
            color: #fff;
            font-size: 12px;
            flex: 1;
        }

        .mythic-ability-toggle {
            width: 40px;
            height: 20px;
            background: #444;
            border: 2px solid #666;
            border-radius: 10px;
            position: relative;
            transition: all 0.3s;
        }

        .mythic-ability.active .mythic-ability-toggle {
            background: #4caf50;
            border-color: #66bb6a;
        }

        .mythic-ability-toggle::after {
            content: '';
            position: absolute;
            width: 12px;
            height: 12px;
            background: #fff;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: all 0.3s;
        }

        .mythic-ability.active .mythic-ability-toggle::after {
            left: 20px;
        }

        #mythicToggleBtn {
            position: absolute;
            top: 120px;
            left: 20px;
            background: linear-gradient(135deg, #daa520, #ffd700);
            border: 3px solid #ffd700;
            padding: 12px 18px;
            color: #000;
            font-size: 14px;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            display: none;
            z-index: 10;
            border-radius: 5px;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
            animation: godPulse 2s ease-in-out infinite;
        }

        @keyframes godPulse {
            0%, 100% {
                box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
            }
            50% {
                box-shadow: 0 0 30px rgba(255, 215, 0, 0.9);
            }
        }

        #mythicToggleBtn:hover {
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            transform: scale(1.08);
            box-shadow: 0 0 35px rgba(255, 215, 0, 1);
        }
        }

        .health-bar {
            width: 200px;
            height: 20px;
            background: #222;
            border: 2px solid #8b4513;
            margin-top: 5px;
            position: relative;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #dc143c, #8b0000);
            transition: width 0.3s;
        }

        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #aaa;
            font-size: 12px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .title {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #fff;
            z-index: 5;
            pointer-events: none;
        }

        .title h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #8b4513;
            text-shadow: 0 0 20px rgba(139, 69, 19, 0.8);
        }

        .title p {
            font-size: 18px;
            color: #ccc;
        }

        .fade-out {
            animation: fadeOut 2s forwards;
        }

        @keyframes fadeOut {
            to { opacity: 0; }
        }

        .upgrade-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .upgrade-container {
            text-align: center;
            color: #fff;
        }

        .upgrade-title {
            font-size: 36px;
            color: #ffd700;
            margin-bottom: 30px;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .upgrade-options {
            display: flex;
            gap: 30px;
            justify-content: center;
        }

        .upgrade-card {
            background: linear-gradient(135deg, #2a2a2a, #1a1a1a);
            border: 3px solid #8b4513;
            padding: 20px;
            width: 250px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }

        .upgrade-card:hover {
            transform: translateY(-10px);
            border-color: #ffd700;
            box-shadow: 0 10px 30px rgba(255, 215, 0, 0.3);
        }

        .upgrade-card h3 {
            color: #ffd700;
            font-size: 22px;
            margin-bottom: 10px;
        }

        .upgrade-card .level {
            color: #ff8c00;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .upgrade-card p {
            color: #ccc;
            font-size: 14px;
            line-height: 1.5;
        }

        .upgrade-card.mythic {
            border-color: #ff00ff;
            animation: mythicGlow 2s ease-in-out infinite;
        }

        .upgrade-card.mythic h3 {
            color: #ff00ff;
            text-shadow: 0 0 15px #ff00ff;
        }

        @keyframes mythicGlow {
            0%, 100% {
                box-shadow: 0 0 20px rgba(255, 0, 255, 0.6), 0 0 40px rgba(255, 0, 255, 0.4);
            }
            50% {
                box-shadow: 0 0 30px rgba(255, 0, 255, 0.8), 0 0 60px rgba(255, 0, 255, 0.6);
            }
        }

        .game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .game-over-title {
            font-size: 48px;
            color: #ff0000;
            margin-bottom: 30px;
            text-shadow: 0 0 20px rgba(255, 0, 0, 0.8);
        }

        .game-over-stats {
            color: #ffd700;
            font-size: 20px;
            margin-bottom: 30px;
        }

        .button-container {
            display: flex;
            gap: 20px;
        }

        .game-button {
            background: linear-gradient(135deg, #8b4513, #654321);
            border: 3px solid #ffd700;
            padding: 15px 40px;
            color: #fff;
            font-size: 18px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }

        .game-button:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(255, 215, 0, 0.4);
            background: linear-gradient(135deg, #a0522d, #8b4513);
        }

        .game-button:active {
            transform: translateY(-2px);
        }
        
        .game-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: linear-gradient(135deg, #4a4a4a, #2a2a2a);
            border-color: #666;
        }
        
        .game-button:disabled:hover {
            transform: none;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            background: linear-gradient(135deg, #4a4a4a, #2a2a2a);
        }
        
        .main-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 50%, #0a0a0a 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }

        .main-menu h1 {
            font-size: 64px;
            color: #8b4513;
            text-shadow: 0 0 30px rgba(139, 69, 19, 0.9);
            margin-bottom: 50px;
            animation: titlePulse 2s ease-in-out infinite;
        }

        @keyframes titlePulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .menu-button {
            background: linear-gradient(135deg, #8b4513, #654321);
            border: 3px solid #ffd700;
            padding: 20px 60px;
            color: #fff;
            font-size: 24px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            min-width: 300px;
        }

        .menu-button:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(255, 215, 0, 0.4);
            background: linear-gradient(135deg, #a0522d, #8b4513);
        }

        .settings-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 201;
        }

        .settings-container {
            background: linear-gradient(135deg, #2a2a2a, #1a1a1a);
            border: 3px solid #8b4513;
            padding: 40px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .settings-container h2 {
            color: #ffd700;
            font-size: 32px;
            margin-bottom: 30px;
            text-align: center;
        }

        .setting-item {
            margin-bottom: 25px;
            color: #fff;
        }

        .setting-item label {
            display: block;
            margin-bottom: 10px;
            font-size: 16px;
            color: #ffd700;
        }

        .setting-item input[type="range"] {
            width: 100%;
            height: 8px;
            background: #444;
            outline: none;
            border-radius: 4px;
        }

        .setting-item input[type="range"]::-webkit-slider-thumb {
            width: 20px;
            height: 20px;
            background: #ffd700;
            cursor: pointer;
            border-radius: 50%;
        }

        .setting-value {
            display: inline-block;
            margin-left: 15px;
            color: #fff;
            font-weight: bold;
        }

        .toggle-button {
            padding: 10px 20px;
            background: #444;
            border: 2px solid #666;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Courier New', monospace;
        }

        .toggle-button.active {
            background: #ffd700;
            border-color: #ffd700;
            color: #000;
        }

        .setting-item select {
            width: 100%;
            padding: 10px;
            background: #444;
            border: 2px solid #666;
            color: #fff;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }

        #safeRoomScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 50, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 150;
        }

        #safeRoomScreen h2 {
            color: #00ff00;
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 0 30px rgba(0, 255, 0, 0.8);
        }

        #safeRoomScreen p {
            color: #90ee90;
            font-size: 20px;
            margin-bottom: 40px;
            text-align: center;
            max-width: 600px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="1200" height="700"></canvas>
    
    <!-- UI Overlay -->
    <div id="ui">
        <div>Health: <span id="health">150</span></div>
        <div class="health-bar">
            <div id="healthBar" class="health-fill" style="width: 100%"></div>
        </div>
        <div style="margin-top: 10px;">Chamber: <span id="room">1</span></div>
        <div>Enemies: <span id="enemies">0</span></div>
        
        <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid #666;">
            <div style="font-size: 12px; color: #ffd700; margin-bottom: 5px;">⚡ SPECIAL ABILITIES</div>
            <div id="specialAbilitiesList" style="font-size: 11px;"></div>
        </div>
    </div>
    
    <!-- Keybinds Display -->
    <div id="keybinds">
        <h3>⚔️ Abilities ⚔️</h3>
        <div class="keybind-item">
            <span class="keybind-key">[J]</span>
            <span class="keybind-ability">Dagger Attack</span>
        </div>
        <div class="keybind-item">
            <span class="keybind-key">[K]</span>
            <span class="keybind-ability">Dash</span>
        </div>
        <div class="keybind-item">
            <span class="keybind-key">[L]</span>
            <span class="keybind-ability">Ranged Attack</span>
        </div>
        <div id="additionalKeybinds"></div>
    </div>
    
    <!-- Mythic Mode Toggle Button -->
    <button id="mythicToggleBtn">⚡ GOD PANEL - ALL ABILITIES</button>
    
    <!-- Mythic Mode Ability Panel -->
    <div id="mythicPanel">
        <h2>⚡ GOLDEN GOD PANEL - ALL ABILITIES ⚡</h2>
        <input type="text" id="abilitySearch" placeholder="🔍 Search abilities..." style="
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ffd700;
            color: #ffd700;
            font-family: 'Courier New', monospace;
            border-radius: 3px;
            outline: none;
        ">
        <div id="mythicAbilityList"></div>
    </div>
    
    <!-- Controls -->
    <div class="controls">
        WASD/Arrows: Move & Aim Knife | SPACE: Jump | J: Dagger | K: Dash | L: Knife<br>
        Q/E: Special Abilities
    </div>
    
    <!-- Main Menu -->
    <div id="mainMenu" class="main-menu">
        <h1>⚔️ SHADOW ASSASSIN ⚔️</h1>
        <div class="menu-buttons">
            <button id="playBtn" class="menu-button">NEW GAME</button>
            <button id="continueBtn" class="menu-button" style="display: none;">CONTINUE</button>
            <button id="settingsBtn" class="menu-button">SETTINGS</button>
        </div>
    </div>

    <!-- Settings Menu -->
    <div id="settingsMenu" class="settings-menu">
        <div class="settings-container">
            <h2>⚙️ SETTINGS ⚙️</h2>
            
            <div class="setting-item">
                <label>Master Volume: <span id="volumeValue" class="setting-value">100%</span></label>
                <input type="range" id="volumeSlider" min="0" max="100" value="100">
            </div>
            
            <div class="setting-item">
                <label>Music Volume: <span id="musicValue" class="setting-value">70%</span></label>
                <input type="range" id="musicSlider" min="0" max="100" value="70">
            </div>
            
            <div class="setting-item">
                <label>SFX Volume: <span id="sfxValue" class="setting-value">100%</span></label>
                <input type="range" id="sfxSlider" min="0" max="100" value="100">
            </div>
            
            <div class="setting-item">
                <label>Particles: <span id="particlesValue" class="setting-value">ON</span></label>
                <button id="particlesToggle" class="toggle-button active">TOGGLE</button>
            </div>
            
            <div class="setting-item">
                <label>Screen Shake: <span id="screenShakeValue" class="setting-value">ON</span></label>
                <button id="screenShakeToggle" class="toggle-button active">TOGGLE</button>
            </div>
            
            <div class="setting-item">
                <label>Damage Numbers: <span id="damageNumbersValue" class="setting-value">ON</span></label>
                <button id="damageNumbersToggle" class="toggle-button active">TOGGLE</button>
            </div>
            
            <div class="setting-item">
                <label>Show FPS: <span id="fpsValue" class="setting-value">OFF</span></label>
                <button id="fpsToggle" class="toggle-button">TOGGLE</button>
            </div>
            
            <div class="setting-item">
                <label>Difficulty:</label>
                <select id="difficultySelect">
                    <option value="easy">Easy</option>
                    <option value="normal" selected>Normal</option>
                    <option value="hard">Hard</option>
                </select>
            </div>
            
            <button id="backBtn" class="game-button" style="width: 100%; margin-top: 20px;">BACK</button>
        </div>
    </div>
    
    <!-- Upgrade Screen -->
    <div id="upgradeScreen" class="upgrade-screen">
        <div class="upgrade-container">
            <div class="upgrade-title">⚡ CHOOSE YOUR UPGRADE ⚡</div>
            <div id="upgradeOptions" class="upgrade-options"></div>
        </div>
    </div>
    
    <!-- Game Over Screen -->
    <div id="gameOverScreen" class="game-over-screen">
        <div class="game-over-title">💀 DEFEATED 💀</div>
        <div class="game-over-stats">
            You reached Chamber <span id="finalRoom">1</span>
        </div>
        <div class="button-container">
            <button class="game-button" id="playAgainBtn">⚔️ Play Again</button>
            <button class="game-button" id="loadCheckpointBtn">📍 Load Checkpoint</button>
            <button class="game-button" id="homeBtn">🏠 Home</button>
        </div>
    </div>

    <div id="safeRoomScreen">
        <h2>🛡️ SAFE ROOM 🛡️</h2>
        <p>You have reached a safe checkpoint. Your progress has been saved.<br>Health fully restored. Take a moment to prepare for the challenges ahead.</p>
        <button class="game-button" id="safeRoomContinueBtn">CONTINUE</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Particle class
        class Particle {
            constructor(x, y, color, vx, vy, life) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.vx = vx;
                this.vy = vy;
                this.life = life;
                this.maxLife = life;
            }
            
            update() {
                // Pause during upgrade selection
                if (showingUpgrade) return;
                
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.2;
                this.life--;
            }
            
            draw() {
                const alpha = this.life / this.maxLife;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - 2, this.y - 2, 4, 4);
                ctx.globalAlpha = 1;
            }
        }

        // Projectile class  
        class Projectile {
            constructor(x, y, angle, speed, owner) {
                this.x = x;
                this.y = y;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.owner = owner;
                this.life = 180;
                this.explosive = false;
                this.homing = false;
                this.angle = angle;
            }
            
            update() {
                // Pause during upgrade selection
                if (showingUpgrade) return true;
                
                // Homing behavior
                if (this.homing && this.owner === 'player') {
                    let nearest = null;
                    let nearestDist = Infinity;
                    for (const enemy of currentRoom.enemies) {
                        const dist = Math.sqrt((enemy.x - this.x)**2 + (enemy.y - this.y)**2);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearest = enemy;
                        }
                    }
                    if (nearest && nearestDist < 400) {
                        const angle = Math.atan2(nearest.y - this.y, nearest.x - this.x);
                        this.vx += Math.cos(angle) * 0.5;
                        this.vy += Math.sin(angle) * 0.5;
                    }
                }
                
                this.x += this.vx;
                this.y += this.vy;
                this.life--;
                
                // Trail particle
                if (Math.random() < 0.2) {
                    particles.push(new Particle(
                        this.x, this.y,
                        this.owner === 'player' ? '#1a1a1a' : '#ff4500',
                        0, 0, 10
                    ));
                }
                
                return this.life > 0 && this.x > 0 && this.x < canvas.width && this.y > 0 && this.y < canvas.height;
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(Math.atan2(this.vy, this.vx));
                
                // Knife shape
                if (this.owner === 'player') {
                    ctx.fillStyle = '#c0c0c0';
                    ctx.fillRect(0, -2, 12, 4);
                    ctx.fillStyle = '#8b4513';
                    ctx.fillRect(-4, -1, 4, 2);
                } else {
                    // Enemy projectile (arrow)
                    ctx.fillStyle = '#8b4513';
                    ctx.fillRect(-4, -1, 8, 2);
                    ctx.fillStyle = '#c0c0c0';
                    ctx.beginPath();
                    ctx.moveTo(8, 0);
                    ctx.lineTo(4, -4);
                    ctx.lineTo(4, 4);
                    ctx.closePath();
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }

        // Shadow Clone class
        class ShadowClone {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 24;
                this.height = 32;
                this.vx = 0;
                this.vy = 0;
                this.life = 300;
                this.facing = 1;
                this.onGround = false;
                this.gravity = 0.6;
                this.attackCooldown = 0;
            }
            
            mimicMeleeAttack() {
                this.attackCooldown = 30;
                for (let i = 0; i < 10; i++) {
                    const angle = (Math.random() - 0.5) * Math.PI;
                    const speed = Math.random() * 3 + 2;
                    particles.push(new Particle(
                        this.x + this.facing * 20,
                        this.y,
                        '#2a2a2a',
                        Math.cos(angle) * speed * this.facing,
                        Math.sin(angle) * speed,
                        15
                    ));
                }
            }
            
            mimicRangedAttack() {
                let nearest = null;
                let nearestDist = Infinity;
                for (const enemy of currentRoom.enemies) {
                    const dist = Math.sqrt((enemy.x - this.x)**2 + (enemy.y - this.y)**2);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearest = enemy;
                    }
                }
                
                if (nearest) {
                    const angle = Math.atan2(nearest.y - this.y, nearest.x - this.x);
                    projectiles.push(new Projectile(this.x, this.y, angle, 10, 'player'));
                }
            }
            
            update() {
                // Pause during upgrade selection
                if (showingUpgrade) return true;
                
                this.life--;
                if (this.attackCooldown > 0) this.attackCooldown--;
                
                // Simple AI - follow nearest enemy
                let nearest = null;
                let nearestDist = Infinity;
                for (const enemy of currentRoom.enemies) {
                    const dist = Math.sqrt((enemy.x - this.x)**2 + (enemy.y - this.y)**2);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearest = enemy;
                    }
                }
                
                if (nearest && nearestDist < 300) {
                    const dx = nearest.x - this.x;
                    this.facing = dx > 0 ? 1 : -1;
                    this.vx = this.facing * 3;
                    
                    if (nearestDist < 100 && this.attackCooldown <= 0) {
                        this.mimicMeleeAttack();
                    }
                } else {
                    this.vx *= 0.9;
                }
                
                // Physics
                this.vy += this.gravity;
                this.x += this.vx;
                this.y += this.vy;
                
                // Platform collision
                this.onGround = false;
                for (const platform of currentRoom.platforms) {
                    if (this.x + this.width / 2 > platform.x &&
                        this.x - this.width / 2 < platform.x + platform.width &&
                        this.y + this.height / 2 > platform.y &&
                        this.y + this.height / 2 < platform.y + 20 &&
                        this.vy >= 0) {
                        this.y = platform.y - this.height / 2;
                        this.vy = 0;
                        this.onGround = true;
                    }
                }
                
                if (this.y > canvas.height - 50 - this.height / 2) {
                    this.y = canvas.height - 50 - this.height / 2;
                    this.vy = 0;
                    this.onGround = true;
                }
                
                return this.life > 0;
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.facing, 1);
                ctx.globalAlpha = 0.6;
                
                // Shadow assassin appearance
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                
                ctx.fillStyle = '#0a0a0a';
                ctx.beginPath();
                ctx.arc(0, -this.height / 2 + 6, 10, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(2, -8, 3, 2);
                
                ctx.globalAlpha = 1;
                ctx.restore();
            }
        }

        // Player class
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 24;
                this.height = 32;
                this.vx = 0;
                this.vy = 0;
                this.speed = 5;
                this.jumpPower = 13;
                this.gravity = 0.6;
                this.onGround = false;
                this.health = 150;
                this.maxHealth = 150;
                this.facing = 1;
                
                // Combat
                this.attacking = false;
                this.attackFrame = 0;
                this.attackCooldown = 0;
                this.attackDamage = 25;
                this.attackRange = 50;
                
                // Dash
                this.dashing = false;
                this.dashFrame = 0;
                this.dashCooldown = 0;
                this.dashSpeed = 15;
                
                // Ranged with directional aiming
                this.rangedCooldown = 0;
                this.aimDirection = { x: 1, y: 0 };
                
                // Upgrades
                this.upgrades = {
                    // Basic stats
                    maxHealth: 0, damage: 0, attackSpeed: 0, speed: 0, critChance: 0, critDamage: 0,
                    // Combat
                    multishot: 0, rapidFire: 0, piercing: 0, explosiveKnives: 0, ricochet: 0, magneticKnives: 0,
                    // Defense
                    lifesteal: 0, thorns: 0, bloodArmor: 0, lastStand: 0, ironSkin: 0, evasion: 0,
                    // Mobility
                    dashAttack: 0, ghostWalk: 0, shadowStep: 0, doubleJump: 0, airDash: 0, swiftness: 0,
                    // Effects
                    poisonDagger: 0, frozenTouch: 0, chainLightning: 0, vampiricAura: 0, bloodRage: 0,
                    // Special abilities
                    shadowClone: 0, timeSlowOnKill: 0, berserker: 0, executeThreshold: 0, backstab: 0,
                    frostNova: 0, knifeStorm: 0, vortex: 0, armorPierce: 0, necromancy: 0, flurry: 0,
                    // NEW UPGRADES
                    lifeLink: 0, deathMark: 0, voidWalk: 0, soulHarvest: 0, reflection: 0,
                    arcaneShield: 0, regeneration: 0, multiStrike: 0, bladeDance: 0, berserkerRage: 0,
                    assassination: 0, execution: 0, rage: 0, berserk: 0, whirlwind: 0,
                    teleportStrike: 0, shadowBurst: 0, deathWave: 0, criticalMass: 0, bloodShield: 0,
                    phantomStrike: 0, timeWarp: 0, meteorStrike: 0, phaseShift: 0, divineIntervention: 0,
                    bloodPact: 0, dimensionalRift: 0, soulReaper: 0
                };
                this.usedLastStand = false;
                this.bloodRageStacks = 0;
                this.shield = 0;
                this.hasDoubleJumped = false;
                
                // Special ability slots - NOW SUPPORTS 6 ABILITIES!
                this.special1 = null;
                this.special2 = null;
                this.special3 = null;
                this.special4 = null;
                this.special5 = null;
                this.special6 = null;
                this.special1Cooldown = 0;
                this.special2Cooldown = 0;
                this.special3Cooldown = 0;
                this.special4Cooldown = 0;
                this.special5Cooldown = 0;
                this.special6Cooldown = 0;
                
                // Ability effects
                this.invincible = false;
                this.damageMultiplier = 1;
                
                // Animation
                this.animFrame = 0;
                this.animCounter = 0;
                
                // NEW: Status effect tracking
                this.poisonedEnemies = new Set();
                this.frozenEnemies = new Set();
                this.markedEnemies = new Set();
                this.regenTimer = 0;
            }

            attack() {
                if (this.attackCooldown <= 0 && !this.attacking && !this.dashing) {
                    this.attacking = true;
                    this.attackFrame = 0;
                    
                    const baseAttackSpeed = 30;
                    const attackSpeedMultiplier = 1 + (this.upgrades.attackSpeed * 0.15);
                    this.attackCooldown = Math.floor(baseAttackSpeed / attackSpeedMultiplier);
                    
                    // Calculate attack direction based on WASD keys (same as knife throwing)
                    let dirX = 0;
                    let dirY = 0;
                    
                    if (keys['w'] || keys['arrowup']) dirY = -1;
                    if (keys['s'] || keys['arrowdown']) dirY = 1;
                    if (keys['a'] || keys['arrowleft']) dirX = -1;
                    if (keys['d'] || keys['arrowright']) dirX = 1;
                    
                    // If no direction key pressed, use facing direction
                    if (dirX === 0 && dirY === 0) {
                        dirX = this.facing;
                    }
                    
                    // Normalize direction
                    const magnitude = Math.sqrt(dirX * dirX + dirY * dirY);
                    if (magnitude > 0) {
                        dirX /= magnitude;
                        dirY /= magnitude;
                    }
                    
                    const attackAngle = Math.atan2(dirY, dirX);
                    
                    // Store attack direction for animation
                    this.attackDirection = attackAngle;
                    
                    // Multi-strike
                    const strikes = 1 + (this.upgrades.multiStrike || 0);
                    
                    for (let s = 0; s < strikes; s++) {
                        setTimeout(() => {
                            // Check for hits on enemies
                            const attackRange = 70;
                            const attackWidth = 45;
                            
                            // Calculate attack position in the attack direction
                            const attackX = this.x + dirX * attackRange;
                            const attackY = this.y + dirY * attackRange;
                            
                            // Check collision with enemies
                            for (let i = currentRoom.enemies.length - 1; i >= 0; i--) {
                                const enemy = currentRoom.enemies[i];
                                const dx = enemy.x - attackX;
                                const dy = enemy.y - attackY;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                
                                if (dist < attackWidth) {
                                    const baseDamage = this.attackDamage * (1 + this.upgrades.damage * 0.15);
                                    const damageMultiplier = this.damageMultiplier * (mythicMode ? 5 : 1);
                                    let finalDamage = baseDamage * damageMultiplier;
                                    
                                    // Critical hit
                                    const critChance = 0.1 + (this.upgrades.critChance * 0.05);
                                    if (Math.random() < critChance) {
                                        const critDamage = 2 + (this.upgrades.critDamage * 0.3);
                                        finalDamage *= critDamage;
                                        
                                        // Crit particles
                                        for (let j = 0; j < 20; j++) {
                                            particles.push(new Particle(
                                                enemy.x, enemy.y, '#ffff00',
                                                (Math.random() - 0.5) * 10,
                                                (Math.random() - 0.5) * 10,
                                                30
                                            ));
                                        }
                                    }
                                    
                                    // Apply damage
                                    enemy.health -= finalDamage;
                                    
                                    // Lifesteal
                                    if (this.upgrades.lifesteal > 0) {
                                        this.health = Math.min(this.maxHealth, this.health + this.upgrades.lifesteal * 2);
                                    }
                                    
                                    // Check if enemy died
                                    if (enemy.health <= 0) {
                                        // Soul Harvest
                                        if (this.upgrades.soulHarvest > 0) {
                                            this.health = Math.min(this.maxHealth, this.health + this.upgrades.soulHarvest * 3);
                                        }
                                        
                                        // Death particles
                                        for (let j = 0; j < 30; j++) {
                                            particles.push(new Particle(
                                                enemy.x, enemy.y, '#ff0000',
                                                (Math.random() - 0.5) * 12,
                                                (Math.random() - 0.5) * 12,
                                                40
                                            ));
                                        }
                                        
                                        currentRoom.enemies.splice(i, 1);
                                    } else {
                                        // Damage particles
                                        for (let j = 0; j < 15; j++) {
                                            particles.push(new Particle(
                                                enemy.x, enemy.y, '#ff0000',
                                                (Math.random() - 0.5) * 8,
                                                (Math.random() - 0.5) * 8,
                                                25
                                            ));
                                        }
                                    }
                                }
                            }
                            
                            // Check collision with boss
                            if (currentRoom.boss && currentRoom.boss.health > 0) {
                                const dx = currentRoom.boss.x - attackX;
                                const dy = currentRoom.boss.y - attackY;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                
                                if (dist < attackWidth + 25) {
                                    const baseDamage = this.attackDamage * (1 + this.upgrades.damage * 0.15);
                                    const damageMultiplier = this.damageMultiplier * (mythicMode ? 5 : 1);
                                    let finalDamage = baseDamage * damageMultiplier;
                                    
                                    // Critical hit
                                    const critChance = 0.1 + (this.upgrades.critChance * 0.05);
                                    if (Math.random() < critChance) {
                                        const critDamage = 2 + (this.upgrades.critDamage * 0.3);
                                        finalDamage *= critDamage;
                                        
                                        // Crit particles
                                        for (let j = 0; j < 20; j++) {
                                            particles.push(new Particle(
                                                currentRoom.boss.x, currentRoom.boss.y, '#ffff00',
                                                (Math.random() - 0.5) * 10,
                                                (Math.random() - 0.5) * 10,
                                                30
                                            ));
                                        }
                                    }
                                    
                                    currentRoom.boss.health -= finalDamage;
                                    currentRoom.boss.health = Math.max(0, currentRoom.boss.health);
                                    
                                    // Boss damage particles
                                    for (let j = 0; j < 20; j++) {
                                        particles.push(new Particle(
                                            currentRoom.boss.x, currentRoom.boss.y, currentRoom.boss.color,
                                            (Math.random() - 0.5) * 10,
                                            (Math.random() - 0.5) * 10,
                                            35
                                        ));
                                    }
                                    
                                    // Lifesteal
                                    if (this.upgrades.lifesteal > 0) {
                                        this.health = Math.min(this.maxHealth, this.health + this.upgrades.lifesteal * 2);
                                    }
                                }
                            }
                            
                            // Trigger clone attacks
                            for (const clone of shadowClones) {
                                clone.mimicMeleeAttack();
                            }
                            
                            // Attack particles in the attack direction
                            for (let i = 0; i < 15; i++) {
                                const angle = attackAngle + (Math.random() - 0.5) * Math.PI * 0.5;
                                const speed = Math.random() * 5 + 3;
                                particles.push(new Particle(
                                    attackX,
                                    attackY,
                                    Math.random() > 0.5 ? '#1a1a1a' : '#4a4a4a',
                                    Math.cos(angle) * speed,
                                    Math.sin(angle) * speed,
                                    20 + Math.random() * 10
                                ));
                            }
                            
                            // Whirlwind
                            if (this.upgrades.whirlwind > 0) {
                                const bladeCount = 8 + this.upgrades.whirlwind * 4;
                                for (let i = 0; i < bladeCount; i++) {
                                    const angle = (Math.PI * 2 / bladeCount) * i;
                                    projectiles.push(new Projectile(
                                        this.x,
                                        this.y,
                                        angle,
                                        8,
                                        'player'
                                    ));
                                }
                            }
                            
                            // Shadow Burst
                            if (this.upgrades.shadowBurst > 0 && Math.random() < 0.25) {
                                const burstCount = 12;
                                for (let i = 0; i < burstCount; i++) {
                                    const angle = (Math.PI * 2 / burstCount) * i;
                                    projectiles.push(new Projectile(
                                        this.x,
                                        this.y,
                                        angle,
                                        10,
                                        'player'
                                    ));
                                }
                            }
                        }, s * 100);
                    }
                    
                    setTimeout(() => {
                        this.attacking = false;
                        this.attackDirection = null;
                    }, 150);
                }
            }

            dash() {
                if (this.dashCooldown <= 0 && !this.dashing) {
                    this.dashing = true;
                    this.dashFrame = 0;
                    this.dashCooldown = 60 - (this.upgrades.shadowStep * 10);
                    this.vy = 0;
                    
                    // Shadow clone on dash
                    if (this.upgrades.shadowClone > 0 && Math.random() < 0.4) {
                        shadowClones.push(new ShadowClone(this.x, this.y));
                    }
                    
                    // Void Walk damage
                    if (this.upgrades.voidWalk > 0) {
                        for (const enemy of currentRoom.enemies) {
                            const dist = Math.sqrt((enemy.x - this.x)**2 + (enemy.y - this.y)**2);
                            if (dist < 100) {
                                const damage = this.attackDamage * (1 + this.upgrades.damage * 0.15) * 0.8;
                                enemy.takeDamage(damage);
                            }
                        }
                    }
                }
            }

            shootRanged() {
                if (this.rangedCooldown <= 0) {
                    // Calculate direction based on WASD keys
                    let dirX = 0;
                    let dirY = 0;
                    
                    if (keys['w'] || keys['arrowup']) dirY = -1;
                    if (keys['s'] || keys['arrowdown']) dirY = 1;
                    if (keys['a'] || keys['arrowleft']) dirX = -1;
                    if (keys['d'] || keys['arrowright']) dirX = 1;
                    
                    // If no direction key pressed, use facing direction
                    if (dirX === 0 && dirY === 0) {
                        dirX = this.facing;
                    }
                    
                    // Normalize direction
                    const magnitude = Math.sqrt(dirX * dirX + dirY * dirY);
                    if (magnitude > 0) {
                        dirX /= magnitude;
                        dirY /= magnitude;
                    }
                    
                    const angle = Math.atan2(dirY, dirX);
                    const cooldown = Math.max(5, 20 - this.upgrades.rapidFire * 3);
                    const knifeCount = 1 + this.upgrades.multishot;
                    const spreadAngle = 0.3;
                    
                    // Spawn knives ahead of player in the direction they're shooting
                    const spawnDistance = 25;
                    const spawnX = this.x + Math.cos(angle) * spawnDistance;
                    const spawnY = this.y + Math.sin(angle) * spawnDistance;
                    
                    for (let i = 0; i < knifeCount; i++) {
                        const offset = (i - (knifeCount - 1) / 2) * spreadAngle;
                        const proj = new Projectile(
                            spawnX,
                            spawnY,
                            angle + offset,
                            12,
                            'player'
                        );
                        proj.explosive = this.upgrades.explosiveKnives > 0;
                        proj.homing = this.upgrades.magneticKnives > 0;
                        projectiles.push(proj);
                    }
                    
                    this.rangedCooldown = cooldown;
                    
                    // Trigger clone ranged attacks
                    for (const clone of shadowClones) {
                        clone.mimicRangedAttack();
                    }
                    
                    // Muzzle flash at spawn position
                    for (let i = 0; i < 10; i++) {
                        particles.push(new Particle(
                            spawnX,
                            spawnY,
                            '#1a1a1a',
                            (Math.random() - 0.5) * 4 + Math.cos(angle) * 3,
                            (Math.random() - 0.5) * 4 + Math.sin(angle) * 3,
                            15
                        ));
                    }
                }
            }

            useSpecial1() {
                if (this.special1 && this.special1Cooldown <= 0) {
                    const ability = upgradeDefinitions[this.special1];
                    const cooldown = ability.cooldown || 300;
                    this.special1Cooldown = cooldown;
                    this.executeSpecialAbility(this.special1);
                }
            }

            useSpecial2() {
                if (this.special2 && this.special2Cooldown <= 0) {
                    const ability = upgradeDefinitions[this.special2];
                    const cooldown = ability.cooldown || 300;
                    this.special2Cooldown = cooldown;
                    this.executeSpecialAbility(this.special2);
                }
            }
            
            useSpecial3() {
                if (this.special3 && this.special3Cooldown <= 0) {
                    const ability = upgradeDefinitions[this.special3];
                    const cooldown = ability.cooldown || 300;
                    this.special3Cooldown = cooldown;
                    this.executeSpecialAbility(this.special3);
                }
            }
            
            useSpecial4() {
                if (this.special4 && this.special4Cooldown <= 0) {
                    const ability = upgradeDefinitions[this.special4];
                    const cooldown = ability.cooldown || 300;
                    this.special4Cooldown = cooldown;
                    this.executeSpecialAbility(this.special4);
                }
            }
            
            useSpecial5() {
                if (this.special5 && this.special5Cooldown <= 0) {
                    const ability = upgradeDefinitions[this.special5];
                    const cooldown = ability.cooldown || 300;
                    this.special5Cooldown = cooldown;
                    this.executeSpecialAbility(this.special5);
                }
            }
            
            useSpecial6() {
                if (this.special6 && this.special6Cooldown <= 0) {
                    const ability = upgradeDefinitions[this.special6];
                    const cooldown = ability.cooldown || 300;
                    this.special6Cooldown = cooldown;
                    this.executeSpecialAbility(this.special6);
                }
            }
            
            executeSpecialAbility(abilityName) {
                switch(abilityName) {
                    case 'shadowClone':
                        shadowClones.push(new ShadowClone(this.x, this.y));
                        for (let i = 0; i < 30; i++) {
                            particles.push(new Particle(
                                this.x, this.y, '#2a2a2a',
                                (Math.random() - 0.5) * 10,
                                (Math.random() - 0.5) * 10,
                                50
                            ));
                        }
                        break;
                        
                    case 'fireStorm':
                        for (let i = 0; i < 12; i++) {
                            setTimeout(() => {
                                const x = this.x + (Math.random() - 0.5) * 200;
                                projectiles.push(new Projectile(x, 50, Math.PI / 2, 8, 'player'));
                            }, i * 100);
                        }
                        break;
                        
                    case 'bladeDance':
                        for (let i = 0; i < 16; i++) {
                            const angle = (Math.PI * 2 / 16) * i;
                            projectiles.push(new Projectile(this.x, this.y, angle, 12, 'player'));
                        }
                        break;
                        
                    case 'timeWarp':
                        for (const enemy of currentRoom.enemies) {
                            enemy.frozen = true;
                            setTimeout(() => enemy.frozen = false, 2000);
                        }
                        if (currentRoom.boss) {
                            currentRoom.boss.frozen = true;
                            setTimeout(() => currentRoom.boss.frozen = false, 2000);
                        }
                        break;
                        
                    case 'teleportStrike':
                        let nearestTele = null;
                        let nearestTeleDist = Infinity;
                        for (const enemy of currentRoom.enemies) {
                            const dist = Math.sqrt((enemy.x - this.x)**2 + (enemy.y - this.y)**2);
                            if (dist < nearestTeleDist && dist < 500) {
                                nearestTeleDist = dist;
                                nearestTele = enemy;
                            }
                        }
                        if (nearestTele) {
                            this.x = nearestTele.x - nearestTele.facing * 50;
                            this.y = nearestTele.y;
                            nearestTele.takeDamage(150);
                            for (let i = 0; i < 30; i++) {
                                particles.push(new Particle(
                                    this.x, this.y, '#00ffff',
                                    (Math.random() - 0.5) * 12,
                                    (Math.random() - 0.5) * 12,
                                    40
                                ));
                            }
                        }
                        break;
                        
                    case 'deathWave':
                        for (let i = 0; i < 8; i++) {
                            const angle = (Math.PI * 2 / 8) * i;
                            for (let j = 0; j < 3; j++) {
                                setTimeout(() => {
                                    projectiles.push(new Projectile(this.x, this.y, angle, 8 + j * 2, 'player'));
                                }, j * 150);
                            }
                        }
                        break;
                        
                    case 'meteorStrike':
                        for (let i = 0; i < 20; i++) {
                            setTimeout(() => {
                                const x = Math.random() * canvas.width;
                                const proj = new Projectile(x, 0, Math.PI / 2, 12, 'player');
                                projectiles.push(proj);
                            }, i * 75);
                        }
                        break;
                        
                    case 'timeStop':
                        for (const enemy of currentRoom.enemies) {
                            enemy.frozen = true;
                            setTimeout(() => enemy.frozen = false, 3000);
                        }
                        if (currentRoom.boss) {
                            currentRoom.boss.frozen = true;
                            setTimeout(() => currentRoom.boss.frozen = false, 3000);
                        }
                        break;
                        
                    case 'phantomStrike':
                        let nearest = null;
                        let nearestDist = Infinity;
                        for (const enemy of currentRoom.enemies) {
                            const dist = Math.sqrt((enemy.x - this.x)**2 + (enemy.y - this.y)**2);
                            if (dist < nearestDist && dist < 500) {
                                nearestDist = dist;
                                nearest = enemy;
                            }
                        }
                        if (nearest) {
                            this.x = nearest.x - nearest.facing * 50;
                            this.y = nearest.y;
                            nearest.takeDamage(100);
                        }
                        break;
                        
                    case 'omniSlash':
                        // ⚔️ OMNI SLASH - SLASH ALL ENEMIES AT ONCE ⚔️
                        // Phase 1: Teleport to each enemy with slash
                        const originalX = this.x;
                        const originalY = this.y;
                        
                        for (let i = 0; i < currentRoom.enemies.length && i < 20; i++) {
                            setTimeout(() => {
                                if (i < currentRoom.enemies.length) {
                                    const enemy = currentRoom.enemies[i];
                                    
                                    // Teleport to enemy
                                    this.x = enemy.x;
                                    this.y = enemy.y;
                                    
                                    // Slash effect
                                    for (let slash = 0; slash < 3; slash++) {
                                        const slashAngle = (Math.PI / 3) * slash;
                                        for (let j = 0; j < 20; j++) {
                                            particles.push(new Particle(
                                                enemy.x + Math.cos(slashAngle) * j * 5,
                                                enemy.y + Math.sin(slashAngle) * j * 5,
                                                ['#ffffff', '#aaaaff'][j % 2],
                                                Math.cos(slashAngle) * 15,
                                                Math.sin(slashAngle) * 15,
                                                35
                                            ));
                                        }
                                    }
                                    
                                    // Damage
                                    enemy.takeDamage(100);
                                    
                                    // Impact particles
                                    for (let k = 0; k < 30; k++) {
                                        particles.push(new Particle(
                                            enemy.x + (Math.random() - 0.5) * 50,
                                            enemy.y + (Math.random() - 0.5) * 50,
                                            ['#ffffff', '#00ffff', '#aaaaff'][Math.floor(Math.random() * 3)],
                                            (Math.random() - 0.5) * 20,
                                            (Math.random() - 0.5) * 20,
                                            40
                                        ));
                                    }
                                }
                            }, i * 80);
                        }
                        
                        // Return to original position
                        setTimeout(() => {
                            this.x = originalX;
                            this.y = originalY;
                            // Return effect
                            for (let i = 0; i < 50; i++) {
                                particles.push(new Particle(
                                    this.x + (Math.random() - 0.5) * 80,
                                    this.y + (Math.random() - 0.5) * 80,
                                    '#00ffff',
                                    (Math.random() - 0.5) * 15,
                                    (Math.random() - 0.5) * 15,
                                    35
                                ));
                            }
                        }, Math.min(currentRoom.enemies.length, 20) * 80 + 200);
                        
                        // Boss slash
                        if (currentRoom.boss) {
                            setTimeout(() => {
                                currentRoom.boss.takeDamage(100);
                                for (let i = 0; i < 60; i++) {
                                    particles.push(new Particle(
                                        currentRoom.boss.x + (Math.random() - 0.5) * 100,
                                        currentRoom.boss.y + (Math.random() - 0.5) * 100,
                                        '#ffffff',
                                        (Math.random() - 0.5) * 25,
                                        (Math.random() - 0.5) * 25,
                                        45
                                    ));
                                }
                            }, Math.min(currentRoom.enemies.length, 20) * 80 + 400);
                        }
                        break;
                        
                    case 'godMode':
                        // 🔱 GOD MODE - BECOME UNTOUCHABLE 🔱
                        this.invincible = true;
                        this.damageMultiplier = 15;
                        this.speed *= 1.5;
                        
                        // Golden transformation
                        for (let i = 0; i < 50; i++) {
                            setTimeout(() => {
                                for (let j = 0; j < 20; j++) {
                                    const angle = (Math.PI * 2 / 20) * j + (i * 0.3);
                                    particles.push(new Particle(
                                        this.x + Math.cos(angle) * (80 - i),
                                        this.y + Math.sin(angle) * (80 - i),
                                        ['#ffd700', '#ffaa00'][j % 2],
                                        0, 0, 30
                                    ));
                                }
                            }, i * 25);
                        }
                        
                        // Continuous god aura
                        const godInterval = setInterval(() => {
                            for (let i = 0; i < 12; i++) {
                                const angle = (Math.PI * 2 / 12) * i + Date.now() / 150;
                                particles.push(new Particle(
                                    this.x + Math.cos(angle) * 60,
                                    this.y + Math.sin(angle) * 60,
                                    '#ffd700',
                                    0, 0, 25
                                ));
                            }
                        }, 50);
                        
                        setTimeout(() => {
                            this.invincible = false;
                            this.damageMultiplier = 1;
                            this.speed /= 1.5;
                            clearInterval(godInterval);
                            
                            // End effect
                            for (let i = 0; i < 100; i++) {
                                particles.push(new Particle(
                                    this.x + (Math.random() - 0.5) * 100,
                                    this.y + (Math.random() - 0.5) * 100,
                                    '#ffd700',
                                    (Math.random() - 0.5) * 15,
                                    (Math.random() - 0.5) * 15,
                                    40
                                ));
                            }
                        }, 5000);
                        break;
                        
                    case 'armageddon':
                        for (let i = 0; i < 30; i++) {
                            setTimeout(() => {
                                const x = Math.random() * canvas.width;
                                projectiles.push(new Projectile(x, 0, Math.PI / 2, 15, 'player'));
                            }, i * 50);
                        }
                        break;
                        
                    case 'infinityEdge':
                        for (let i = 0; i < 20; i++) {
                            setTimeout(() => {
                                const angle = Math.random() * Math.PI * 2;
                                const proj = new Projectile(this.x, this.y, angle, 10, 'player');
                                proj.homing = true;
                                projectiles.push(proj);
                            }, i * 50);
                        }
                        break;
                        
                    case 'divineShield':
                        this.invincible = true;
                        setTimeout(() => {
                            this.invincible = false;
                        }, 4000);
                        break;
                        
                    case 'stormCaller':
                        for (const enemy of currentRoom.enemies) {
                            enemy.takeDamage(100);
                            for (let i = 0; i < 20; i++) {
                                particles.push(new Particle(
                                    enemy.x, enemy.y, '#ffff00',
                                    (Math.random() - 0.5) * 10,
                                    (Math.random() - 0.5) * 10,
                                    30
                                ));
                            }
                        }
                        if (currentRoom.boss) {
                            currentRoom.boss.takeDamage(100);
                        }
                        break;
                        
                    case 'timestrike':
                        for (const enemy of currentRoom.enemies) {
                            enemy.frozen = true;
                            setTimeout(() => enemy.frozen = false, 5000);
                        }
                        if (currentRoom.boss) {
                            currentRoom.boss.frozen = true;
                            setTimeout(() => currentRoom.boss.frozen = false, 5000);
                        }
                        break;
                        
                    case 'soulReaper':
                        for (const enemy of currentRoom.enemies) {
                            enemy.health = 0;
                            for (let i = 0; i < 30; i++) {
                                particles.push(new Particle(
                                    enemy.x, enemy.y, '#8b008b',
                                    (Math.random() - 0.5) * 15,
                                    (Math.random() - 0.5) * 15,
                                    40
                                ));
                            }
                        }
                        break;
                        
                    case 'ragnarok':
                        for (const enemy of currentRoom.enemies) {
                            enemy.takeDamage(200);
                        }
                        if (currentRoom.boss) {
                            currentRoom.boss.takeDamage(200);
                        }
                        for (let i = 0; i < 200; i++) {
                            particles.push(new Particle(
                                Math.random() * canvas.width,
                                Math.random() * canvas.height,
                                ['#ff0000', '#ff8800', '#ffff00'][Math.floor(Math.random() * 3)],
                                (Math.random() - 0.5) * 20,
                                (Math.random() - 0.5) * 20,
                                50
                            ));
                        }
                        break;
                        
                    // NEW MYTHIC IMPLEMENTATIONS
                    case 'apocalypse':
                        // 🔥 APOCALYPSE - THE END TIMES 🔥
                        // Phase 1: Blood red sky
                        for (let i = 0; i < 100; i++) {
                            setTimeout(() => {
                                particles.push(new Particle(
                                    Math.random() * canvas.width,
                                    0,
                                    '#8b0000',
                                    0,
                                    Math.random() * 5 + 2,
                                    50
                                ));
                            }, i * 10);
                        }
                        
                        // Phase 2: Meteor storms - 10 WAVES!
                        for (let wave = 0; wave < 10; wave++) {
                            setTimeout(() => {
                                // Warning indicators
                                for (let i = 0; i < 15; i++) {
                                    const x = Math.random() * canvas.width;
                                    // Red targeting beam
                                    for (let j = 0; j < 20; j++) {
                                        particles.push(new Particle(
                                            x + (Math.random() - 0.5) * 20,
                                            j * 40,
                                            '#ff0000',
                                            0, 0, 15
                                        ));
                                    }
                                    // Meteor strike
                                    setTimeout(() => {
                                        projectiles.push(new Projectile(x, 0, Math.PI / 2, 20 + wave * 2, 'player'));
                                        // Meteor trail
                                        for (let t = 0; t < 10; t++) {
                                            particles.push(new Particle(
                                                x + (Math.random() - 0.5) * 30,
                                                t * 40,
                                                ['#ff8800', '#ff4500', '#ff0000'][Math.floor(Math.random() * 3)],
                                                (Math.random() - 0.5) * 5,
                                                5,
                                                40
                                            ));
                                        }
                                    }, 300);
                                }
                                
                                // Ground explosions everywhere
                                for (let i = 0; i < 80; i++) {
                                    setTimeout(() => {
                                        particles.push(new Particle(
                                            Math.random() * canvas.width,
                                            canvas.height - 50,
                                            ['#ff0000', '#ff4500', '#ff8800', '#ffff00'][Math.floor(Math.random() * 4)],
                                            (Math.random() - 0.5) * 30,
                                            -Math.random() * 25,
                                            70
                                        ));
                                    }, i * 15);
                                }
                                
                                // Damage all enemies
                                for (const enemy of currentRoom.enemies) {
                                    enemy.takeDamage(60);
                                    // Fire particles on enemies
                                    for (let i = 0; i < 20; i++) {
                                        particles.push(new Particle(
                                            enemy.x + (Math.random() - 0.5) * 40,
                                            enemy.y + (Math.random() - 0.5) * 40,
                                            '#ff4500',
                                            (Math.random() - 0.5) * 10,
                                            -Math.random() * 10,
                                            40
                                        ));
                                    }
                                }
                                if (currentRoom.boss) {
                                    currentRoom.boss.takeDamage(60);
                                    for (let i = 0; i < 40; i++) {
                                        particles.push(new Particle(
                                            currentRoom.boss.x + (Math.random() - 0.5) * 80,
                                            currentRoom.boss.y + (Math.random() - 0.5) * 80,
                                            '#ff0000',
                                            (Math.random() - 0.5) * 15,
                                            -Math.random() * 15,
                                            50
                                        ));
                                    }
                                }
                            }, wave * 600);
                        }
                        
                        // Phase 3: Ground cracks and lava
                        setTimeout(() => {
                            for (let i = 0; i < 200; i++) {
                                setTimeout(() => {
                                    particles.push(new Particle(
                                        Math.random() * canvas.width,
                                        canvas.height - 50,
                                        ['#ff4500', '#ff8800', '#8b0000'][Math.floor(Math.random() * 3)],
                                        (Math.random() - 0.5) * 8,
                                        -Math.random() * 15 - 5,
                                        60
                                    ));
                                }, i * 30);
                            }
                        }, 3000);
                        
                        // Phase 4: Final judgment - pillars of fire
                        setTimeout(() => {
                            for (let i = 0; i < 10; i++) {
                                setTimeout(() => {
                                    const pillarX = (canvas.width / 10) * i + 50;
                                    // Fire pillar
                                    for (let j = 0; j < 25; j++) {
                                        for (let thick = -20; thick <= 20; thick += 10) {
                                            particles.push(new Particle(
                                                pillarX + thick,
                                                canvas.height - j * 35,
                                                ['#ff0000', '#ff8800', '#ffff00'][j % 3],
                                                (Math.random() - 0.5) * 5,
                                                -15,
                                                50
                                            ));
                                        }
                                    }
                                }, i * 150);
                            }
                        }, 5000);
                        break;
                        
                    case 'universeRewrite':
                        // 🌌 UNIVERSE REWRITE - REWRITE REALITY 🌌
                        // Phase 1: Reality fragmenting
                        for (let i = 0; i < 80; i++) {
                            setTimeout(() => {
                                // Screen glitch effect
                                for (let j = 0; j < 25; j++) {
                                    particles.push(new Particle(
                                        Math.random() * canvas.width,
                                        Math.random() * canvas.height,
                                        ['#ff00ff', '#00ffff', '#ffff00', '#ff0000', '#00ff00', '#0000ff'][Math.floor(Math.random() * 6)],
                                        (Math.random() - 0.5) * 30,
                                        (Math.random() - 0.5) * 30,
                                        25
                                    ));
                                }
                            }, i * 25);
                        }
                        
                        // Phase 2: Reality rewrite waves
                        if (currentRoom.boss) {
                            const bossX = currentRoom.boss.x;
                            const bossY = currentRoom.boss.y;
                            
                            for (let wave = 0; wave < 20; wave++) {
                                setTimeout(() => {
                                    // Expanding rewrite wave
                                    for (let i = 0; i < 48; i++) {
                                        const angle = (Math.PI * 2 / 48) * i;
                                        particles.push(new Particle(
                                            bossX + Math.cos(angle) * wave * 30,
                                            bossY + Math.sin(angle) * wave * 30,
                                            ['#ff00ff', '#00ffff', '#ffffff'][wave % 3],
                                            Math.cos(angle) * 5,
                                            Math.sin(angle) * 5,
                                            35
                                        ));
                                    }
                                }, wave * 50);
                            }
                            
                            // Phase 3: Boss health manipulation
                            setTimeout(() => {
                                // Drain boss health with particles
                                const healthDrain = setInterval(() => {
                                    if (currentRoom.boss && currentRoom.boss.health > 1) {
                                        currentRoom.boss.health = Math.max(1, currentRoom.boss.health - 50);
                                        // Drain particles
                                        for (let i = 0; i < 15; i++) {
                                            particles.push(new Particle(
                                                currentRoom.boss.x + (Math.random() - 0.5) * 60,
                                                currentRoom.boss.y + (Math.random() - 0.5) * 60,
                                                ['#ff00ff', '#8b008b'][Math.floor(Math.random() * 2)],
                                                (Math.random() - 0.5) * 10,
                                                -Math.random() * 15,
                                                40
                                            ));
                                        }
                                    }
                                }, 100);
                                
                                setTimeout(() => {
                                    clearInterval(healthDrain);
                                    if (currentRoom.boss) {
                                        currentRoom.boss.health = 1;
                                        // Final rewrite flash
                                        for (let i = 0; i < 200; i++) {
                                            particles.push(new Particle(
                                                currentRoom.boss.x + (Math.random() - 0.5) * 250,
                                                currentRoom.boss.y + (Math.random() - 0.5) * 250,
                                                '#ffffff',
                                                (Math.random() - 0.5) * 25,
                                                (Math.random() - 0.5) * 25,
                                                60
                                            ));
                                        }
                                    }
                                }, 1500);
                            }, 1000);
                        }
                        
                        // Phase 4: All enemies weakened
                        setTimeout(() => {
                            for (const enemy of currentRoom.enemies) {
                                enemy.health = Math.min(enemy.health, 10);
                                // Weakness particles
                                for (let i = 0; i < 30; i++) {
                                    particles.push(new Particle(
                                        enemy.x + (Math.random() - 0.5) * 50,
                                        enemy.y + (Math.random() - 0.5) * 50,
                                        '#8b008b',
                                        (Math.random() - 0.5) * 12,
                                        (Math.random() - 0.5) * 12,
                                        40
                                    ));
                                }
                            }
                        }, 2500);
                        break;
                        
                    case 'omnipotence':
                        // 👑 OMNIPOTENCE - BECOME AN UNSTOPPABLE GOD 👑
                        this.invincible = true;
                        this.damageMultiplier = 10;
                        this.speed *= 2;
                        
                        // Phase 1: Godly transformation
                        for (let i = 0; i < 60; i++) {
                            setTimeout(() => {
                                // Ascending particles
                                for (let j = 0; j < 15; j++) {
                                    particles.push(new Particle(
                                        this.x + (Math.random() - 0.5) * 80,
                                        this.y + 100 - i * 3,
                                        '#ffd700',
                                        0,
                                        -8,
                                        40
                                    ));
                                }
                            }, i * 20);
                        }
                        
                        // Phase 2: Continuous god aura
                        const omnipotenceInterval = setInterval(() => {
                            // Triple layer golden aura
                            for (let layer = 1; layer <= 3; layer++) {
                                for (let i = 0; i < 16; i++) {
                                    const angle = (Math.PI * 2 / 16) * i + Date.now() / (200 * layer);
                                    particles.push(new Particle(
                                        this.x + Math.cos(angle) * (50 * layer),
                                        this.y + Math.sin(angle) * (50 * layer),
                                        ['#ffd700', '#ffaa00', '#ff8800'][layer - 1],
                                        Math.cos(angle) * 3,
                                        Math.sin(angle) * 3,
                                        35
                                    ));
                                }
                            }
                            
                            // Holy light beams from player
                            if (Math.random() < 0.3) {
                                const beamAngle = Math.random() * Math.PI * 2;
                                for (let i = 0; i < 20; i++) {
                                    particles.push(new Particle(
                                        this.x + Math.cos(beamAngle) * i * 15,
                                        this.y + Math.sin(beamAngle) * i * 15,
                                        '#ffffff',
                                        0, 0, 25
                                    ));
                                }
                            }
                            
                            // Crown particles above player
                            for (let i = 0; i < 8; i++) {
                                const crownAngle = (Math.PI * 2 / 8) * i;
                                particles.push(new Particle(
                                    this.x + Math.cos(crownAngle) * 40,
                                    this.y - 60 - Math.abs(Math.sin(Date.now() / 200)) * 20,
                                    '#ffd700',
                                    0, 0, 20
                                ));
                            }
                            
                            // Damage aura - hurts nearby enemies
                            for (const enemy of currentRoom.enemies) {
                                const dist = Math.sqrt((enemy.x - this.x)**2 + (enemy.y - this.y)**2);
                                if (dist < 150) {
                                    enemy.takeDamage(3);
                                    // Smite particles
                                    for (let i = 0; i < 3; i++) {
                                        particles.push(new Particle(
                                            enemy.x + (Math.random() - 0.5) * 30,
                                            enemy.y + (Math.random() - 0.5) * 30,
                                            '#ffff00',
                                            (Math.random() - 0.5) * 8,
                                            -Math.random() * 8,
                                            25
                                        ));
                                    }
                                }
                            }
                        }, 50);
                        
                        // Phase 3: Divine projectiles
                        const divineProjectiles = setInterval(() => {
                            // Auto-fire divine bolts at enemies
                            if (currentRoom.enemies.length > 0) {
                                const target = currentRoom.enemies[Math.floor(Math.random() * currentRoom.enemies.length)];
                                const angle = Math.atan2(target.y - this.y, target.x - this.x);
                                projectiles.push(new Projectile(this.x, this.y, angle, 15, 'player'));
                                // Holy trail
                                for (let i = 0; i < 8; i++) {
                                    particles.push(new Particle(
                                        this.x + Math.cos(angle) * i * 10,
                                        this.y + Math.sin(angle) * i * 10,
                                        '#ffff00',
                                        0, 0, 20
                                    ));
                                }
                            }
                        }, 200);
                        
                        // Phase 4: End of omnipotence
                        setTimeout(() => {
                            this.invincible = false;
                            this.damageMultiplier = 1;
                            this.speed /= 2;
                            clearInterval(omnipotenceInterval);
                            clearInterval(divineProjectiles);
                            
                            // Descension particles
                            for (let i = 0; i < 100; i++) {
                                particles.push(new Particle(
                                    this.x + (Math.random() - 0.5) * 120,
                                    this.y + (Math.random() - 0.5) * 120,
                                    ['#ffd700', '#ffaa00'][Math.floor(Math.random() * 2)],
                                    (Math.random() - 0.5) * 15,
                                    Math.random() * 10,
                                    50
                                ));
                            }
                        }, 10000);
                        break;
                        
                    case 'galaxyCollapse':
                        // 🌌 GALAXY COLLAPSE - BLACK HOLE SINGULARITY 🌌
                        const centerX = canvas.width / 2;
                        const centerY = canvas.height / 2;
                        
                        // Phase 1: Black hole forming
                        for (let i = 0; i < 50; i++) {
                            setTimeout(() => {
                                // Swirling dark matter
                                for (let j = 0; j < 20; j++) {
                                    const angle = (Math.PI * 2 / 20) * j + (i * 0.2);
                                    const dist = 300 - (i * 5);
                                    particles.push(new Particle(
                                        centerX + Math.cos(angle) * dist,
                                        centerY + Math.sin(angle) * dist,
                                        ['#4b0082', '#000080', '#000000'][Math.floor(Math.random() * 3)],
                                        -Math.cos(angle) * 6,
                                        -Math.sin(angle) * 6,
                                        30
                                    ));
                                }
                                
                                // Growing darkness at center
                                for (let k = 0; k < 15; k++) {
                                    particles.push(new Particle(
                                        centerX + (Math.random() - 0.5) * i * 2,
                                        centerY + (Math.random() - 0.5) * i * 2,
                                        '#000000',
                                        0, 0, 35
                                    ));
                                }
                            }, i * 40);
                        }
                        
                        // Phase 2: Gravitational pull - enemies sucked in!
                        for (let i = 0; i < 90; i++) {
                            setTimeout(() => {
                                for (const enemy of currentRoom.enemies) {
                                    const dx = centerX - enemy.x;
                                    const dy = centerY - enemy.y;
                                    const dist = Math.sqrt(dx * dx + dy * dy);
                                    const pullStrength = Math.min(0.15, 300 / dist);
                                    enemy.x += dx * pullStrength;
                                    enemy.y += dy * pullStrength;
                                    
                                    // Stretching effect particles
                                    if (i % 3 === 0) {
                                        particles.push(new Particle(
                                            enemy.x,
                                            enemy.y,
                                            ['#4b0082', '#8b008b'][Math.floor(Math.random() * 2)],
                                            dx * 0.2,
                                            dy * 0.2,
                                            25
                                        ));
                                    }
                                }
                                
                                if (currentRoom.boss) {
                                    const dx = centerX - currentRoom.boss.x;
                                    const dy = centerY - currentRoom.boss.y;
                                    const dist = Math.sqrt(dx * dx + dy * dy);
                                    const pullStrength = Math.min(0.08, 200 / dist);
                                    currentRoom.boss.x += dx * pullStrength;
                                    currentRoom.boss.y += dy * pullStrength;
                                }
                                
                                // Accretion disk particles
                                const diskAngle = (i / 90) * Math.PI * 12;
                                for (let j = 0; j < 8; j++) {
                                    const radius = 100 + j * 20;
                                    particles.push(new Particle(
                                        centerX + Math.cos(diskAngle + j * 0.5) * radius,
                                        centerY + Math.sin(diskAngle + j * 0.5) * radius,
                                        ['#9400d3', '#4b0082', '#8b008b'][j % 3],
                                        0, 0, 25
                                    ));
                                }
                            }, i * 25);
                        }
                        
                        // Phase 3: Singularity collapse - MASSIVE EXPLOSION
                        setTimeout(() => {
                            // White flash
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                            
                            // Damage everything
                            for (const enemy of currentRoom.enemies) {
                                enemy.takeDamage(400);
                            }
                            if (currentRoom.boss) currentRoom.boss.takeDamage(400);
                            
                            // Explosion waves
                            for (let wave = 0; wave < 25; wave++) {
                                setTimeout(() => {
                                    for (let i = 0; i < 40; i++) {
                                        const angle = (Math.PI * 2 / 40) * i;
                                        particles.push(new Particle(
                                            centerX + Math.cos(angle) * wave * 35,
                                            centerY + Math.sin(angle) * wave * 35,
                                            ['#ffffff', '#9400d3', '#4b0082', '#8b008b'][wave % 4],
                                            Math.cos(angle) * 15,
                                            Math.sin(angle) * 15,
                                            50
                                        ));
                                    }
                                    
                                    // Ring projectiles
                                    if (wave % 3 === 0) {
                                        for (let i = 0; i < 24; i++) {
                                            const angle = (Math.PI * 2 / 24) * i;
                                            projectiles.push(new Projectile(
                                                centerX,
                                                centerY,
                                                angle,
                                                12 + wave * 0.5,
                                                'player'
                                            ));
                                        }
                                    }
                                }, wave * 60);
                            }
                            
                            // Massive central explosion
                            for (let i = 0; i < 400; i++) {
                                particles.push(new Particle(
                                    centerX,
                                    centerY,
                                    ['#ffffff', '#9400d3', '#4b0082', '#8b008b', '#000000'][Math.floor(Math.random() * 5)],
                                    (Math.random() - 0.5) * 40,
                                    (Math.random() - 0.5) * 40,
                                    80
                                ));
                            }
                        }, 2250);
                        
                        // Phase 4: Aftermath - space dust
                        setTimeout(() => {
                            for (let i = 0; i < 200; i++) {
                                setTimeout(() => {
                                    particles.push(new Particle(
                                        Math.random() * canvas.width,
                                        Math.random() * canvas.height,
                                        ['#9400d3', '#4b0082'][Math.floor(Math.random() * 2)],
                                        (Math.random() - 0.5) * 8,
                                        (Math.random() - 0.5) * 8,
                                        60
                                    ));
                                }, i * 25);
                            }
                        }, 3750);
                        break;
                        
                    case 'voidAnnihilation':
                        // ⚫ VOID ANNIHILATION - ERASE FROM EXISTENCE ⚫
                        // Phase 1: Void spreading across screen
                        for (let i = 0; i < 100; i++) {
                            setTimeout(() => {
                                // Creeping darkness
                                for (let j = 0; j < 30; j++) {
                                    particles.push(new Particle(
                                        Math.random() * canvas.width,
                                        Math.random() * canvas.height,
                                        '#000000',
                                        (Math.random() - 0.5) * 15,
                                        (Math.random() - 0.5) * 15,
                                        45
                                    ));
                                }
                            }, i * 15);
                        }
                        
                        // Phase 2: Dark tendrils reaching for enemies
                        for (const enemy of currentRoom.enemies) {
                            setTimeout(() => {
                                // Tendrils from all directions
                                for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
                                    for (let dist = 0; dist < 150; dist += 15) {
                                        setTimeout(() => {
                                            particles.push(new Particle(
                                                enemy.x + Math.cos(angle) * (150 - dist),
                                                enemy.y + Math.sin(angle) * (150 - dist),
                                                '#000000',
                                                Math.cos(angle) * 8,
                                                Math.sin(angle) * 8,
                                                35
                                            ));
                                        }, dist * 5);
                                    }
                                }
                            }, Math.random() * 500);
                        }
                        
                        // Phase 3: Void consumption - enemies erased
                        setTimeout(() => {
                            for (let i = 0; i < currentRoom.enemies.length; i++) {
                                setTimeout(() => {
                                    if (i < currentRoom.enemies.length) {
                                        const enemy = currentRoom.enemies[i];
                                        
                                        // Erasure effect - particles being absorbed
                                        for (let j = 0; j < 100; j++) {
                                            setTimeout(() => {
                                                particles.push(new Particle(
                                                    enemy.x + (Math.random() - 0.5) * 60,
                                                    enemy.y + (Math.random() - 0.5) * 60,
                                                    ['#000000', '#1a1a1a', '#333333'][Math.floor(Math.random() * 3)],
                                                    (Math.random() - 0.5) * 20,
                                                    (Math.random() - 0.5) * 20,
                                                    50
                                                ));
                                            }, j * 8);
                                        }
                                        
                                        // Purple void energy
                                        for (let k = 0; k < 50; k++) {
                                            setTimeout(() => {
                                                particles.push(new Particle(
                                                    enemy.x + (Math.random() - 0.5) * 80,
                                                    enemy.y + (Math.random() - 0.5) * 80,
                                                    ['#8b008b', '#4b0082'][Math.floor(Math.random() * 2)],
                                                    (Math.random() - 0.5) * 15,
                                                    (Math.random() - 0.5) * 15,
                                                    40
                                                ));
                                            }, k * 10);
                                        }
                                        
                                        setTimeout(() => {
                                            enemy.health = 0;
                                        }, 800);
                                    }
                                }, i * 150);
                            }
                        }, 1500);
                        
                        // Phase 4: Boss severely weakened by void
                        if (currentRoom.boss) {
                            setTimeout(() => {
                                currentRoom.boss.takeDamage(500);
                                // Void corruption particles on boss
                                for (let i = 0; i < 150; i++) {
                                    particles.push(new Particle(
                                        currentRoom.boss.x + (Math.random() - 0.5) * 120,
                                        currentRoom.boss.y + (Math.random() - 0.5) * 120,
                                        ['#000000', '#8b008b', '#4b0082'][Math.floor(Math.random() * 3)],
                                        (Math.random() - 0.5) * 18,
                                        (Math.random() - 0.5) * 18,
                                        60
                                    ));
                                }
                            }, 2000);
                        }
                        
                        // Phase 5: Void receding
                        setTimeout(() => {
                            for (let i = 0; i < 100; i++) {
                                setTimeout(() => {
                                    particles.push(new Particle(
                                        Math.random() * canvas.width,
                                        Math.random() * canvas.height,
                                        '#000000',
                                        0,
                                        Math.random() * 10 + 5,
                                        40
                                    ));
                                }, i * 20);
                            }
                        }, 3500);
                        break;
                        
                    case 'dimensionRift':
                        // 🌀 DIMENSION RIFT - TEAR REALITY APART 🌀
                        for (let i = 0; i < 8; i++) {
                            setTimeout(() => {
                                const riftX = Math.random() * canvas.width;
                                const riftY = Math.random() * (canvas.height - 100) + 50;
                                
                                // Phase 1: Reality tearing open
                                for (let j = 0; j < 150; j++) {
                                    setTimeout(() => {
                                        // Spiral rift opening
                                        const angle = (j / 150) * Math.PI * 8 + Date.now() / 100;
                                        const dist = (j / 150) * 80;
                                        particles.push(new Particle(
                                            riftX + Math.cos(angle) * dist,
                                            riftY + Math.sin(angle) * dist,
                                            ['#8b008b', '#4b0082', '#000000'][Math.floor(Math.random() * 3)],
                                            -Math.cos(angle) * 3,
                                            -Math.sin(angle) * 3,
                                            35
                                        ));
                                        
                                        // Void particles being sucked in
                                        if (j % 3 === 0) {
                                            const voidAngle = Math.random() * Math.PI * 2;
                                            particles.push(new Particle(
                                                riftX + Math.cos(voidAngle) * 150,
                                                riftY + Math.sin(voidAngle) * 150,
                                                '#000000',
                                                -Math.cos(voidAngle) * 8,
                                                -Math.sin(voidAngle) * 8,
                                                25
                                            ));
                                        }
                                    }, j * 8);
                                }
                                
                                // Phase 2: Portal fully open - lightning around edges
                                setTimeout(() => {
                                    for (let k = 0; k < 30; k++) {
                                        setTimeout(() => {
                                            const edgeAngle = (k / 30) * Math.PI * 2;
                                            // Lightning bolts
                                            for (let m = 0; m < 8; m++) {
                                                particles.push(new Particle(
                                                    riftX + Math.cos(edgeAngle) * (60 + m * 10),
                                                    riftY + Math.sin(edgeAngle) * (60 + m * 10),
                                                    '#ff00ff',
                                                    (Math.random() - 0.5) * 5,
                                                    (Math.random() - 0.5) * 5,
                                                    15
                                                ));
                                            }
                                        }, k * 30);
                                    }
                                }, 1200);
                                
                                // Phase 3: Vacuum effect - suck enemies in!
                                setTimeout(() => {
                                    const pullInterval = setInterval(() => {
                                        for (const enemy of currentRoom.enemies) {
                                            const dist = Math.sqrt((enemy.x - riftX)**2 + (enemy.y - riftY)**2);
                                            if (dist < 200) {
                                                // Pull towards rift
                                                const dx = riftX - enemy.x;
                                                const dy = riftY - enemy.y;
                                                enemy.x += dx * 0.08;
                                                enemy.y += dy * 0.08;
                                                
                                                // Stretching/distortion particles
                                                particles.push(new Particle(
                                                    enemy.x,
                                                    enemy.y,
                                                    ['#8b008b', '#ff00ff'][Math.floor(Math.random() * 2)],
                                                    dx * 0.3,
                                                    dy * 0.3,
                                                    20
                                                ));
                                            }
                                        }
                                        if (currentRoom.boss) {
                                            const bossDist = Math.sqrt((currentRoom.boss.x - riftX)**2 + (currentRoom.boss.y - riftY)**2);
                                            if (bossDist < 200) {
                                                const dx = riftX - currentRoom.boss.x;
                                                const dy = riftY - currentRoom.boss.y;
                                                currentRoom.boss.x += dx * 0.04;
                                                currentRoom.boss.y += dy * 0.04;
                                            }
                                        }
                                    }, 50);
                                    
                                    setTimeout(() => clearInterval(pullInterval), 1500);
                                }, 1200);
                                
                                // Phase 4: Banishment - enemies touched by rift are DELETED
                                setTimeout(() => {
                                    for (let k = currentRoom.enemies.length - 1; k >= 0; k--) {
                                        const enemy = currentRoom.enemies[k];
                                        const dist = Math.sqrt((enemy.x - riftX)**2 + (enemy.y - riftY)**2);
                                        if (dist < 100) {
                                            // Disintegration effect
                                            for (let p = 0; p < 60; p++) {
                                                particles.push(new Particle(
                                                    enemy.x + (Math.random() - 0.5) * 40,
                                                    enemy.y + (Math.random() - 0.5) * 40,
                                                    ['#000000', '#8b008b', '#4b0082'][Math.floor(Math.random() * 3)],
                                                    (Math.random() - 0.5) * 20,
                                                    (Math.random() - 0.5) * 20,
                                                    50
                                                ));
                                            }
                                            currentRoom.enemies.splice(k, 1);
                                        }
                                    }
                                    if (currentRoom.boss) {
                                        const bossDist = Math.sqrt((currentRoom.boss.x - riftX)**2 + (currentRoom.boss.y - riftY)**2);
                                        if (bossDist < 100) {
                                            currentRoom.boss.takeDamage(300);
                                        }
                                    }
                                    
                                    // Portal closing effect
                                    for (let c = 0; c < 50; c++) {
                                        setTimeout(() => {
                                            const closeAngle = (c / 50) * Math.PI * 4;
                                            particles.push(new Particle(
                                                riftX + Math.cos(closeAngle) * (50 - c),
                                                riftY + Math.sin(closeAngle) * (50 - c),
                                                '#8b008b',
                                                0, 0, 25
                                            ));
                                        }, c * 10);
                                    }
                                }, 2700);
                            }, i * 1000);
                        }
                        break;
                        
                    case 'deathStar':
                        // 🛸 DEATH STAR - ORBITAL ANNIHILATION LASER 🛸
                        // Phase 1: Targeting system activating
                        for (let i = 0; i < 30; i++) {
                            setTimeout(() => {
                                // Targeting reticles on all enemies
                                for (const enemy of currentRoom.enemies) {
                                    particles.push(new Particle(
                                        enemy.x + (Math.random() - 0.5) * 50,
                                        enemy.y - 100 - i * 10,
                                        '#ff0000',
                                        0, 5, 15
                                    ));
                                }
                                // Red warning lights across top
                                for (let j = 0; j < 20; j++) {
                                    particles.push(new Particle(
                                        j * (canvas.width / 20),
                                        20,
                                        '#ff0000',
                                        0, 0, 10
                                    ));
                                }
                            }, i * 30);
                        }
                        
                        // Phase 2: LASER SWEEP DESTRUCTION
                        for (let sweep = 0; sweep < 5; sweep++) {
                            setTimeout(() => {
                                const startX = sweep % 2 === 0 ? 0 : canvas.width;
                                const direction = sweep % 2 === 0 ? 1 : -1;
                                
                                // Laser charge buildup at start position
                                for (let charge = 0; charge < 20; charge++) {
                                    setTimeout(() => {
                                        for (let j = 0; j < 15; j++) {
                                            particles.push(new Particle(
                                                startX + (Math.random() - 0.5) * 80,
                                                j * 50,
                                                '#00ffff',
                                                0, 0, 20
                                            ));
                                        }
                                    }, charge * 20);
                                }
                                
                                // Sweeping laser beam
                                setTimeout(() => {
                                    for (let i = 0; i < 60; i++) {
                                        setTimeout(() => {
                                            const laserX = startX + (direction * i * 25);
                                            
                                            // Main laser beam (thick!)
                                            for (let j = 0; j < 25; j++) {
                                                for (let thick = -15; thick <= 15; thick += 5) {
                                                    particles.push(new Particle(
                                                        laserX + thick,
                                                        j * 35,
                                                        ['#ffffff', '#00ffff', '#0088ff'][Math.abs(thick) / 5 % 3],
                                                        0, 8, 15
                                                    ));
                                                }
                                            }
                                            
                                            // Ground impact explosion
                                            for (let e = 0; e < 30; e++) {
                                                particles.push(new Particle(
                                                    laserX + (Math.random() - 0.5) * 60,
                                                    canvas.height - 50,
                                                    ['#ffffff', '#ffff00', '#ff8800'][Math.floor(Math.random() * 3)],
                                                    (Math.random() - 0.5) * 15,
                                                    -Math.random() * 20,
                                                    40
                                                ));
                                            }
                                            
                                            // Damage enemies in beam path
                                            for (const enemy of currentRoom.enemies) {
                                                if (Math.abs(enemy.x - laserX) < 40) {
                                                    enemy.takeDamage(35);
                                                    // Burn particles on enemy
                                                    for (let b = 0; b < 15; b++) {
                                                        particles.push(new Particle(
                                                            enemy.x + (Math.random() - 0.5) * 30,
                                                            enemy.y + (Math.random() - 0.5) * 30,
                                                            '#ff8800',
                                                            (Math.random() - 0.5) * 10,
                                                            (Math.random() - 0.5) * 10,
                                                            30
                                                        ));
                                                    }
                                                }
                                            }
                                            if (currentRoom.boss && Math.abs(currentRoom.boss.x - laserX) < 40) {
                                                currentRoom.boss.takeDamage(35);
                                                for (let b = 0; b < 20; b++) {
                                                    particles.push(new Particle(
                                                        currentRoom.boss.x + (Math.random() - 0.5) * 60,
                                                        currentRoom.boss.y + (Math.random() - 0.5) * 60,
                                                        '#ff0000',
                                                        (Math.random() - 0.5) * 15,
                                                        (Math.random() - 0.5) * 15,
                                                        35
                                                    ));
                                                }
                                            }
                                        }, i * 15);
                                    }
                                }, 400);
                            }, sweep * 2000);
                        }
                        
                        // Phase 3: Final orbital strike
                        setTimeout(() => {
                            for (let i = 0; i < 12; i++) {
                                setTimeout(() => {
                                    const strikeX = (canvas.width / 12) * i;
                                    // Massive beam
                                    for (let j = 0; j < 30; j++) {
                                        for (let thick = -25; thick <= 25; thick += 5) {
                                            particles.push(new Particle(
                                                strikeX + thick,
                                                j * 30,
                                                '#ffffff',
                                                0, 12, 20
                                            ));
                                        }
                                    }
                                    // Ground explosion
                                    for (let e = 0; e < 50; e++) {
                                        particles.push(new Particle(
                                            strikeX + (Math.random() - 0.5) * 100,
                                            canvas.height - 50,
                                            ['#ffffff', '#ffff00', '#ff0000'][Math.floor(Math.random() * 3)],
                                            (Math.random() - 0.5) * 25,
                                            -Math.random() * 30,
                                            50
                                        ));
                                    }
                                }, i * 100);
                            }
                        }, 10000);
                        break;
                        
                    case 'bigBang':
                        // 💥 BIG BANG - UNIVERSE-ENDING EXPLOSION 💥
                        const bangX = canvas.width / 2;
                        const bangY = canvas.height / 2;
                        
                        // Phase 1: Singularity formation (everything converges)
                        for (let i = 0; i < 50; i++) {
                            setTimeout(() => {
                                // Pull in from all directions
                                for (let j = 0; j < 20; j++) {
                                    const angle = (Math.PI * 2 / 20) * j;
                                    const dist = 400 - (i * 7);
                                    particles.push(new Particle(
                                        bangX + Math.cos(angle) * dist,
                                        bangY + Math.sin(angle) * dist,
                                        '#ffffff',
                                        -Math.cos(angle) * 12,
                                        -Math.sin(angle) * 12,
                                        15
                                    ));
                                }
                                // Growing singularity
                                for (let k = 0; k < 12; k++) {
                                    particles.push(new Particle(
                                        bangX + (Math.random() - 0.5) * i,
                                        bangY + (Math.random() - 0.5) * i,
                                        '#000000',
                                        0, 0, 20
                                    ));
                                }
                            }, i * 25);
                        }
                        
                        // Phase 2: THE BIG BANG EXPLOSION!
                        setTimeout(() => {
                            // Screen flash white
                            ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                            
                            // Reality-shattering particles in ALL directions
                            for (let i = 0; i < 1000; i++) {
                                const angle = Math.random() * Math.PI * 2;
                                const speed = 20 + Math.random() * 30;
                                particles.push(new Particle(
                                    bangX,
                                    bangY,
                                    ['#ffffff', '#ffff00', '#ff8800', '#ff0000', '#ff00ff', '#00ffff'][Math.floor(Math.random() * 6)],
                                    Math.cos(angle) * speed,
                                    Math.sin(angle) * speed,
                                    100
                                ));
                            }
                            
                            // Expanding shockwave rings
                            for (let ring = 0; ring < 20; ring++) {
                                setTimeout(() => {
                                    for (let i = 0; i < 48; i++) {
                                        const angle = (Math.PI * 2 / 48) * i;
                                        const ringDist = ring * 40;
                                        particles.push(new Particle(
                                            bangX + Math.cos(angle) * ringDist,
                                            bangY + Math.sin(angle) * ringDist,
                                            ['#ffffff', '#ffffaa'][ring % 2],
                                            Math.cos(angle) * 15,
                                            Math.sin(angle) * 15,
                                            50
                                        ));
                                    }
                                }, ring * 50);
                            }
                            
                            // Energy waves in grid pattern
                            for (let i = 0; i < 15; i++) {
                                setTimeout(() => {
                                    // Vertical waves
                                    for (let x = 0; x < canvas.width; x += 40) {
                                        particles.push(new Particle(x, 0, '#ffff00', 0, 20, 30));
                                        particles.push(new Particle(x, canvas.height, '#ff8800', 0, -20, 30));
                                    }
                                    // Horizontal waves
                                    for (let y = 0; y < canvas.height; y += 40) {
                                        particles.push(new Particle(0, y, '#ff0000', 20, 0, 30));
                                        particles.push(new Particle(canvas.width, y, '#ff00ff', -20, 0, 30));
                                    }
                                }, i * 100);
                            }
                            
                            // Instant kill EVERYTHING
                            for (const enemy of currentRoom.enemies) {
                                enemy.health = 0;
                                // Vaporization effect
                                for (let i = 0; i < 50; i++) {
                                    particles.push(new Particle(
                                        enemy.x, enemy.y,
                                        '#ffffff',
                                        (Math.random() - 0.5) * 30,
                                        (Math.random() - 0.5) * 30,
                                        60
                                    ));
                                }
                            }
                            if (currentRoom.boss) {
                                currentRoom.boss.takeDamage(999);
                                for (let i = 0; i < 100; i++) {
                                    particles.push(new Particle(
                                        currentRoom.boss.x, currentRoom.boss.y,
                                        '#ffffff',
                                        (Math.random() - 0.5) * 40,
                                        (Math.random() - 0.5) * 40,
                                        80
                                    ));
                                }
                            }
                        }, 1250);
                        
                        // Phase 3: Universe rebirth particles
                        setTimeout(() => {
                            for (let i = 0; i < 500; i++) {
                                setTimeout(() => {
                                    particles.push(new Particle(
                                        Math.random() * canvas.width,
                                        Math.random() * canvas.height,
                                        ['#ffffff', '#aaaaff', '#ffaaff'][Math.floor(Math.random() * 3)],
                                        (Math.random() - 0.5) * 5,
                                        (Math.random() - 0.5) * 5,
                                        40
                                    ));
                                }, i * 10);
                            }
                        }, 2500);
                        break;
                        
                    case 'infinityGauntlet':
                        // 💎 INFINITY GAUNTLET - THE SNAP 💎
                        // Phase 1: Gauntlet charge up
                        for (let i = 0; i < 50; i++) {
                            setTimeout(() => {
                                // Six infinity stones orbiting player
                                const stoneColors = ['#ff0000', '#ff8800', '#ffff00', '#00ff00', '#0000ff', '#8b00ff'];
                                for (let j = 0; j < 6; j++) {
                                    const angle = (Math.PI * 2 / 6) * j + (i * 0.15);
                                    particles.push(new Particle(
                                        this.x + Math.cos(angle) * (80 - i),
                                        this.y + Math.sin(angle) * (80 - i),
                                        stoneColors[j],
                                        0, 0, 30
                                    ));
                                }
                                // Power buildup
                                for (let k = 0; k < 8; k++) {
                                    particles.push(new Particle(
                                        this.x + (Math.random() - 0.5) * 100,
                                        this.y + (Math.random() - 0.5) * 100,
                                        stoneColors[Math.floor(Math.random() * 6)],
                                        (Math.random() - 0.5) * 10,
                                        (Math.random() - 0.5) * 10,
                                        25
                                    ));
                                }
                            }, i * 30);
                        }
                        
                        // Phase 2: THE SNAP
                        setTimeout(() => {
                            // Screen flash
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                            
                            // Snap shockwave
                            for (let wave = 0; wave < 15; wave++) {
                                setTimeout(() => {
                                    for (let i = 0; i < 32; i++) {
                                        const angle = (Math.PI * 2 / 32) * i;
                                        particles.push(new Particle(
                                            this.x + Math.cos(angle) * wave * 50,
                                            this.y + Math.sin(angle) * wave * 50,
                                            '#ffffff',
                                            0, 0, 20
                                        ));
                                    }
                                }, wave * 40);
                            }
                            
                            // Snap away half of enemies
                            const toSnap = Math.ceil(currentRoom.enemies.length / 2);
                            const snappedIndices = [];
                            
                            // Select random enemies to snap
                            while (snappedIndices.length < toSnap && snappedIndices.length < currentRoom.enemies.length) {
                                const randomIndex = Math.floor(Math.random() * currentRoom.enemies.length);
                                if (!snappedIndices.includes(randomIndex)) {
                                    snappedIndices.push(randomIndex);
                                }
                            }
                            
                            // Disintegrate selected enemies
                            snappedIndices.sort((a, b) => b - a); // Sort descending to remove safely
                            for (let i = 0; i < snappedIndices.length; i++) {
                                setTimeout(() => {
                                    const idx = snappedIndices[i];
                                    if (idx < currentRoom.enemies.length) {
                                        const enemy = currentRoom.enemies[idx];
                                        
                                        // Disintegration effect
                                        for (let j = 0; j < 80; j++) {
                                            setTimeout(() => {
                                                particles.push(new Particle(
                                                    enemy.x + (Math.random() - 0.5) * 50,
                                                    enemy.y + (Math.random() - 0.5) * 50,
                                                    ['#ffd700', '#ff8800', '#8b4513', '#654321'][Math.floor(Math.random() * 4)],
                                                    (Math.random() - 0.5) * 18,
                                                    (Math.random() - 0.5) * 18 - 5,
                                                    70
                                                ));
                                            }, j * 15);
                                        }
                                        
                                        // Ash particles falling
                                        setTimeout(() => {
                                            for (let k = 0; k < 50; k++) {
                                                particles.push(new Particle(
                                                    enemy.x + (Math.random() - 0.5) * 60,
                                                    enemy.y + (Math.random() - 0.5) * 60,
                                                    ['#8b4513', '#654321', '#888888'][Math.floor(Math.random() * 3)],
                                                    (Math.random() - 0.5) * 5,
                                                    Math.random() * 8 + 3,
                                                    100
                                                ));
                                            }
                                        }, 800);
                                        
                                        // Remove enemy
                                        setTimeout(() => {
                                            const currentIdx = currentRoom.enemies.indexOf(enemy);
                                            if (currentIdx !== -1) {
                                                currentRoom.enemies.splice(currentIdx, 1);
                                            }
                                        }, 1200);
                                    }
                                }, i * 250);
                            }
                            
                            // Boss takes heavy damage but doesn't get snapped
                            if (currentRoom.boss) {
                                setTimeout(() => {
                                    currentRoom.boss.takeDamage(300);
                                    for (let i = 0; i < 60; i++) {
                                        particles.push(new Particle(
                                            currentRoom.boss.x + (Math.random() - 0.5) * 80,
                                            currentRoom.boss.y + (Math.random() - 0.5) * 80,
                                            '#ffd700',
                                            (Math.random() - 0.5) * 15,
                                            (Math.random() - 0.5) * 15,
                                            50
                                        ));
                                    }
                                }, 1500);
                            }
                        }, 1500);
                        
                        // Phase 3: Reality settling
                        setTimeout(() => {
                            for (let i = 0; i < 100; i++) {
                                setTimeout(() => {
                                    particles.push(new Particle(
                                        Math.random() * canvas.width,
                                        Math.random() * canvas.height,
                                        ['#ffd700', '#ffaa00'][Math.floor(Math.random() * 2)],
                                        0,
                                        Math.random() * 3 + 1,
                                        80
                                    ));
                                }, i * 30);
                            }
                        }, 4000);
                        break;
                        
                    case 'judgmentDay':
                        // ⚡ JUDGMENT DAY - DIVINE WRATH FROM THE HEAVENS ⚡
                        // Phase 1: Darkening skies
                        for (let i = 0; i < 80; i++) {
                            setTimeout(() => {
                                particles.push(new Particle(
                                    Math.random() * canvas.width,
                                    0,
                                    ['#8b0000', '#696969', '#2f4f4f'][Math.floor(Math.random() * 3)],
                                    0,
                                    Math.random() * 8 + 2,
                                    40
                                ));
                            }, i * 15);
                        }
                        
                        // Phase 2: Divine judgment marks appear on enemies
                        for (let i = 0; i < currentRoom.enemies.length; i++) {
                            setTimeout(() => {
                                if (i < currentRoom.enemies.length) {
                                    const enemy = currentRoom.enemies[i];
                                    // Judgment circle above enemy
                                    for (let j = 0; j < 30; j++) {
                                        setTimeout(() => {
                                            const angle = (Math.PI * 2 / 30) * j;
                                            particles.push(new Particle(
                                                enemy.x + Math.cos(angle) * 40,
                                                enemy.y - 80 + Math.sin(Date.now() / 100) * 10,
                                                '#ffd700',
                                                0, 0, 25
                                            ));
                                        }, j * 20);
                                    }
                                }
                            }, i * 80);
                        }
                        
                        // Phase 3: Lightning strikes of judgment
                        for (let i = 0; i < currentRoom.enemies.length && i < 25; i++) {
                            setTimeout(() => {
                                if (i < currentRoom.enemies.length) {
                                    const enemy = currentRoom.enemies[i];
                                    
                                    // Lightning bolt warning
                                    for (let j = 0; j < 25; j++) {
                                        setTimeout(() => {
                                            particles.push(new Particle(
                                                enemy.x + (Math.random() - 0.5) * 40,
                                                j * 35,
                                                '#ffff00',
                                                0, 0, 20
                                            ));
                                        }, j * 15);
                                    }
                                    
                                    // THE STRIKE
                                    setTimeout(() => {
                                        // Massive holy beam
                                        for (let j = 0; j < 30; j++) {
                                            for (let thick = -25; thick <= 25; thick += 5) {
                                                particles.push(new Particle(
                                                    enemy.x + thick,
                                                    j * 30,
                                                    ['#ffffff', '#ffff00', '#ffd700'][Math.abs(thick) / 10 % 3],
                                                    0,
                                                    8,
                                                    45
                                                ));
                                            }
                                        }
                                        
                                        // Ground impact explosion
                                        for (let k = 0; k < 60; k++) {
                                            particles.push(new Particle(
                                                enemy.x + (Math.random() - 0.5) * 80,
                                                enemy.y + (Math.random() - 0.5) * 80,
                                                ['#ffffff', '#ffff00', '#ffd700'][Math.floor(Math.random() * 3)],
                                                (Math.random() - 0.5) * 20,
                                                (Math.random() - 0.5) * 20,
                                                50
                                            ));
                                        }
                                        
                                        enemy.takeDamage(180);
                                        
                                        // Cross-shaped light
                                        for (let cross = 0; cross < 4; cross++) {
                                            const crossAngle = (Math.PI / 2) * cross;
                                            for (let dist = 0; dist < 60; dist += 10) {
                                                particles.push(new Particle(
                                                    enemy.x + Math.cos(crossAngle) * dist,
                                                    enemy.y + Math.sin(crossAngle) * dist,
                                                    '#ffffff',
                                                    0, 0, 30
                                                ));
                                            }
                                        }
                                    }, 375);
                                }
                            }, i * 120);
                        }
                        
                        // Phase 4: Boss receives ULTIMATE JUDGMENT
                        if (currentRoom.boss) {
                            setTimeout(() => {
                                const bossX = currentRoom.boss.x;
                                const bossY = currentRoom.boss.y;
                                
                                // Massive judgment seal
                                for (let ring = 1; ring <= 5; ring++) {
                                    for (let i = 0; i < 48; i++) {
                                        const angle = (Math.PI * 2 / 48) * i;
                                        particles.push(new Particle(
                                            bossX + Math.cos(angle) * ring * 30,
                                            bossY - 120,
                                            '#ffd700',
                                            0, 0, 35
                                        ));
                                    }
                                }
                                
                                // Multiple lightning pillars
                                setTimeout(() => {
                                    for (let pillar = 0; pillar < 5; pillar++) {
                                        setTimeout(() => {
                                            const pillarX = bossX + (pillar - 2) * 40;
                                            // Thick lightning pillar
                                            for (let j = 0; j < 30; j++) {
                                                for (let thick = -30; thick <= 30; thick += 10) {
                                                    particles.push(new Particle(
                                                        pillarX + thick,
                                                        j * 35,
                                                        ['#ffffff', '#ffff00'][Math.abs(thick) / 15 % 2],
                                                        0,
                                                        10,
                                                        50
                                                    ));
                                                }
                                            }
                                        }, pillar * 100);
                                    }
                                    
                                    // Boss damage
                                    setTimeout(() => {
                                        currentRoom.boss.takeDamage(250);
                                        // Divine explosion
                                        for (let i = 0; i < 200; i++) {
                                            particles.push(new Particle(
                                                bossX + (Math.random() - 0.5) * 150,
                                                bossY + (Math.random() - 0.5) * 150,
                                                ['#ffffff', '#ffd700', '#ffff00'][Math.floor(Math.random() * 3)],
                                                (Math.random() - 0.5) * 25,
                                                (Math.random() - 0.5) * 25,
                                                70
                                            ));
                                        }
                                    }, 500);
                                }, 800);
                            }, 3000);
                        }
                        break;
                        
                    case 'cosmicPower':
                        // 🌌 COSMIC POWER - BECOME ONE WITH THE UNIVERSE 🌌
                        this.invincible = true;
                        this.damageMultiplier = 20;
                        this.speed *= 2.5;
                        
                        // Phase 1: Cosmic transformation
                        for (let i = 0; i < 60; i++) {
                            setTimeout(() => {
                                // Stars orbiting player
                                for (let j = 0; j < 12; j++) {
                                    const angle = (Math.PI * 2 / 12) * j + (i * 0.2);
                                    particles.push(new Particle(
                                        this.x + Math.cos(angle) * (100 - i),
                                        this.y + Math.sin(angle) * (100 - i),
                                        '#ffffff',
                                        0, 0, 30
                                    ));
                                }
                            }, i * 20);
                        }
                        
                        // Phase 2: Continuous cosmic effects
                        const cosmicInterval = setInterval(() => {
                            // Triple rainbow aura layers
                            for (let layer = 1; layer <= 3; layer++) {
                                for (let i = 0; i < 12; i++) {
                                    const angle = (Math.PI * 2 / 12) * i + Date.now() / (150 * layer);
                                    const colors = ['#ff0000', '#ff8800', '#ffff00', '#00ff00', '#00ffff', '#0000ff', '#8b00ff', '#ff00ff'];
                                    particles.push(new Particle(
                                        this.x + Math.cos(angle) * (60 * layer),
                                        this.y + Math.sin(angle) * (60 * layer),
                                        colors[(i + Math.floor(Date.now() / 100)) % colors.length],
                                        0, 0, 30
                                    ));
                                }
                            }
                            
                            // Nebula particles
                            for (let i = 0; i < 15; i++) {
                                particles.push(new Particle(
                                    this.x + (Math.random() - 0.5) * 150,
                                    this.y + (Math.random() - 0.5) * 150,
                                    ['#ff00ff', '#00ffff', '#ff8800', '#ffff00'][Math.floor(Math.random() * 4)],
                                    (Math.random() - 0.5) * 8,
                                    (Math.random() - 0.5) * 8,
                                    35
                                ));
                            }
                            
                            // Shooting stars from player
                            if (Math.random() < 0.4) {
                                const starAngle = Math.random() * Math.PI * 2;
                                for (let i = 0; i < 15; i++) {
                                    setTimeout(() => {
                                        particles.push(new Particle(
                                            this.x + Math.cos(starAngle) * i * 20,
                                            this.y + Math.sin(starAngle) * i * 20,
                                            '#ffffff',
                                            Math.cos(starAngle) * 15,
                                            Math.sin(starAngle) * 15,
                                            25
                                        ));
                                    }, i * 15);
                                }
                            }
                            
                            // Galaxy spiral
                            const spiralArms = 5;
                            for (let arm = 0; arm < spiralArms; arm++) {
                                for (let i = 0; i < 8; i++) {
                                    const angle = (Math.PI * 2 / spiralArms) * arm + (i * 0.3) + Date.now() / 500;
                                    const dist = 40 + i * 12;
                                    particles.push(new Particle(
                                        this.x + Math.cos(angle) * dist,
                                        this.y + Math.sin(angle) * dist,
                                        ['#9400d3', '#4b0082', '#0000cd'][i % 3],
                                        0, 0, 28
                                    ));
                                }
                            }
                            
                            // Cosmic damage aura
                            for (const enemy of currentRoom.enemies) {
                                const dist = Math.sqrt((enemy.x - this.x)**2 + (enemy.y - this.y)**2);
                                if (dist < 200) {
                                    enemy.takeDamage(5);
                                    // Star burst on enemy
                                    for (let i = 0; i < 5; i++) {
                                        const burstAngle = Math.random() * Math.PI * 2;
                                        particles.push(new Particle(
                                            enemy.x + Math.cos(burstAngle) * 30,
                                            enemy.y + Math.sin(burstAngle) * 30,
                                            ['#ffffff', '#ffff00', '#00ffff'][Math.floor(Math.random() * 3)],
                                            Math.cos(burstAngle) * 8,
                                            Math.sin(burstAngle) * 8,
                                            30
                                        ));
                                    }
                                }
                            }
                        }, 50);
                        
                        // Phase 3: Cosmic projectiles
                        const cosmicProjectiles = setInterval(() => {
                            // Auto-fire cosmic energy at all enemies
                            for (let i = 0; i < Math.min(3, currentRoom.enemies.length); i++) {
                                const target = currentRoom.enemies[i];
                                if (target) {
                                    const angle = Math.atan2(target.y - this.y, target.x - this.x);
                                    projectiles.push(new Projectile(this.x, this.y, angle, 18, 'player'));
                                    
                                    // Cosmic trail
                                    for (let j = 0; j < 12; j++) {
                                        particles.push(new Particle(
                                            this.x + Math.cos(angle) * j * 12,
                                            this.y + Math.sin(angle) * j * 12,
                                            ['#ff00ff', '#00ffff', '#ffff00'][j % 3],
                                            0, 0, 25
                                        ));
                                    }
                                }
                            }
                        }, 300);
                        
                        // Phase 4: Celestial comets
                        const cometInterval = setInterval(() => {
                            const cometAngle = Math.random() * Math.PI * 2;
                            const startDist = 400;
                            const cometX = this.x + Math.cos(cometAngle) * startDist;
                            const cometY = this.y + Math.sin(cometAngle) * startDist;
                            
                            projectiles.push(new Projectile(cometX, cometY, cometAngle + Math.PI, 20, 'player'));
                            
                            // Comet tail
                            for (let i = 0; i < 20; i++) {
                                setTimeout(() => {
                                    particles.push(new Particle(
                                        cometX - Math.cos(cometAngle) * i * 15,
                                        cometY - Math.sin(cometAngle) * i * 15,
                                        ['#ffffff', '#aaccff'][i % 2],
                                        0, 0, 35
                                    ));
                                }, i * 20);
                            }
                        }, 500);
                        
                        // Phase 5: End of cosmic power
                        setTimeout(() => {
                            this.invincible = false;
                            this.damageMultiplier = 1;
                            this.speed /= 2.5;
                            clearInterval(cosmicInterval);
                            clearInterval(cosmicProjectiles);
                            clearInterval(cometInterval);
                            
                            // Supernova farewell
                            for (let i = 0; i < 200; i++) {
                                particles.push(new Particle(
                                    this.x + (Math.random() - 0.5) * 200,
                                    this.y + (Math.random() - 0.5) * 200,
                                    ['#ff0000', '#ff8800', '#ffff00', '#00ff00', '#00ffff', '#0000ff', '#8b00ff'][Math.floor(Math.random() * 7)],
                                    (Math.random() - 0.5) * 25,
                                    (Math.random() - 0.5) * 25,
                                    60
                                ));
                            }
                        }, 8000);
                        break;
                        
                    case 'realityBend':
                        // 🌀 REALITY BEND - PHYSICS NO LONGER APPLY 🌀
                        // Phase 1: Reality glitching
                        for (let glitch = 0; glitch < 50; glitch++) {
                            setTimeout(() => {
                                // Screen glitch particles
                                for (let i = 0; i < 30; i++) {
                                    particles.push(new Particle(
                                        Math.random() * canvas.width,
                                        Math.random() * canvas.height,
                                        ['#ff00ff', '#00ffff', '#ffff00', '#ff0000', '#00ff00'][Math.floor(Math.random() * 5)],
                                        (Math.random() - 0.5) * 25,
                                        (Math.random() - 0.5) * 25,
                                        20
                                    ));
                                }
                            }, glitch * 30);
                        }
                        
                        // Phase 2: Gravity reversal waves
                        for (let wave = 0; wave < 8; wave++) {
                            setTimeout(() => {
                                // Upward projectiles
                                for (let i = 0; i < 12; i++) {
                                    const x = (canvas.width / 12) * i;
                                    projectiles.push(new Projectile(
                                        x,
                                        canvas.height,
                                        -Math.PI / 2,
                                        15,
                                        'player'
                                    ));
                                }
                                // Gravity flip particles
                                for (let i = 0; i < 50; i++) {
                                    particles.push(new Particle(
                                        Math.random() * canvas.width,
                                        canvas.height,
                                        '#ff00ff',
                                        (Math.random() - 0.5) * 10,
                                        -Math.random() * 25,
                                        40
                                    ));
                                }
                            }, wave * 200);
                        }
                        
                        // Phase 3: Projectile chaos from all directions
                        for (let i = 0; i < 80; i++) {
                            setTimeout(() => {
                                const side = Math.floor(Math.random() * 4);
                                let x, y, angle;
                                
                                switch(side) {
                                    case 0: // Top
                                        x = Math.random() * canvas.width;
                                        y = 0;
                                        angle = Math.PI / 2 + (Math.random() - 0.5);
                                        break;
                                    case 1: // Right
                                        x = canvas.width;
                                        y = Math.random() * canvas.height;
                                        angle = Math.PI + (Math.random() - 0.5);
                                        break;
                                    case 2: // Bottom
                                        x = Math.random() * canvas.width;
                                        y = canvas.height;
                                        angle = -Math.PI / 2 + (Math.random() - 0.5);
                                        break;
                                    case 3: // Left
                                        x = 0;
                                        y = Math.random() * canvas.height;
                                        angle = 0 + (Math.random() - 0.5);
                                        break;
                                }
                                
                                projectiles.push(new Projectile(x, y, angle, 12 + Math.random() * 8, 'player'));
                                
                                // Reality tear particles
                                for (let j = 0; j < 5; j++) {
                                    particles.push(new Particle(
                                        x + (Math.random() - 0.5) * 50,
                                        y + (Math.random() - 0.5) * 50,
                                        ['#ff00ff', '#00ffff', '#ffff00'][Math.floor(Math.random() * 3)],
                                        (Math.random() - 0.5) * 15,
                                        (Math.random() - 0.5) * 15,
                                        30
                                    ));
                                }
                            }, i * 40);
                        }
                        
                        // Phase 4: Spiral projectile vortexes
                        for (let vortex = 0; vortex < 4; vortex++) {
                            setTimeout(() => {
                                const vortexX = [100, canvas.width - 100, 100, canvas.width - 100][vortex];
                                const vortexY = [100, 100, canvas.height - 100, canvas.height - 100][vortex];
                                
                                for (let i = 0; i < 24; i++) {
                                    setTimeout(() => {
                                        const angle = (Math.PI * 2 / 24) * i + (vortex * Math.PI / 2);
                                        projectiles.push(new Projectile(
                                            vortexX,
                                            vortexY,
                                            angle,
                                            10,
                                            'player'
                                        ));
                                        // Vortex particles
                                        for (let j = 0; j < 8; j++) {
                                            const spiralAngle = angle + (j * 0.3);
                                            particles.push(new Particle(
                                                vortexX + Math.cos(spiralAngle) * j * 10,
                                                vortexY + Math.sin(spiralAngle) * j * 10,
                                                ['#ff00ff', '#00ffff'][j % 2],
                                                Math.cos(angle) * 8,
                                                Math.sin(angle) * 8,
                                                25
                                            ));
                                        }
                                    }, i * 50);
                                }
                            }, vortex * 600);
                        }
                        
                        // Phase 5: Reality stabilization
                        setTimeout(() => {
                            for (let i = 0; i < 100; i++) {
                                setTimeout(() => {
                                    particles.push(new Particle(
                                        Math.random() * canvas.width,
                                        Math.random() * canvas.height,
                                        '#ffffff',
                                        0, 0, 30
                                    ));
                                }, i * 20);
                            }
                        }, 3500);
                        break;
                        
                    case 'superNova':
                        // ⭐ SUPERNOVA - EXPLODE LIKE A DYING STAR ⭐
                        const supernovaX = canvas.width / 2;
                        const supernovaY = canvas.height / 2;
                        
                        // Phase 1: Core compression (pulling everything in)
                        for (let i = 0; i < 30; i++) {
                            setTimeout(() => {
                                // Implosion particles
                                for (let j = 0; j < 15; j++) {
                                    const angle = Math.random() * Math.PI * 2;
                                    const dist = 300 - (i * 8);
                                    particles.push(new Particle(
                                        supernovaX + Math.cos(angle) * dist,
                                        supernovaY + Math.sin(angle) * dist,
                                        '#ffffff',
                                        -Math.cos(angle) * 8,
                                        -Math.sin(angle) * 8,
                                        25
                                    ));
                                }
                                // Growing core
                                for (let k = 0; k < 8; k++) {
                                    const coreAngle = (Math.PI * 2 / 8) * k;
                                    particles.push(new Particle(
                                        supernovaX + Math.cos(coreAngle) * (i * 2),
                                        supernovaY + Math.sin(coreAngle) * (i * 2),
                                        ['#ffffff', '#ffff00', '#ff8800'][i % 3],
                                        0, 0, 30
                                    ));
                                }
                            }, i * 40);
                        }
                        
                        // Phase 2: SUPERNOVA EXPLOSION! (at center)
                        setTimeout(() => {
                            // Flash the screen white
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                            
                            // Expanding shockwave rings
                            for (let wave = 1; wave <= 15; wave++) {
                                setTimeout(() => {
                                    const waveRadius = wave * 50;
                                    // Circular shockwave
                                    for (let i = 0; i < 32; i++) {
                                        const angle = (Math.PI * 2 / 32) * i;
                                        projectiles.push(new Projectile(
                                            supernovaX + Math.cos(angle) * 20,
                                            supernovaY + Math.sin(angle) * 20,
                                            angle,
                                            10 + wave * 0.5,
                                            'player'
                                        ));
                                        
                                        // Particle trail
                                        for (let j = 0; j < 5; j++) {
                                            particles.push(new Particle(
                                                supernovaX + Math.cos(angle) * waveRadius,
                                                supernovaY + Math.sin(angle) * waveRadius,
                                                ['#ffffff', '#ffffaa', '#ffff00', '#ff8800', '#ff4400', '#ff0000'][wave % 6],
                                                Math.cos(angle) * wave * 2,
                                                Math.sin(angle) * wave * 2,
                                                50 - wave
                                            ));
                                        }
                                    }
                                    
                                    // Massive center explosion particles
                                    for (let i = 0; i < 80; i++) {
                                        particles.push(new Particle(
                                            supernovaX,
                                            supernovaY,
                                            ['#ffffff', '#ffff00', '#ff8800', '#ff0000', '#ff00ff'][Math.floor(Math.random() * 5)],
                                            (Math.random() - 0.5) * wave * 5,
                                            (Math.random() - 0.5) * wave * 5,
                                            60
                                        ));
                                    }
                                    
                                    // Damage everything caught in the wave
                                    for (const enemy of currentRoom.enemies) {
                                        const dist = Math.sqrt((enemy.x - supernovaX)**2 + (enemy.y - supernovaY)**2);
                                        if (dist < waveRadius + 50) {
                                            enemy.takeDamage(40);
                                        }
                                    }
                                    if (currentRoom.boss) {
                                        const bossDist = Math.sqrt((currentRoom.boss.x - supernovaX)**2 + (currentRoom.boss.y - supernovaY)**2);
                                        if (bossDist < waveRadius + 50) {
                                            currentRoom.boss.takeDamage(40);
                                        }
                                    }
                                }, wave * 80);
                            }
                            
                            // Phase 3: Lingering star death particles
                            for (let i = 0; i < 300; i++) {
                                setTimeout(() => {
                                    particles.push(new Particle(
                                        supernovaX + (Math.random() - 0.5) * 400,
                                        supernovaY + (Math.random() - 0.5) * 400,
                                        ['#ff8800', '#ff4400', '#8b0000'][Math.floor(Math.random() * 3)],
                                        (Math.random() - 0.5) * 15,
                                        (Math.random() - 0.5) * 15,
                                        40
                                    ));
                                }, i * 20);
                            }
                        }, 1200);
                        break;
                        
                    case 'timeLord':
                        // ⏰ TIME LORD - MASTER OF TIME ITSELF ⏰
                        // Phase 1: Time freeze wave
                        for (let wave = 0; wave < 10; wave++) {
                            setTimeout(() => {
                                const waveRadius = wave * 80;
                                // Expanding time freeze ring
                                for (let i = 0; i < 36; i++) {
                                    const angle = (Math.PI * 2 / 36) * i;
                                    particles.push(new Particle(
                                        this.x + Math.cos(angle) * waveRadius,
                                        this.y + Math.sin(angle) * waveRadius,
                                        ['#00ffff', '#0088ff', '#ffffff'][wave % 3],
                                        0, 0, 25
                                    ));
                                }
                            }, wave * 60);
                        }
                        
                        // Freeze all enemies
                        for (const enemy of currentRoom.enemies) {
                            enemy.frozen = true;
                            // Frozen in time effect
                            for (let i = 0; i < 30; i++) {
                                particles.push(new Particle(
                                    enemy.x + (Math.random() - 0.5) * 50,
                                    enemy.y + (Math.random() - 0.5) * 50,
                                    '#00ffff',
                                    0, 0, 40
                                ));
                            }
                        }
                        if (currentRoom.boss) {
                            currentRoom.boss.frozen = true;
                            for (let i = 0; i < 60; i++) {
                                particles.push(new Particle(
                                    currentRoom.boss.x + (Math.random() - 0.5) * 80,
                                    currentRoom.boss.y + (Math.random() - 0.5) * 80,
                                    '#00ffff',
                                    0, 0, 50
                                ));
                            }
                        }
                        
                        // Phase 2: Time acceleration for player
                        this.speed *= 3;
                        this.damageMultiplier = 5;
                        
                        // Clock/time particles around player
                        const timeLordInterval = setInterval(() => {
                            // Clock hands rotating
                            for (let i = 0; i < 12; i++) {
                                const angle = (Math.PI * 2 / 12) * i + Date.now() / 100;
                                particles.push(new Particle(
                                    this.x + Math.cos(angle) * 70,
                                    this.y + Math.sin(angle) * 70,
                                    '#00ffff',
                                    0, 0, 20
                                ));
                            }
                            // Time distortion waves
                            for (let i = 0; i < 8; i++) {
                                particles.push(new Particle(
                                    this.x + (Math.random() - 0.5) * 120,
                                    this.y + (Math.random() - 0.5) * 120,
                                    ['#00ffff', '#0088ff', '#ffffff'][Math.floor(Math.random() * 3)],
                                    (Math.random() - 0.5) * 8,
                                    (Math.random() - 0.5) * 8,
                                    25
                                ));
                            }
                            // Afterimages
                            for (let i = 0; i < 3; i++) {
                                particles.push(new Particle(
                                    this.x - this.vx * i * 5,
                                    this.y - this.vy * i * 5,
                                    'rgba(0, 255, 255, 0.5)',
                                    0, 0, 15
                                ));
                            }
                        }, 50);
                        
                        // Phase 3: Time rewind effect (enemies move backwards)
                        setTimeout(() => {
                            const rewindInterval = setInterval(() => {
                                for (const enemy of currentRoom.enemies) {
                                    // Move enemies backwards slightly
                                    enemy.x += (Math.random() - 0.5) * 10;
                                    // Rewind particles
                                    particles.push(new Particle(
                                        enemy.x,
                                        enemy.y,
                                        '#00ffff',
                                        (Math.random() - 0.5) * 5,
                                        -5,
                                        20
                                    ));
                                }
                            }, 100);
                            setTimeout(() => clearInterval(rewindInterval), 2000);
                        }, 2000);
                        
                        // Phase 4: Time resume
                        setTimeout(() => {
                            for (const enemy of currentRoom.enemies) {
                                enemy.frozen = false;
                                // Time shattering effect
                                for (let i = 0; i < 20; i++) {
                                    particles.push(new Particle(
                                        enemy.x + (Math.random() - 0.5) * 60,
                                        enemy.y + (Math.random() - 0.5) * 60,
                                        '#ffffff',
                                        (Math.random() - 0.5) * 15,
                                        (Math.random() - 0.5) * 15,
                                        30
                                    ));
                                }
                            }
                            if (currentRoom.boss) {
                                currentRoom.boss.frozen = false;
                                for (let i = 0; i < 40; i++) {
                                    particles.push(new Particle(
                                        currentRoom.boss.x + (Math.random() - 0.5) * 100,
                                        currentRoom.boss.y + (Math.random() - 0.5) * 100,
                                        '#ffffff',
                                        (Math.random() - 0.5) * 20,
                                        (Math.random() - 0.5) * 20,
                                        40
                                    ));
                                }
                            }
                            this.speed /= 3;
                            this.damageMultiplier = 1;
                            clearInterval(timeLordInterval);
                        }, 6000);
                        break;
                        
                    case 'godSlayer':
                        // ⚔️ GOD SLAYER - ULTIMATE BOSS ANNIHILATION ⚔️
                        if (currentRoom.boss) {
                            const bossX = currentRoom.boss.x;
                            const bossY = currentRoom.boss.y;
                            
                            // Phase 1: Gathering divine power
                            for (let i = 0; i < 60; i++) {
                                setTimeout(() => {
                                    // Power converging from all corners
                                    const corners = [
                                        {x: 0, y: 0},
                                        {x: canvas.width, y: 0},
                                        {x: 0, y: canvas.height},
                                        {x: canvas.width, y: canvas.height}
                                    ];
                                    for (const corner of corners) {
                                        particles.push(new Particle(
                                            corner.x + (bossX - corner.x) * (i / 60),
                                            corner.y + (bossY - corner.y) * (i / 60),
                                            ['#ffd700', '#ff8800', '#ff0000'][i % 3],
                                            (bossX - corner.x) * 0.02,
                                            (bossY - corner.y) * 0.02,
                                            30
                                        ));
                                    }
                                    // Charging aura around player
                                    for (let j = 0; j < 12; j++) {
                                        const angle = (Math.PI * 2 / 12) * j + (i * 0.1);
                                        particles.push(new Particle(
                                            this.x + Math.cos(angle) * (60 - i),
                                            this.y + Math.sin(angle) * (60 - i),
                                            '#ffd700',
                                            0, 0, 25
                                        ));
                                    }
                                }, i * 20);
                            }
                            
                            // Phase 2: THE STRIKE
                            setTimeout(() => {
                                // Divine sword slash from sky
                                for (let slash = 0; slash < 5; slash++) {
                                    setTimeout(() => {
                                        const slashAngle = (Math.PI / 4) * slash;
                                        // Massive energy blade
                                        for (let i = 0; i < 100; i++) {
                                            const dist = i * 8;
                                            particles.push(new Particle(
                                                bossX + Math.cos(slashAngle) * dist,
                                                bossY + Math.sin(slashAngle) * dist,
                                                ['#ffffff', '#ffd700', '#ffff00'][i % 3],
                                                Math.cos(slashAngle) * 20,
                                                Math.sin(slashAngle) * 20,
                                                40
                                            ));
                                        }
                                    }, slash * 100);
                                }
                                
                                // Cross-shaped divine strike
                                for (let i = 0; i < 4; i++) {
                                    const crossAngle = (Math.PI / 2) * i;
                                    for (let j = 0; j < 50; j++) {
                                        setTimeout(() => {
                                            particles.push(new Particle(
                                                bossX + Math.cos(crossAngle) * j * 15,
                                                bossY + Math.sin(crossAngle) * j * 15,
                                                '#ffffff',
                                                0, 0, 30
                                            ));
                                        }, j * 10);
                                    }
                                }
                                
                                // Explosion at boss location
                                for (let i = 0; i < 300; i++) {
                                    particles.push(new Particle(
                                        bossX + (Math.random() - 0.5) * 150,
                                        bossY + (Math.random() - 0.5) * 150,
                                        ['#ffffff', '#ffd700', '#ff8800', '#ff0000'][Math.floor(Math.random() * 4)],
                                        (Math.random() - 0.5) * 35,
                                        (Math.random() - 0.5) * 35,
                                        80
                                    ));
                                }
                                
                                // Screen shake effect with particles
                                for (let shake = 0; shake < 20; shake++) {
                                    setTimeout(() => {
                                        for (let s = 0; s < 50; s++) {
                                            particles.push(new Particle(
                                                Math.random() * canvas.width,
                                                Math.random() * canvas.height,
                                                '#ffffff',
                                                (Math.random() - 0.5) * 30,
                                                (Math.random() - 0.5) * 30,
                                                20
                                            ));
                                        }
                                    }, shake * 50);
                                }
                            }, 1200);
                            
                            // Phase 3: Damage application
                            setTimeout(() => {
                                currentRoom.boss.takeDamage(9999);
                                
                                // Victory particles
                                for (let i = 0; i < 200; i++) {
                                    setTimeout(() => {
                                        particles.push(new Particle(
                                            bossX + (Math.random() - 0.5) * 200,
                                            bossY + (Math.random() - 0.5) * 200,
                                            ['#ffd700', '#ffff00'][Math.floor(Math.random() * 2)],
                                            (Math.random() - 0.5) * 20,
                                            (Math.random() - 0.5) * 20,
                                            60
                                        ));
                                    }, i * 20);
                                }
                            }, 1700);
                        } else {
                            // No boss - show missed effect
                            for (let i = 0; i < 100; i++) {
                                particles.push(new Particle(
                                    this.x + (Math.random() - 0.5) * 100,
                                    this.y + (Math.random() - 0.5) * 100,
                                    '#888888',
                                    (Math.random() - 0.5) * 15,
                                    (Math.random() - 0.5) * 15,
                                    40
                                ));
                            }
                        }
                        break;
                        
                    // NEW LEGENDARY ABILITIES
                    case 'blackHole':
                        // Pull all enemies then crush
                        const bhX = this.x;
                        const bhY = this.y;
                        for (let i = 0; i < 120; i++) {
                            setTimeout(() => {
                                for (const enemy of currentRoom.enemies) {
                                    const dx = bhX - enemy.x;
                                    const dy = bhY - enemy.y;
                                    enemy.x += dx * 0.08;
                                    enemy.y += dy * 0.08;
                                    const dist = Math.sqrt(dx*dx + dy*dy);
                                    if (dist < 50) enemy.takeDamage(10);
                                }
                                if (currentRoom.boss) {
                                    const dx = bhX - currentRoom.boss.x;
                                    const dy = bhY - currentRoom.boss.y;
                                    currentRoom.boss.x += dx * 0.04;
                                    currentRoom.boss.y += dy * 0.04;
                                }
                                // Black hole particles
                                const angle = (i / 120) * Math.PI * 12;
                                particles.push(new Particle(
                                    bhX + Math.cos(angle) * (120 - i),
                                    bhY + Math.sin(angle) * (120 - i),
                                    '#000000',
                                    0, 0, 15
                                ));
                            }, i * 25);
                        }
                        break;
                        
                    case 'dragonBreath':
                        // Massive fire cone
                        for (let i = 0; i < 30; i++) {
                            const spreadAngle = (this.facing > 0 ? 0 : Math.PI) + (Math.random() - 0.5) * 1;
                            projectiles.push(new Projectile(
                                this.x + this.facing * 30,
                                this.y,
                                spreadAngle,
                                8 + Math.random() * 6,
                                'player'
                            ));
                        }
                        // Fire particles
                        for (let i = 0; i < 100; i++) {
                            particles.push(new Particle(
                                this.x + this.facing * (30 + Math.random() * 200),
                                this.y + (Math.random() - 0.5) * 100,
                                ['#ff0000', '#ff8800', '#ffff00'][Math.floor(Math.random() * 3)],
                                this.facing * (5 + Math.random() * 10),
                                (Math.random() - 0.5) * 8,
                                50
                            ));
                        }
                        break;
                        
                    case 'voidShift':
                        // Become invincible shadow
                        this.invincible = true;
                        this.speed *= 2.5;
                        const voidInterval = setInterval(() => {
                            // Shadow trail
                            for (let i = 0; i < 8; i++) {
                                particles.push(new Particle(
                                    this.x + (Math.random() - 0.5) * 40,
                                    this.y + (Math.random() - 0.5) * 40,
                                    '#000000',
                                    (Math.random() - 0.5) * 10,
                                    (Math.random() - 0.5) * 10,
                                    40
                                ));
                            }
                        }, 50);
                        setTimeout(() => {
                            this.invincible = false;
                            this.speed /= 2.5;
                            clearInterval(voidInterval);
                        }, 5000);
                        break;
                        
                    case 'obliterate':
                        // Delete nearest enemy
                        let nearestOb = null;
                        let nearestObDist = Infinity;
                        for (const enemy of currentRoom.enemies) {
                            const dist = Math.sqrt((enemy.x - this.x)**2 + (enemy.y - this.y)**2);
                            if (dist < nearestObDist) {
                                nearestObDist = dist;
                                nearestOb = enemy;
                            }
                        }
                        if (nearestOb) {
                            // Deletion particles
                            for (let i = 0; i < 100; i++) {
                                particles.push(new Particle(
                                    nearestOb.x,
                                    nearestOb.y,
                                    '#ffffff',
                                    (Math.random() - 0.5) * 20,
                                    (Math.random() - 0.5) * 20,
                                    50
                                ));
                            }
                            nearestOb.health = 0;
                        }
                        break;
                        
                    case 'chainReaction':
                        // Kill one enemy, ALL explode
                        if (currentRoom.enemies.length > 0) {
                            const firstEnemy = currentRoom.enemies[0];
                            firstEnemy.health = 0;
                            setTimeout(() => {
                                for (const enemy of currentRoom.enemies) {
                                    // Chain explosion
                                    for (let i = 0; i < 40; i++) {
                                        particles.push(new Particle(
                                            enemy.x, enemy.y,
                                            ['#ff0000', '#ff8800'][Math.floor(Math.random() * 2)],
                                            (Math.random() - 0.5) * 15,
                                            (Math.random() - 0.5) * 15,
                                            45
                                        ));
                                    }
                                    enemy.health = 0;
                                }
                            }, 500);
                        }
                        break;
                        
                    case 'soulCollector':
                        // Drain all enemy life
                        let totalDrained = 0;
                        for (const enemy of currentRoom.enemies) {
                            totalDrained += enemy.health;
                            // Soul drain particles
                            for (let i = 0; i < 20; i++) {
                                setTimeout(() => {
                                    particles.push(new Particle(
                                        enemy.x + (Math.random() - 0.5) * 30,
                                        enemy.y + (Math.random() - 0.5) * 30,
                                        '#8b008b',
                                        (this.x - enemy.x) * 0.05,
                                        (this.y - enemy.y) * 0.05,
                                        40
                                    ));
                                }, i * 30);
                            }
                            enemy.health = 0;
                        }
                        this.health = Math.min(this.maxHealth, this.health + totalDrained * 0.1);
                        break;
                }
                
                // CRITICAL FIX: Remove dead enemies after abilities execute
                setTimeout(() => {
                    for (let i = currentRoom.enemies.length - 1; i >= 0; i--) {
                        if (currentRoom.enemies[i].health <= 0) {
                            currentRoom.enemies.splice(i, 1);
                        }
                    }
                }, 100);
            }

            update() {
                // Cooldowns
                if (this.attackCooldown > 0) this.attackCooldown--;
                if (this.dashCooldown > 0) this.dashCooldown--;
                if (this.rangedCooldown > 0) this.rangedCooldown--;
                if (this.special1Cooldown > 0) this.special1Cooldown--;
                if (this.special2Cooldown > 0) this.special2Cooldown--;
                if (this.special3Cooldown > 0) this.special3Cooldown--;
                if (this.special4Cooldown > 0) this.special4Cooldown--;
                if (this.special5Cooldown > 0) this.special5Cooldown--;
                if (this.special6Cooldown > 0) this.special6Cooldown--;
                
                // Regeneration
                if (this.upgrades.regeneration > 0) {
                    this.regenTimer++;
                    if (this.regenTimer >= 60) {
                        this.health = Math.min(this.maxHealth, this.health + this.upgrades.regeneration * 0.5);
                        this.regenTimer = 0;
                    }
                }
                
                // Vampiric Aura
                if (this.upgrades.vampiricAura > 0) {
                    for (const enemy of currentRoom.enemies) {
                        const dist = Math.sqrt((enemy.x - this.x)**2 + (enemy.y - this.y)**2);
                        if (dist < 150) {
                            if (Math.random() < 0.02) {
                                this.health = Math.min(this.maxHealth, this.health + 1);
                            }
                        }
                    }
                }
                
                // Dash movement
                if (this.dashing) {
                    this.dashFrame++;
                    this.vx = this.facing * this.dashSpeed;
                    
                    // Dash trail
                    for (let i = 0; i < 3; i++) {
                        particles.push(new Particle(
                            this.x, this.y,
                            '#1a1a1a',
                            (Math.random() - 0.5) * 2,
                            (Math.random() - 0.5) * 2,
                            20
                        ));
                    }
                    
                    if (this.dashFrame > 10) {
                        this.dashing = false;
                        this.dashFrame = 0;
                    }
                }
                
                // Physics
                this.vy += this.gravity;
                this.x += this.vx;
                this.y += this.vy;
                
                // Platform collision
                this.onGround = false;
                for (const platform of currentRoom.platforms) {
                    if (this.x + this.width / 2 > platform.x &&
                        this.x - this.width / 2 < platform.x + platform.width &&
                        this.y + this.height / 2 > platform.y &&
                        this.y + this.height / 2 < platform.y + 20 &&
                        this.vy >= 0) {
                        this.y = platform.y - this.height / 2;
                        this.vy = 0;
                        this.onGround = true;
                        this.hasDoubleJumped = false;
                    }
                }
                
                // Ground collision
                if (this.y > canvas.height - 50 - this.height / 2) {
                    this.y = canvas.height - 50 - this.height / 2;
                    this.vy = 0;
                    this.onGround = true;
                    this.hasDoubleJumped = false;
                }
                
                // Bounds
                if (this.x < this.width / 2) this.x = this.width / 2;
                if (this.x > canvas.width - this.width / 2) this.x = canvas.width - this.width / 2;
                
                // Animation
                this.animCounter++;
                if (this.animCounter > 8) {
                    this.animFrame = (this.animFrame + 1) % 4;
                    this.animCounter = 0;
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.facing, 1);
                
                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.ellipse(0, this.height / 2 + 5, this.width / 2, 5, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Dash effect
                if (this.dashing) {
                    ctx.globalAlpha = 0.5;
                    for (let i = 0; i < 3; i++) {
                        ctx.fillStyle = '#1a1a1a';
                        ctx.fillRect(-this.width / 2 - i * 10, -this.height / 2, this.width, this.height);
                    }
                    ctx.globalAlpha = 1;
                }
                
                // Mythic mode aura
                if (mythicMode) {
                    const mythicGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.width * 2);
                    mythicGradient.addColorStop(0, 'rgba(255, 0, 255, 0.3)');
                    mythicGradient.addColorStop(1, 'rgba(255, 0, 255, 0)');
                    ctx.fillStyle = mythicGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width * 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Body (assassin in dark cloak)
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                
                // Hood
                ctx.fillStyle = '#0a0a0a';
                ctx.beginPath();
                ctx.arc(0, -this.height / 2 + 6, 10, 0, Math.PI * 2);
                ctx.fill();
                
                // Face shadow
                ctx.fillStyle = '#2a2a2a';
                ctx.fillRect(-this.width / 2 + 6, -this.height / 2 + 8, this.width - 12, 8);
                
                // Eyes (glowing)
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(2, -8, 3, 2);
                
                // Cloak
                ctx.fillStyle = '#0a0a0a';
                ctx.beginPath();
                ctx.moveTo(-this.width / 2, -this.height / 2 + 12);
                ctx.lineTo(-this.width / 2 - 6, -this.height / 2 + 20 + Math.sin(Date.now() / 100) * 3);
                ctx.lineTo(-this.width / 2 - 4, this.height / 2);
                ctx.lineTo(-this.width / 2, this.height / 2);
                ctx.fill();
                
                // Belt
                ctx.fillStyle = '#4a2511';
                ctx.fillRect(-this.width / 2, 0, this.width, 4);
                
                // Weapon (dagger)
                if (this.attacking && this.attackDirection !== null) {
                    ctx.save();
                    ctx.rotate(this.attackDirection);
                    
                    // Dagger blade
                    ctx.fillStyle = '#c0c0c0';
                    ctx.beginPath();
                    ctx.moveTo(40, 0);
                    ctx.lineTo(10, -3);
                    ctx.lineTo(10, 3);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Blade shine
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.moveTo(35, 0);
                    ctx.lineTo(20, -1);
                    ctx.lineTo(20, 1);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Handle
                    ctx.fillStyle = '#8b4513';
                    ctx.fillRect(8, -2, 8, 4);
                    
                    // Pommel
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.arc(8, 0, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                }
                
                ctx.restore();
            }

            takeDamage(amount) {
                if (this.invincible) return;
                
                // Evasion
                if (this.upgrades.evasion > 0 && Math.random() < this.upgrades.evasion * 0.1) {
                    return;
                }
                
                // Blood Shield
                if (this.upgrades.bloodShield > 0 && Math.random() < 0.15 * this.upgrades.bloodShield) {
                    amount *= 0.5;
                }
                
                // Iron Skin
                if (this.upgrades.ironSkin > 0) {
                    amount *= (1 - this.upgrades.ironSkin * 0.1);
                }
                
                // Thorns
                if (this.upgrades.thorns > 0) {
                    for (const enemy of currentRoom.enemies) {
                        const dx = enemy.x - this.x;
                        const dy = enemy.y - this.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 100) {
                            enemy.takeDamage(amount * 0.3 * this.upgrades.thorns);
                        }
                    }
                }
                
                // Reflection
                if (this.upgrades.reflection > 0) {
                    for (const enemy of currentRoom.enemies) {
                        const dist = Math.sqrt((enemy.x - this.x)**2 + (enemy.y - this.y)**2);
                        if (dist < 200) {
                            enemy.health -= amount * this.upgrades.reflection * 0.3;
                        }
                    }
                }
                
                this.health -= amount;
                this.health = Math.max(0, Math.min(this.health, this.maxHealth));
                
                // Damage particles
                for (let i = 0; i < 20; i++) {
                    particles.push(new Particle(
                        this.x,
                        this.y,
                        '#ff0066',
                        (Math.random() - 0.5) * 8,
                        (Math.random() - 0.5) * 8,
                        30
                    ));
                }
            }
        }

        // Enemy class (keeping original visuals)
        class Enemy {
            constructor(x, y, type = 'basic') {
                this.x = x;
                this.y = y;
                this.width = 28;
                this.height = 32;
                this.vx = 0;
                this.vy = 0;
                this.gravity = 0.6;
                
                const enemyStats = {
                    'basic': { health: 35, speed: 2, color: '#808080', damage: 8 },
                    'advanced': { health: 40, speed: 2.5, color: '#8b4513', damage: 10 },
                    'heavy': { health: 70, speed: 1, color: '#4a4a4a', damage: 12 },
                    'assassin': { health: 25, speed: 4, color: '#1a1a1a', damage: 6 },
                    'mage': { health: 25, speed: 1.5, color: '#4b0082', damage: 6 }
                };
                
                const stats = enemyStats[type] || enemyStats['basic'];
                this.health = stats.health;
                this.maxHealth = stats.health;
                this.speed = stats.speed;
                this.color = stats.color;
                this.baseDamage = stats.damage;
                this.type = type;
                this.facing = -1;
                this.onGround = false;
                
                this.attackCooldown = 0;
                this.shootCooldown = 0;
                this.teleportCooldown = 0;
                this.state = 'idle';
                this.stateTimer = 0;
                this.frozen = false;
                
                this.animFrame = 0;
                this.animCounter = 0;
            }

            update() {
                // Pause during upgrade selection
                if (showingUpgrade) return;
                
                if (this.frozen) {
                    this.vy += this.gravity;
                    this.y += this.vy;
                    if (this.y > canvas.height - 50 - this.height / 2) {
                        this.y = canvas.height - 50 - this.height / 2;
                        this.vy = 0;
                    }
                    return;
                }
                
                this.vy += this.gravity;
                this.x += this.vx;
                this.y += this.vy;
                
                // Platform collision
                this.onGround = false;
                for (const platform of currentRoom.platforms) {
                    if (this.x + this.width / 2 > platform.x &&
                        this.x - this.width / 2 < platform.x + platform.width &&
                        this.y + this.height / 2 > platform.y &&
                        this.y + this.height / 2 < platform.y + 20 &&
                        this.vy >= 0) {
                        this.y = platform.y - this.height / 2;
                        this.vy = 0;
                        this.onGround = true;
                    }
                }
                
                if (this.y > canvas.height - 50 - this.height / 2) {
                    this.y = canvas.height - 50 - this.height / 2;
                    this.vy = 0;
                    this.onGround = true;
                }
                
                // AI
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                this.facing = dx > 0 ? 1 : -1;
                
                if (this.attackCooldown > 0) this.attackCooldown--;
                if (this.shootCooldown > 0) this.shootCooldown--;
                if (this.teleportCooldown > 0) this.teleportCooldown--;
                
                switch(this.type) {
                    case 'basic':
                    case 'heavy':
                        // Melee enemies
                        if (dist > 50) {
                            this.vx = this.facing * this.speed;
                        } else {
                            this.vx = 0;
                            if (this.attackCooldown <= 0) {
                                this.attackCooldown = 60;
                                player.takeDamage(this.baseDamage);
                            }
                        }
                        break;
                        
                    case 'advanced':
                        // Archer - keep distance and shoot
                        if (dist < 100) {
                            this.vx = -this.facing * this.speed;
                        } else if (dist > 300) {
                            this.vx = this.facing * this.speed;
                        } else {
                            this.vx *= 0.9;
                        }
                        
                        if (this.shootCooldown <= 0 && dist < 400) {
                            this.shootCooldown = 90;
                            const angle = Math.atan2(dy, dx);
                            projectiles.push(new Projectile(this.x, this.y, angle, 8, 'enemy'));
                        }
                        break;
                        
                    case 'assassin':
                        // Fast melee
                        if (dist > 40) {
                            this.vx = this.facing * this.speed;
                        } else {
                            this.vx = 0;
                            if (this.attackCooldown <= 0) {
                                this.attackCooldown = 45;
                                player.takeDamage(this.baseDamage);
                            }
                        }
                        break;
                        
                    case 'mage':
                        // Teleporting ranged
                        if (dist > 150 && dist < 350) {
                            this.vx *= 0.95;
                            
                            if (this.shootCooldown <= 0) {
                                this.shootCooldown = 100;
                                const angle = Math.atan2(dy, dx);
                                for (let i = -1; i <= 1; i++) {
                                    projectiles.push(new Projectile(
                                        this.x,
                                        this.y,
                                        angle + i * 0.2,
                                        8,
                                        'enemy'
                                    ));
                                }
                            }
                        } else if (dist < 150 && this.teleportCooldown <= 0) {
                            this.teleportCooldown = 200;
                            const teleAngle = Math.random() * Math.PI * 2;
                            let newX = this.x + Math.cos(teleAngle) * 150;
                            let newY = this.y + Math.sin(teleAngle) * 100;
                            
                            newX = Math.max(50, Math.min(canvas.width - 50, newX));
                            newY = Math.max(100, Math.min(canvas.height - 100, newY));
                            
                            this.x = newX;
                            this.y = newY;
                            
                            for (let i = 0; i < 20; i++) {
                                particles.push(new Particle(
                                    this.x, this.y, '#4b0082',
                                    (Math.random() - 0.5) * 10,
                                    (Math.random() - 0.5) * 10,
                                    30
                                ));
                            }
                        } else if (dist > 400) {
                            this.vx = this.facing * this.speed * 0.7;
                        } else {
                            this.vx *= 0.9;
                        }
                        break;
                }
                
                // Animation
                this.animCounter++;
                if (this.animCounter > 10) {
                    this.animFrame = (this.animFrame + 1) % 3;
                    this.animCounter = 0;
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.facing, 1);
                
                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.ellipse(0, this.height / 2 + 5, this.width / 2, 5, 0, 0, Math.PI * 2);
                ctx.fill();
                
                switch(this.type) {
                    case 'basic':
                        // Sword Knight
                        ctx.fillStyle = '#808080';
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        ctx.fillStyle = '#a0a0a0';
                        ctx.fillRect(-this.width / 2 + 4, -this.height / 2 + 4, this.width - 8, this.height / 2);
                        
                        ctx.fillStyle = '#696969';
                        ctx.beginPath();
                        ctx.arc(0, -this.height / 2 + 6, 10, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = '#000000';
                        ctx.fillRect(-6, -this.height / 2 + 4, 12, 3);
                        
                        // Shield
                        ctx.fillStyle = '#8b0000';
                        ctx.beginPath();
                        ctx.arc(-8, 0, 8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#ffd700';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        // Sword
                        ctx.strokeStyle = '#c0c0c0';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(8, -4);
                        ctx.lineTo(8, -16);
                        ctx.stroke();
                        
                        ctx.fillStyle = '#8b4513';
                        ctx.fillRect(6, -6, 4, 6);
                        break;
                        
                    case 'advanced':
                        // Archer Knight
                        ctx.fillStyle = '#8b4513';
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        ctx.fillStyle = '#654321';
                        ctx.fillRect(-this.width / 2 + 4, -this.height / 2 + 8, this.width - 8, this.height - 12);
                        
                        ctx.fillStyle = '#a0a0a0';
                        ctx.beginPath();
                        ctx.arc(0, -this.height / 2 + 6, 9, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = '#ffe0bd';
                        ctx.fillRect(-4, -this.height / 2 + 4, 8, 6);
                        
                        ctx.fillStyle = '#000000';
                        ctx.fillRect(-3, -this.height / 2 + 5, 2, 2);
                        ctx.fillRect(1, -this.height / 2 + 5, 2, 2);
                        
                        // Bow
                        ctx.strokeStyle = '#8b4513';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(10, 0, 12, -Math.PI/3, Math.PI/3);
                        ctx.stroke();
                        
                        ctx.strokeStyle = '#d3d3d3';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(10 + Math.cos(-Math.PI/3) * 12, Math.sin(-Math.PI/3) * 12);
                        ctx.lineTo(10 + Math.cos(Math.PI/3) * 12, Math.sin(Math.PI/3) * 12);
                        ctx.stroke();
                        
                        ctx.fillStyle = '#654321';
                        ctx.fillRect(-10, this.height / 4, 4, 8);
                        break;
                        
                    case 'heavy':
                        // Tank
                        ctx.fillStyle = '#4a4a4a';
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        ctx.fillStyle = '#5a5a5a';
                        ctx.fillRect(-this.width / 2 + 2, -this.height / 2 + 2, this.width - 4, 8);
                        ctx.fillRect(-this.width / 2 + 2, 0, this.width - 4, 6);
                        
                        ctx.fillStyle = '#3a3a3a';
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, 10);
                        
                        // Spikes
                        ctx.fillStyle = '#8b4513';
                        for (let i = -1; i <= 1; i++) {
                            ctx.beginPath();
                            ctx.moveTo(i * 8, -this.height / 2);
                            ctx.lineTo(i * 8 - 3, -this.height / 2 - 6);
                            ctx.lineTo(i * 8 + 3, -this.height / 2 - 6);
                            ctx.fill();
                        }
                        
                        ctx.fillStyle = '#ff0000';
                        ctx.fillRect(-8, -this.height / 2 + 12, 16, 3);
                        
                        // Hammer
                        ctx.fillStyle = '#696969';
                        ctx.fillRect(8, -8, 4, 16);
                        ctx.fillRect(6, -12, 8, 8);
                        break;
                        
                    case 'assassin':
                        // Fast assassin
                        ctx.fillStyle = '#1a1a1a';
                        ctx.fillRect(-this.width / 2 + 4, -this.height / 2, this.width - 8, this.height);
                        
                        ctx.fillStyle = '#0a0a0a';
                        ctx.beginPath();
                        ctx.arc(0, -this.height / 2 + 4, 8, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = '#ff0000';
                        ctx.fillRect(-3, -this.height / 2 + 6, 2, 2);
                        ctx.fillRect(1, -this.height / 2 + 6, 2, 2);
                        
                        // Daggers
                        ctx.fillStyle = '#c0c0c0';
                        ctx.fillRect(8, -2, 8, 2);
                        ctx.fillRect(8, 2, 8, 2);
                        break;
                        
                    case 'mage':
                        // Mage
                        ctx.fillStyle = '#4b0082';
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        ctx.fillStyle = '#6a0dad';
                        ctx.fillRect(-this.width / 2 + 4, -this.height / 2 + 8, this.width - 8, this.height - 12);
                        
                        ctx.fillStyle = '#3a2a5a';
                        ctx.beginPath();
                        ctx.arc(0, -this.height / 2 + 4, 10, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Hat
                        ctx.fillStyle = '#2a1a4a';
                        ctx.beginPath();
                        ctx.moveTo(0, -this.height / 2 - 8);
                        ctx.lineTo(-8, -this.height / 2 + 4);
                        ctx.lineTo(8, -this.height / 2 + 4);
                        ctx.fill();
                        
                        // Staff
                        ctx.strokeStyle = '#8b4513';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(10, 0);
                        ctx.lineTo(10, -18);
                        ctx.stroke();
                        
                        ctx.fillStyle = '#9400d3';
                        ctx.beginPath();
                        ctx.arc(10, -20, 4, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                }
                
                ctx.restore();
                
                // Health bar
                const barWidth = this.width + 10;
                const barHeight = 4;
                const barY = this.y - this.height / 2 - 10;
                
                ctx.fillStyle = '#222';
                ctx.fillRect(this.x - barWidth / 2, barY, barWidth, barHeight);
                
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(this.x - barWidth / 2, barY, barWidth * (this.health / this.maxHealth), barHeight);
            }

            takeDamage(amount) {
                const baseDamage = player.attackDamage * (1 + player.upgrades.damage * 0.15);
                const damageMultiplier = player.damageMultiplier * (mythicMode ? 5 : 1);
                let finalDamage = amount * damageMultiplier;
                
                // Critical hit
                const critChance = 0.1 + (player.upgrades.critChance * 0.05);
                if (Math.random() < critChance) {
                    const critDamage = 2 + (player.upgrades.critDamage * 0.3);
                    finalDamage *= critDamage;
                    
                    // Critical Mass
                    if (player.upgrades.criticalMass > 0) {
                        for (let i = 0; i < 8; i++) {
                            const angle = (Math.PI * 2 / 8) * i;
                            projectiles.push(new Projectile(
                                this.x,
                                this.y,
                                angle,
                                6,
                                'player'
                            ));
                        }
                    }
                }
                
                // Death Mark bonus
                if (player.markedEnemies.has(this)) {
                    finalDamage *= 1.5;
                }
                
                // Berserker Rage bonus
                if (player.upgrades.berserkerRage > 0 && player.health < player.maxHealth * 0.3) {
                    finalDamage *= (1 + player.upgrades.berserkerRage * 0.15);
                }
                
                this.health -= finalDamage;
                this.health = Math.max(0, this.health);
                
                // Lifesteal
                if (player.upgrades.lifesteal > 0) {
                    player.health = Math.min(player.maxHealth, player.health + player.upgrades.lifesteal);
                }
                
                // Soul Harvest on kill
                if (this.health <= 0 && player.upgrades.soulHarvest > 0) {
                    player.health = Math.min(player.maxHealth, player.health + player.upgrades.soulHarvest * 3);
                }
                
                // Status effects
                if (player.upgrades.poisonDagger > 0) {
                    player.poisonedEnemies.add(this);
                }
                if (player.upgrades.frozenTouch > 0) {
                    player.frozenEnemies.add(this);
                    this.speed *= 0.5;
                }
                if (player.upgrades.deathMark > 0 && Math.random() < 0.3) {
                    player.markedEnemies.add(this);
                }
                
                // Damage particles
                for (let i = 0; i < 15; i++) {
                    particles.push(new Particle(
                        this.x,
                        this.y,
                        '#ff0000',
                        (Math.random() - 0.5) * 6,
                        (Math.random() - 0.5) * 6,
                        25
                    ));
                }
            }
        }

        // Boss class with UNIQUE ATTACK PATTERNS
        class Boss {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.width = 50;
                this.height = 60;
                this.vx = 0;
                this.vy = 0;
                this.gravity = 0.6;
                this.type = type;
                this.facing = -1;
                this.onGround = false;
                
                const bossStats = {
                    'Crimson Knight': { health: 600, speed: 1.8, color: '#8b0000', damage: 15 },
                    'Shadow Lord': { health: 550, speed: 2.3, color: '#2a2a2a', damage: 13 },
                    'Frost Warden': { health: 580, speed: 1.4, color: '#00bfff', damage: 14 },
                    'Flame Tyrant': { health: 570, speed: 2.0, color: '#ff4500', damage: 15 },
                    'Stone Golem': { health: 800, speed: 1.0, color: '#696969', damage: 18 },
                    'Toxic Assassin': { health: 520, speed: 2.8, color: '#228b22', damage: 13 },
                    'Thunder King': { health: 620, speed: 1.7, color: '#ffd700', damage: 15 },
                    'Necromancer': { health: 540, speed: 1.5, color: '#4b0082', damage: 14 },
                    'Blood Reaper': { health: 600, speed: 2.1, color: '#dc143c', damage: 15 },
                    'Void Walker': { health: 590, speed: 2.2, color: '#483d8b', damage: 14 },
                    'Crystal Sage': { health: 560, speed: 1.3, color: '#ff1493', damage: 13 },
                    'Iron Colossus': { health: 900, speed: 0.8, color: '#4a4a4a', damage: 20 },
                    'Phantom Assassin': { health: 500, speed: 3.2, color: '#8b008b', damage: 12 },
                    'Plague Doctor': { health: 580, speed: 1.6, color: '#006400', damage: 14 },
                    'Storm Herald': { health: 610, speed: 1.9, color: '#4169e1', damage: 15 }
                };
                
                const stats = bossStats[type];
                this.health = stats.health;
                this.maxHealth = stats.health;
                this.speed = stats.speed;
                this.color = stats.color;
                this.baseDamage = stats.damage;
                
                this.attackCooldown = 0;
                this.specialCooldown = 0;
                this.phase = 1;
                this.animFrame = 0;
                this.isBoss = true;
                this.frozen = false;
                
                // ADVANCED ATTACK PATTERN SYSTEM
                this.patternPhase = 0;
                this.patternTimer = 0;
                this.currentPattern = 0;
                this.attackState = 'idle'; // idle, telegraph, attacking, recovering
                this.stateTimer = 0;
                this.telegraphTimer = 0;
                this.isInvulnerable = false;
                this.dashTarget = { x: 0, y: 0 };
                this.summonedMinions = [];
            }

            update() {
                // Pause during upgrade selection
                if (showingUpgrade) return;
                
                if (this.frozen) {
                    this.vy += this.gravity;
                    this.y += this.vy;
                    if (this.y > canvas.height - 50 - this.height / 2) {
                        this.y = canvas.height - 50 - this.height / 2;
                        this.vy = 0;
                    }
                    return;
                }
                
                this.vy += this.gravity;
                this.x += this.vx;
                this.y += this.vy;
                
                // Platform collision
                this.onGround = false;
                for (const platform of currentRoom.platforms) {
                    if (this.x + this.width / 2 > platform.x &&
                        this.x - this.width / 2 < platform.x + platform.width &&
                        this.y + this.height / 2 > platform.y &&
                        this.y + this.height / 2 < platform.y + 20 &&
                        this.vy >= 0) {
                        this.y = platform.y - this.height / 2;
                        this.vy = 0;
                        this.onGround = true;
                    }
                }
                
                if (this.y > canvas.height - 50 - this.height / 2) {
                    this.y = canvas.height - 50 - this.height / 2;
                    this.vy = 0;
                    this.onGround = true;
                }
                
                // Phase transition at 50% HP
                if (this.health < this.maxHealth / 2 && this.phase === 1) {
                    this.phase = 2;
                    this.speed *= 1.15; // Reduced from 1.4
                    this.baseDamage *= 1.1; // Reduced from 1.2
                    
                    for (let i = 0; i < 80; i++) {
                        particles.push(new Particle(
                            this.x, this.y, this.color,
                            (Math.random() - 0.5) * 20,
                            (Math.random() - 0.5) * 20,
                            50
                        ));
                    }
                }
                
                // AI with UNIQUE ATTACK PATTERNS
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                this.facing = dx > 0 ? 1 : -1;
                
                if (this.attackCooldown > 0) this.attackCooldown--;
                if (this.specialCooldown > 0) this.specialCooldown--;
                
                this.patternTimer++;
                if (this.patternTimer > 250) {
                    this.patternTimer = 0;
                    this.currentPattern = (this.currentPattern + 1) % 5; // Now 5 patterns!
                }
                
                // In phase 2, patterns cycle faster and more aggressively
                if (this.phase === 2 && this.patternTimer > 150) {
                    this.patternTimer = 0;
                    this.currentPattern = (this.currentPattern + 1) % 5;
                }
                
                // Set attack pattern for executeAttackPattern method
                this.attackPattern = this.currentPattern;
                
                // Boss-specific attack patterns
                this.executeAttackPattern(dx, dy, dist);
                
                this.animFrame++;
            }
            
            executeAttackPattern(dx, dy, dist) {
                switch(this.type) {
                    case 'Crimson Knight':
                        // Keep distance, use sword attacks
                        if (dist > 120) {
                            this.vx = this.facing * this.speed * 0.6;
                        } else {
                            this.vx *= 0.8;
                        }
                        
                        if (this.attackPattern === 0) {
                            // Sword slash wave - telegraphed
                            if (this.patternTimer % 100 === 0) {
                                // Visual telegraph
                                for (let i = 0; i < 20; i++) {
                                    particles.push(new Particle(
                                        this.x + this.facing * 30, this.y,
                                        '#ffd700',
                                        this.facing * (Math.random() * 2 + 2),
                                        (Math.random() - 0.5) * 4,
                                        30
                                    ));
                                }
                                // Actual attack after delay
                                setTimeout(() => {
                                    for (let i = -1; i <= 1; i++) {
                                        const angle = (this.facing > 0 ? 0 : Math.PI) + i * 0.3;
                                        projectiles.push(new Projectile(this.x, this.y, angle, 7, 'enemy'));
                                    }
                                }, 400);
                            }
                        } else if (this.attackPattern === 1) {
                            // Shield spin - circular projectiles
                            if (this.patternTimer % 120 === 0) {
                                for (let i = 0; i < 8; i++) {
                                    setTimeout(() => {
                                        const angle = (Math.PI * 2 / 8) * i;
                                        projectiles.push(new Projectile(this.x, this.y, angle, 5, 'enemy'));
                                    }, i * 60);
                                }
                            }
                        } else if (this.attackPattern === 2) {
                            // Ground pound shockwave
                            if (this.onGround && this.patternTimer % 140 === 0) {
                                // Jump warning
                                this.vy = -8;
                                setTimeout(() => {
                                    if (this.onGround) {
                                        // Shockwave on landing
                                        for (let i = 0; i < 30; i++) {
                                            particles.push(new Particle(
                                                this.x, this.y + this.height/2,
                                                '#8b4513',
                                                (Math.random() - 0.5) * 10,
                                                -Math.random() * 5,
                                                40
                                            ));
                                        }
                                        projectiles.push(new Projectile(this.x, this.y, 0, 6, 'enemy'));
                                        projectiles.push(new Projectile(this.x, this.y, Math.PI, 6, 'enemy'));
                                    }
                                }, 800);
                            }
                        } else if (this.attackPattern === 3) {
                            // NEW: Crimson Blade Dance - rapid spinning slash combo
                            if (this.patternTimer % 110 === 0) {
                                for (let combo = 0; combo < 4; combo++) {
                                    setTimeout(() => {
                                        // Spinning slash particles
                                        for (let i = 0; i < 12; i++) {
                                            const angle = (Math.PI * 2 / 12) * i + (combo * 0.2);
                                            particles.push(new Particle(
                                                this.x + Math.cos(angle) * 40,
                                                this.y + Math.sin(angle) * 40,
                                                '#ff0000',
                                                Math.cos(angle) * 3,
                                                Math.sin(angle) * 3,
                                                25
                                            ));
                                        }
                                        // Projectiles in cross pattern
                                        for (let i = 0; i < 4; i++) {
                                            const angle = (Math.PI / 2) * i + (combo * 0.3);
                                            projectiles.push(new Projectile(this.x, this.y, angle, 8, 'enemy'));
                                        }
                                    }, combo * 250);
                                }
                            }
                        } else {
                            // NEW: Royal Charge - telegraphed dash attack with sword trail
                            if (this.patternTimer % 130 === 0) {
                                const angle = Math.atan2(dy, dx);
                                
                                // Charging particles
                                for (let i = 0; i < 40; i++) {
                                    particles.push(new Particle(
                                        this.x, this.y,
                                        '#8b0000',
                                        Math.cos(angle) * (i * 0.3),
                                        Math.sin(angle) * (i * 0.3),
                                        50
                                    ));
                                }
                                
                                // Execute charge
                                setTimeout(() => {
                                    this.vx = Math.cos(angle) * 15;
                                    this.vy = Math.sin(angle) * 15;
                                    
                                    // Leave projectiles in wake
                                    for (let i = 0; i < 6; i++) {
                                        setTimeout(() => {
                                            projectiles.push(new Projectile(this.x, this.y, angle + Math.PI, 4, 'enemy'));
                                        }, i * 50);
                                    }
                                    
                                    // Stop charge
                                    setTimeout(() => {
                                        this.vx *= 0.2;
                                        this.vy *= 0.2;
                                    }, 300);
                                }, 700);
                            }
                        }
                        break;
                        
                    case 'Shadow Lord':
                        // Stay at medium range, teleport around
                        if (dist < 150 || dist > 300) {
                            this.vx *= 0.9;
                        } else {
                            this.vx = this.facing * this.speed * 0.5;
                        }
                        
                        if (this.attackPattern === 0) {
                            // Shadow clone barrage
                            if (this.patternTimer % 150 === 0) {
                                // Create shadow clones that shoot
                                for (let i = 0; i < 3; i++) {
                                    setTimeout(() => {
                                        const cloneX = this.x + (Math.random() - 0.5) * 200;
                                        const cloneY = this.y - 100;
                                        
                                        // Clone particles
                                        for (let j = 0; j < 15; j++) {
                                            particles.push(new Particle(
                                                cloneX, cloneY, '#000000',
                                                (Math.random() - 0.5) * 6,
                                                (Math.random() - 0.5) * 6,
                                                40
                                            ));
                                        }
                                        
                                        // Clone shoots
                                        setTimeout(() => {
                                            const angle = Math.atan2(player.y - cloneY, player.x - cloneX);
                                            projectiles.push(new Projectile(cloneX, cloneY, angle, 7, 'enemy'));
                                        }, 500);
                                    }, i * 400);
                                }
                            }
                        } else if (this.attackPattern === 1) {
                            // Shadow dash (telegraphed)
                            if (this.patternTimer % 120 === 0) {
                                // Show dash direction
                                for (let i = 0; i < 20; i++) {
                                    particles.push(new Particle(
                                        this.x, this.y,
                                        '#ff0000',
                                        this.facing * i * 0.5,
                                        0,
                                        25
                                    ));
                                }
                                
                                // Dash after delay
                                setTimeout(() => {
                                    this.vx = this.facing * this.speed * 8;
                                    setTimeout(() => {
                                        this.vx *= 0.3;
                                    }, 200);
                                }, 600);
                            }
                        } else {
                            // Dark nova - expanding ring
                            if (this.patternTimer % 180 === 0) {
                                for (let wave = 1; wave <= 3; wave++) {
                                    setTimeout(() => {
                                        for (let i = 0; i < 12; i++) {
                                            const angle = (Math.PI * 2 / 12) * i;
                                            projectiles.push(new Projectile(this.x, this.y, angle, 4 + wave, 'enemy'));
                                        }
                                    }, wave * 400);
                                }
                            }
                        }
                        break;
                        
                    case 'Frost Warden':
                        // Slow and methodical, uses ice magic
                        this.vx *= 0.9; // Stay mostly still
                        
                        if (this.attackPattern === 0) {
                            // Ice spike line (telegraphed)
                            if (this.patternTimer % 110 === 0) {
                                const angle = Math.atan2(dy, dx);
                                
                                // Show ice forming
                                for (let i = 0; i < 10; i++) {
                                    setTimeout(() => {
                                        const distance = i * 40;
                                        particles.push(new Particle(
                                            this.x + Math.cos(angle) * distance,
                                            this.y + Math.sin(angle) * distance,
                                            '#00ffff',
                                            0, 0, 40
                                        ));
                                    }, i * 50);
                                }
                                
                                // Ice spike attack
                                setTimeout(() => {
                                    for (let i = 0; i < 5; i++) {
                                        projectiles.push(new Projectile(this.x, this.y, angle + (Math.random() - 0.5) * 0.2, 8, 'enemy'));
                                    }
                                }, 600);
                            }
                        } else if (this.attackPattern === 1) {
                            // Blizzard - random ice from above
                            if (this.patternTimer % 30 === 0 && this.patternTimer % 180 > 0) {
                                const x = Math.random() * canvas.width;
                                projectiles.push(new Projectile(x, 0, Math.PI / 2, 6, 'enemy'));
                            }
                        } else {
                            // Ice wall - horizontal wave
                            if (this.patternTimer % 140 === 0) {
                                setTimeout(() => {
                                    for (let i = -2; i <= 2; i++) {
                                        projectiles.push(new Projectile(
                                            this.x + i * 40,
                                            this.y - 50,
                                            Math.PI / 2,
                                            5,
                                            'enemy'
                                        ));
                                    }
                                }, 500);
                            }
                        }
                        break;
                        
                    case 'Flame Tyrant':
                        // Medium range, uses fire attacks
                        if (dist > 180) {
                            this.vx = this.facing * this.speed * 0.7;
                        } else {
                            this.vx *= 0.85;
                        }
                        
                        if (this.attackPattern === 0) {
                            // Fireball volley
                            if (this.patternTimer % 90 === 0) {
                                for (let i = 0; i < 3; i++) {
                                    setTimeout(() => {
                                        const angle = Math.atan2(dy, dx) + (Math.random() - 0.5) * 0.4;
                                        projectiles.push(new Projectile(this.x, this.y, angle, 7, 'enemy'));
                                    }, i * 200);
                                }
                            }
                        } else if (this.attackPattern === 1) {
                            // Flame pillar (telegraphed)
                            if (this.patternTimer % 120 === 0) {
                                const targetX = player.x;
                                
                                // Show target zone
                                for (let i = 0; i < 30; i++) {
                                    particles.push(new Particle(
                                        targetX + (Math.random() - 0.5) * 50,
                                        canvas.height - 50,
                                        '#ff8c00',
                                        0, -Math.random() * 3,
                                        50
                                    ));
                                }
                                
                                // Flame eruption
                                setTimeout(() => {
                                    for (let i = 0; i < 8; i++) {
                                        projectiles.push(new Projectile(
                                            targetX + (Math.random() - 0.5) * 60,
                                            canvas.height - 50,
                                            -Math.PI / 2 + (Math.random() - 0.5) * 0.5,
                                            8 + Math.random() * 3,
                                            'enemy'
                                        ));
                                    }
                                }, 800);
                            }
                        } else {
                            // Fire ring
                            if (this.patternTimer % 100 === 0) {
                                for (let i = 0; i < 10; i++) {
                                    const angle = (Math.PI * 2 / 10) * i;
                                    projectiles.push(new Projectile(this.x, this.y, angle, 5, 'enemy'));
                                }
                            }
                        }
                        break;
                        
                    case 'Stone Golem':
                        // Very slow, powerful but telegraphed attacks
                        if (dist > 100) {
                            this.vx = this.facing * this.speed * 0.8;
                        } else {
                            this.vx *= 0.7;
                        }
                        
                        if (this.attackPattern === 0) {
                            // Boulder toss (highly telegraphed)
                            if (this.patternTimer % 150 === 0) {
                                // Windup
                                for (let i = 0; i < 40; i++) {
                                    particles.push(new Particle(
                                        this.x, this.y - 20,
                                        '#8b4513',
                                        (Math.random() - 0.5) * 3,
                                        -Math.random() * 5,
                                        50
                                    ));
                                }
                                
                                // Throw boulder
                                setTimeout(() => {
                                    const angle = Math.atan2(dy, dx);
                                    for (let i = 0; i < 5; i++) {
                                        setTimeout(() => {
                                            projectiles.push(new Projectile(this.x, this.y, angle, 6, 'enemy'));
                                        }, i * 100);
                                    }
                                }, 1000);
                            }
                        } else if (this.attackPattern === 1) {
                            // Ground slam - shockwave
                            if (this.onGround && this.patternTimer % 160 === 0) {
                                this.vy = -10;
                                
                                setTimeout(() => {
                                    if (this.onGround) {
                                        // Massive shockwave
                                        for (let i = 0; i < 50; i++) {
                                            particles.push(new Particle(
                                                this.x + (Math.random() - 0.5) * 100,
                                                this.y + this.height/2,
                                                '#696969',
                                                (Math.random() - 0.5) * 15,
                                                -Math.random() * 8,
                                                60
                                            ));
                                        }
                                        
                                        for (let i = 0; i < 6; i++) {
                                            const angle = i * (Math.PI / 3);
                                            projectiles.push(new Projectile(this.x, this.y, angle, 5, 'enemy'));
                                        }
                                    }
                                }, 1200);
                            }
                        } else {
                            // Rock spray
                            if (this.patternTimer % 100 === 0) {
                                for (let i = -2; i <= 2; i++) {
                                    const angle = (this.facing > 0 ? 0 : Math.PI) + i * 0.25;
                                    projectiles.push(new Projectile(this.x, this.y, angle, 6, 'enemy'));
                                }
                            }
                        }
                        break;
                        
                    case 'Toxic Assassin':
                        // Fast hit and run, poison attacks
                        if (dist > 200) {
                            this.vx = this.facing * this.speed;
                        } else if (dist < 100) {
                            this.vx = -this.facing * this.speed;
                        } else {
                            this.vx *= 0.9;
                        }
                        
                        if (this.attackPattern === 0) {
                            // Poison dart spray
                            if (this.patternTimer % 80 === 0) {
                                const angle = Math.atan2(dy, dx);
                                for (let i = -1; i <= 1; i++) {
                                    projectiles.push(new Projectile(this.x, this.y, angle + i * 0.3, 9, 'enemy'));
                                }
                            }
                        } else if (this.attackPattern === 1) {
                            // Poison cloud (area denial)
                            if (this.patternTimer % 130 === 0) {
                                const cloudX = player.x;
                                const cloudY = player.y;
                                
                                // Create poison cloud
                                for (let i = 0; i < 80; i++) {
                                    setTimeout(() => {
                                        particles.push(new Particle(
                                            cloudX + (Math.random() - 0.5) * 100,
                                            cloudY + (Math.random() - 0.5) * 100,
                                            '#00ff00',
                                            (Math.random() - 0.5) * 2,
                                            (Math.random() - 0.5) * 2,
                                            80
                                        ));
                                    }, i * 10);
                                }
                            }
                        } else {
                            // Blink strike
                            if (this.patternTimer % 110 === 0 && dist < 250) {
                                const oldX = this.x;
                                this.x = player.x + this.facing * 60;
                                
                                for (let i = 0; i < 20; i++) {
                                    particles.push(new Particle(
                                        oldX, this.y, '#228b22',
                                        (Math.random() - 0.5) * 8,
                                        (Math.random() - 0.5) * 8,
                                        30
                                    ));
                                }
                            }
                        }
                        break;
                        
                    case 'Thunder King':
                        // Mid range, lightning attacks
                        if (dist > 160) {
                            this.vx = this.facing * this.speed * 0.6;
                        } else {
                            this.vx *= 0.85;
                        }
                        
                        if (this.attackPattern === 0) {
                            // Lightning bolt (targeted)
                            if (this.patternTimer % 100 === 0) {
                                const targetX = player.x;
                                
                                // Warning flash
                                for (let i = 0; i < 20; i++) {
                                    particles.push(new Particle(
                                        targetX, 0,
                                        '#ffff00',
                                        (Math.random() - 0.5) * 4,
                                        Math.random() * 5,
                                        40
                                    ));
                                }
                                
                                // Lightning strike
                                setTimeout(() => {
                                    for (let i = 0; i < 3; i++) {
                                        projectiles.push(new Projectile(
                                            targetX + (Math.random() - 0.5) * 40,
                                            0,
                                            Math.PI / 2,
                                            12,
                                            'enemy'
                                        ));
                                    }
                                }, 600);
                            }
                        } else if (this.attackPattern === 1) {
                            // Electric orb
                            if (this.patternTimer % 90 === 0) {
                                const angle = Math.atan2(dy, dx);
                                projectiles.push(new Projectile(this.x, this.y, angle, 6, 'enemy'));
                            }
                        } else {
                            // Chain lightning
                            if (this.patternTimer % 120 === 0) {
                                for (let i = 0; i < 8; i++) {
                                    setTimeout(() => {
                                        const randomAngle = Math.random() * Math.PI * 2;
                                        projectiles.push(new Projectile(this.x, this.y, randomAngle, 7, 'enemy'));
                                    }, i * 80);
                                }
                            }
                        }
                        break;
                        
                    case 'Necromancer':
                        // Stay back, summon attacks
                        if (dist < 250) {
                            this.vx = -this.facing * this.speed;
                        } else {
                            this.vx *= 0.9;
                        }
                        
                        if (this.attackPattern === 0) {
                            // Soul missiles
                            if (this.patternTimer % 70 === 0) {
                                const angle = Math.atan2(dy, dx);
                                projectiles.push(new Projectile(this.x, this.y, angle, 5, 'enemy'));
                            }
                        } else if (this.attackPattern === 1) {
                            // Curse circle (telegraphed danger zone)
                            if (this.patternTimer % 140 === 0) {
                                const curseX = player.x;
                                const curseY = player.y;
                                
                                // Show curse forming
                                for (let i = 0; i < 60; i++) {
                                    setTimeout(() => {
                                        const angle = (Math.PI * 2 / 20) * (i % 20);
                                        particles.push(new Particle(
                                            curseX + Math.cos(angle) * 60,
                                            curseY + Math.sin(angle) * 60,
                                            '#8b008b',
                                            0, 0, 60
                                        ));
                                    }, i * 20);
                                }
                                
                                // Curse activates
                                setTimeout(() => {
                                    for (let i = 0; i < 12; i++) {
                                        const angle = (Math.PI * 2 / 12) * i;
                                        projectiles.push(new Projectile(
                                            curseX + Math.cos(angle) * 60,
                                            curseY + Math.sin(angle) * 60,
                                            angle + Math.PI,
                                            4,
                                            'enemy'
                                        ));
                                    }
                                }, 1200);
                            }
                        } else {
                            // Skull barrage
                            if (this.patternTimer % 100 === 0) {
                                for (let i = 0; i < 4; i++) {
                                    setTimeout(() => {
                                        const angle = Math.atan2(dy, dx) + (Math.random() - 0.5) * 0.6;
                                        projectiles.push(new Projectile(this.x, this.y, angle, 6, 'enemy'));
                                    }, i * 150);
                                }
                            }
                        }
                        break;
                        
                    case 'Blood Reaper':
                        // Aggressive but predictable
                        if (dist > 140) {
                            this.vx = this.facing * this.speed * 0.8;
                        } else {
                            this.vx *= 0.9;
                        }
                        
                        if (this.attackPattern === 0) {
                            // Blood scythe swing (arc of projectiles)
                            if (this.patternTimer % 90 === 0) {
                                for (let i = -3; i <= 3; i++) {
                                    const angle = (this.facing > 0 ? 0 : Math.PI) + i * 0.2;
                                    projectiles.push(new Projectile(this.x, this.y, angle, 7, 'enemy'));
                                }
                            }
                        } else if (this.attackPattern === 1) {
                            // Blood rain
                            if (this.patternTimer % 40 === 0 && this.patternTimer % 160 > 0) {
                                const x = player.x + (Math.random() - 0.5) * 150;
                                projectiles.push(new Projectile(x, 0, Math.PI / 2, 8, 'enemy'));
                            }
                        } else {
                            // Reaper dash (telegraphed)
                            if (this.patternTimer % 130 === 0) {
                                // Show intent
                                for (let i = 0; i < 15; i++) {
                                    particles.push(new Particle(
                                        this.x, this.y,
                                        '#dc143c',
                                        this.facing * (i + 5),
                                        (Math.random() - 0.5) * 3,
                                        35
                                    ));
                                }
                                
                                // Dash attack
                                setTimeout(() => {
                                    this.vx = this.facing * this.speed * 10;
                                    setTimeout(() => this.vx *= 0.2, 250);
                                }, 500);
                            }
                        }
                        break;
                        
                    case 'Void Walker':
                        // Unpredictable teleporting
                        if (this.patternTimer % 60 === 0) {
                            this.vx *= 0.5; // Slow down
                        }
                        
                        if (this.attackPattern === 0) {
                            // Void rift - creates portals that shoot
                            if (this.patternTimer % 120 === 0) {
                                for (let i = 0; i < 2; i++) {
                                    const riftX = Math.random() * (canvas.width - 100) + 50;
                                    const riftY = Math.random() * (canvas.height - 200) + 100;
                                    
                                    // Portal particles
                                    for (let j = 0; j < 30; j++) {
                                        particles.push(new Particle(
                                            riftX, riftY, '#9370db',
                                            (Math.random() - 0.5) * 4,
                                            (Math.random() - 0.5) * 4,
                                            60
                                        ));
                                    }
                                    
                                    // Portal shoots
                                    setTimeout(() => {
                                        const angle = Math.atan2(player.y - riftY, player.x - riftX);
                                        projectiles.push(new Projectile(riftX, riftY, angle, 7, 'enemy'));
                                    }, 700);
                                }
                            }
                        } else if (this.attackPattern === 1) {
                            // Void beam (sweeping)
                            if (this.patternTimer % 150 === 0) {
                                const startAngle = Math.atan2(dy, dx);
                                for (let i = 0; i < 7; i++) {
                                    setTimeout(() => {
                                        const angle = startAngle + (i - 3) * 0.15;
                                        projectiles.push(new Projectile(this.x, this.y, angle, 8, 'enemy'));
                                    }, i * 100);
                                }
                            }
                        } else {
                            // Void collapse (pulls toward center then explodes)
                            if (this.patternTimer % 180 === 0) {
                                setTimeout(() => {
                                    for (let i = 0; i < 16; i++) {
                                        const angle = (Math.PI * 2 / 16) * i;
                                        projectiles.push(new Projectile(this.x, this.y, angle, 6, 'enemy'));
                                    }
                                }, 800);
                            }
                        }
                        
                        // Random teleport
                        if (this.patternTimer % 80 === 0 && Math.random() < 0.4) {
                            const angle = Math.random() * Math.PI * 2;
                            this.x = player.x + Math.cos(angle) * 200;
                            this.y = Math.max(150, Math.min(canvas.height - 150, player.y + Math.sin(angle) * 150));
                            
                            for (let i = 0; i < 25; i++) {
                                particles.push(new Particle(
                                    this.x, this.y, '#483d8b',
                                    (Math.random() - 0.5) * 8,
                                    (Math.random() - 0.5) * 8,
                                    40
                                ));
                            }
                        }
                        break;
                        
                    case 'Crystal Sage':
                        // Floats around, summons crystal spikes and laser beams
                        // Stays at long range, VERY defensive
                        if (dist > 350) {
                            this.vx = this.facing * this.speed * 0.8;
                        } else if (dist < 250) {
                            this.vx = -this.facing * this.speed;
                        } else {
                            this.vx *= 0.92;
                        }
                        
                        if (this.attackPattern === 0) {
                            // Crystal Cage - surrounds player with crystals then they explode inward
                            if (this.patternTimer % 200 === 0) {
                                const cageRadius = 150;
                                // Telegraph cage formation
                                for (let i = 0; i < 12; i++) {
                                    const angle = (Math.PI * 2 / 12) * i;
                                    const x = player.x + Math.cos(angle) * cageRadius;
                                    const y = player.y + Math.sin(angle) * cageRadius;
                                    
                                    // Show crystal forming locations
                                    for (let j = 0; j < 15; j++) {
                                        setTimeout(() => {
                                            particles.push(new Particle(
                                                x, y, '#ff1493',
                                                (Math.random() - 0.5) * 3,
                                                (Math.random() - 0.5) * 3,
                                                30
                                            ));
                                        }, j * 50);
                                    }
                                    
                                    // Then shoot inward
                                    setTimeout(() => {
                                        const angleToCenter = Math.atan2(player.y - y, player.x - x);
                                        projectiles.push(new Projectile(x, y, angleToCenter, 8, 'enemy'));
                                    }, 1000);
                                }
                            }
                        } else if (this.attackPattern === 1) {
                            // Laser Sweep - charges then sweeps laser across arena
                            if (this.patternTimer % 180 === 0) {
                                // Charge up visual
                                for (let i = 0; i < 50; i++) {
                                    setTimeout(() => {
                                        particles.push(new Particle(
                                            this.x, this.y, '#ff69b4',
                                            (Math.random() - 0.5) * 10,
                                            (Math.random() - 0.5) * 10,
                                            20
                                        ));
                                    }, i * 20);
                                }
                                
                                // Sweep laser (multiple projectiles in arc)
                                setTimeout(() => {
                                    for (let sweep = 0; sweep < 15; sweep++) {
                                        setTimeout(() => {
                                            const angle = -Math.PI/3 + (sweep / 15) * (2 * Math.PI / 3);
                                            projectiles.push(new Projectile(this.x, this.y, angle, 12, 'enemy'));
                                        }, sweep * 40);
                                    }
                                }, 1000);
                            }
                        } else {
                            // Crystal Rain - rains crystals from above in waves
                            if (this.patternTimer % 20 === 0 && this.patternTimer % 180 < 100) {
                                for (let i = 0; i < 3; i++) {
                                    const x = player.x + (Math.random() - 0.5) * 200;
                                    projectiles.push(new Projectile(x, 0, Math.PI / 2, 7 + Math.random() * 3, 'enemy'));
                                }
                            }
                        }
                        
                        // Levitate effect (hover up and down)
                        if (this.onGround && this.patternTimer % 60 === 0) {
                            this.vy = -6;
                        }
                        break;
                        
                    case 'Iron Colossus':
                        // MASSIVE tank boss, slow but DEVASTATING attacks
                        // Almost never moves, just uses powerful area attacks
                        this.vx *= 0.95; // Almost stationary
                        
                        if (this.attackPattern === 0) {
                            // Meteor Slam - jumps up and creates massive shockwave
                            if (this.onGround && this.patternTimer % 220 === 0) {
                                // Jump animation
                                this.vy = -15;
                                
                                // Warning particles
                                for (let i = 0; i < 60; i++) {
                                    particles.push(new Particle(
                                        this.x, this.y, '#ff0000',
                                        (Math.random() - 0.5) * 8,
                                        -Math.random() * 10,
                                        60
                                    ));
                                }
                                
                                // On landing create HUGE shockwave
                                setTimeout(() => {
                                    if (this.onGround) {
                                        // Screen shake effect through particles
                                        for (let i = 0; i < 100; i++) {
                                            particles.push(new Particle(
                                                this.x + (Math.random() - 0.5) * 200,
                                                this.y + this.height/2,
                                                ['#696969', '#8b4513', '#a9a9a9'][Math.floor(Math.random() * 3)],
                                                (Math.random() - 0.5) * 20,
                                                -Math.random() * 15,
                                                70
                                            ));
                                        }
                                        
                                        // Shockwave projectiles in ALL directions
                                        for (let i = 0; i < 24; i++) {
                                            const angle = (Math.PI * 2 / 24) * i;
                                            projectiles.push(new Projectile(this.x, this.y, angle, 6, 'enemy'));
                                        }
                                        
                                        // Ground cracks (bonus projectiles along ground)
                                        projectiles.push(new Projectile(this.x, this.y + this.height/2, 0, 8, 'enemy'));
                                        projectiles.push(new Projectile(this.x, this.y + this.height/2, Math.PI, 8, 'enemy'));
                                    }
                                }, 1500);
                            }
                        } else if (this.attackPattern === 1) {
                            // Iron Fortress - becomes invulnerable and shoots out spinning blades
                            if (this.patternTimer % 200 === 0) {
                                this.isInvulnerable = true;
                                
                                // Visual shield
                                for (let i = 0; i < 80; i++) {
                                    setTimeout(() => {
                                        const angle = (Date.now() / 20) + i;
                                        particles.push(new Particle(
                                            this.x + Math.cos(angle) * 60,
                                            this.y + Math.sin(angle) * 60,
                                            '#4169e1',
                                            0, 0, 10
                                        ));
                                    }, i * 10);
                                }
                                
                                // Spinning blade waves
                                for (let wave = 0; wave < 4; wave++) {
                                    setTimeout(() => {
                                        for (let i = 0; i < 16; i++) {
                                            const angle = (Math.PI * 2 / 16) * i + wave * 0.2;
                                            projectiles.push(new Projectile(this.x, this.y, angle, 5 + wave, 'enemy'));
                                        }
                                    }, wave * 600);
                                }
                                
                                // End invulnerability
                                setTimeout(() => {
                                    this.isInvulnerable = false;
                                }, 2800);
                            }
                        } else {
                            // Hammer Throw - telegraphed MASSIVE projectile
                            if (this.patternTimer % 170 === 0) {
                                const angle = Math.atan2(dy, dx);
                                
                                // Huge windup telegraph
                                for (let i = 0; i < 40; i++) {
                                    setTimeout(() => {
                                        particles.push(new Particle(
                                            this.x + Math.cos(angle) * 30 * (i / 40),
                                            this.y + Math.sin(angle) * 30 * (i / 40),
                                            '#ffd700',
                                            0, 0, 20
                                        ));
                                    }, i * 30);
                                }
                                
                                // Throw 3 huge projectiles
                                setTimeout(() => {
                                    for (let i = -1; i <= 1; i++) {
                                        projectiles.push(new Projectile(this.x, this.y, angle + i * 0.25, 9, 'enemy'));
                                    }
                                }, 1200);
                            }
                        }
                        break;
                        
                    case 'Phantom Assassin':
                        // SUPER FAST hit-and-run, constantly teleporting
                        // Most mobile boss, hardest to hit
                        if (dist > 250 || dist < 80) {
                            // Teleport frequently
                            if (this.patternTimer % 50 === 0) {
                                const oldX = this.x;
                                const oldY = this.y;
                                
                                // Teleport near player
                                const angle = Math.random() * Math.PI * 2;
                                const teleportDist = 120 + Math.random() * 80;
                                this.x = player.x + Math.cos(angle) * teleportDist;
                                this.y = Math.max(150, Math.min(canvas.height - 150, player.y + Math.sin(angle) * teleportDist));
                                
                                // After-image particles
                                for (let i = 0; i < 20; i++) {
                                    particles.push(new Particle(oldX, oldY, '#8b008b', (Math.random() - 0.5) * 6, (Math.random() - 0.5) * 6, 35));
                                    particles.push(new Particle(this.x, this.y, '#8b008b', (Math.random() - 0.5) * 6, (Math.random() - 0.5) * 6, 35));
                                }
                            }
                        }
                        
                        if (this.attackPattern === 0) {
                            // Phantom Strike - multiple rapid teleports with attacks
                            if (this.patternTimer % 130 === 0) {
                                for (let strike = 0; strike < 5; strike++) {
                                    setTimeout(() => {
                                        // Teleport
                                        const angle = Math.random() * Math.PI * 2;
                                        this.x = player.x + Math.cos(angle) * 100;
                                        this.y = player.y + Math.sin(angle) * 80;
                                        
                                        // Strike
                                        const attackAngle = Math.atan2(player.y - this.y, player.x - this.x);
                                        for (let i = 0; i < 3; i++) {
                                            projectiles.push(new Projectile(this.x, this.y, attackAngle + (i - 1) * 0.2, 11, 'enemy'));
                                        }
                                        
                                        // Effect
                                        for (let i = 0; i < 15; i++) {
                                            particles.push(new Particle(this.x, this.y, '#ff00ff', (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10, 25));
                                        }
                                    }, strike * 400);
                                }
                            }
                        } else if (this.attackPattern === 1) {
                            // Shadow Clones - creates 4 clones that all attack simultaneously
                            if (this.patternTimer % 180 === 0) {
                                const clonePositions = [
                                    {x: player.x - 150, y: player.y - 100},
                                    {x: player.x + 150, y: player.y - 100},
                                    {x: player.x - 100, y: player.y + 80},
                                    {x: player.x + 100, y: player.y + 80}
                                ];
                                
                                clonePositions.forEach((pos, idx) => {
                                    setTimeout(() => {
                                        // Show clone appearing
                                        for (let i = 0; i < 20; i++) {
                                            particles.push(new Particle(pos.x, pos.y, '#000000', (Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5, 40));
                                        }
                                        
                                        // Clone attacks
                                        setTimeout(() => {
                                            const angle = Math.atan2(player.y - pos.y, player.x - pos.x);
                                            projectiles.push(new Projectile(pos.x, pos.y, angle, 10, 'enemy'));
                                        }, 500);
                                    }, idx * 200);
                                });
                            }
                        } else {
                            // Void Dash - dashes through player dealing damage
                            if (this.patternTimer % 100 === 0) {
                                // Telegraph dash
                                const angle = Math.atan2(player.y - this.y, player.x - this.x);
                                for (let i = 0; i < 30; i++) {
                                    particles.push(new Particle(
                                        this.x + Math.cos(angle) * i * 5,
                                        this.y + Math.sin(angle) * i * 5,
                                        '#ff0000',
                                        0, 0, 40
                                    ));
                                }
                                
                                // Execute dash
                                setTimeout(() => {
                                    const dashSpeed = 18;
                                    this.vx = Math.cos(angle) * dashSpeed;
                                    this.vy = Math.sin(angle) * dashSpeed;
                                    
                                    // Stop dash
                                    setTimeout(() => {
                                        this.vx *= 0.1;
                                        this.vy *= 0.1;
                                    }, 250);
                                }, 600);
                            }
                        }
                        break;
                        
                    case 'Plague Doctor':
                        // Poison/DOT specialist, area denial through toxic zones
                        // Stays at medium range, creates hazard zones
                        if (dist > 200) {
                            this.vx = this.facing * this.speed * 0.6;
                        } else if (dist < 120) {
                            this.vx = -this.facing * this.speed * 0.8;
                        } else {
                            this.vx *= 0.9;
                        }
                        
                        if (this.attackPattern === 0) {
                            // Plague Bomb - throws bombs that create lingering poison clouds
                            if (this.patternTimer % 120 === 0) {
                                for (let bomb = 0; bomb < 3; bomb++) {
                                    setTimeout(() => {
                                        const targetX = player.x + (Math.random() - 0.5) * 150;
                                        const targetY = player.y;
                                        const angle = Math.atan2(targetY - this.y, targetX - this.x);
                                        
                                        // Bomb projectile
                                        projectiles.push(new Projectile(this.x, this.y, angle, 7, 'enemy'));
                                        
                                        // Create poison cloud at target
                                        setTimeout(() => {
                                            for (let i = 0; i < 120; i++) {
                                                setTimeout(() => {
                                                    particles.push(new Particle(
                                                        targetX + (Math.random() - 0.5) * 120,
                                                        targetY + (Math.random() - 0.5) * 120,
                                                        '#00ff00',
                                                        (Math.random() - 0.5) * 2,
                                                        -Math.random() * 2,
                                                        100
                                                    ));
                                                }, i * 20);
                                            }
                                        }, 800);
                                    }, bomb * 400);
                                }
                            }
                        } else if (this.attackPattern === 1) {
                            // Miasma Wave - sends out expanding toxic rings
                            if (this.patternTimer % 140 === 0) {
                                for (let ring = 1; ring <= 4; ring++) {
                                    setTimeout(() => {
                                        for (let i = 0; i < 16; i++) {
                                            const angle = (Math.PI * 2 / 16) * i;
                                            projectiles.push(new Projectile(this.x, this.y, angle, 4 + ring * 0.5, 'enemy'));
                                        }
                                        
                                        // Ring particles
                                        for (let i = 0; i < 20; i++) {
                                            const angle = (Math.PI * 2 / 20) * i;
                                            particles.push(new Particle(
                                                this.x + Math.cos(angle) * ring * 30,
                                                this.y + Math.sin(angle) * ring * 30,
                                                '#228b22',
                                                0, 0, 30
                                            ));
                                        }
                                    }, ring * 500);
                                }
                            }
                        } else {
                            // Pestilence Swarm - releases swarm of poison projectiles
                            if (this.patternTimer % 90 === 0) {
                                // Release swarm in random directions
                                for (let i = 0; i < 15; i++) {
                                    setTimeout(() => {
                                        const angle = Math.random() * Math.PI * 2;
                                        const speed = 4 + Math.random() * 4;
                                        projectiles.push(new Projectile(this.x, this.y, angle, speed, 'enemy'));
                                    }, i * 50);
                                }
                            }
                        }
                        break;
                        
                    case 'Storm Herald':
                        // Lightning and wind attacks, very erratic movement
                        // Flies around using wind currents
                        if (dist > 220) {
                            this.vx = this.facing * this.speed * 0.9;
                        } else {
                            this.vx *= 0.88;
                        }
                        
                        // Fly/float behavior
                        if (this.patternTimer % 90 === 0) {
                            this.vy = -8;
                        }
                        
                        if (this.attackPattern === 0) {
                            // Lightning Storm - calls down multiple lightning strikes
                            if (this.patternTimer % 150 === 0) {
                                for (let strike = 0; strike < 8; strike++) {
                                    setTimeout(() => {
                                        const strikeX = player.x + (Math.random() - 0.5) * 300;
                                        
                                        // Lightning telegraph (from top)
                                        for (let i = 0; i < 20; i++) {
                                            particles.push(new Particle(
                                                strikeX + (Math.random() - 0.5) * 20,
                                                i * 35,
                                                '#ffff00',
                                                0, 0, 15
                                            ));
                                        }
                                        
                                        // Lightning bolt
                                        setTimeout(() => {
                                            for (let i = 0; i < 5; i++) {
                                                projectiles.push(new Projectile(
                                                    strikeX + (Math.random() - 0.5) * 30,
                                                    0,
                                                    Math.PI / 2,
                                                    15 + Math.random() * 5,
                                                    'enemy'
                                                ));
                                            }
                                            
                                            // Impact effect
                                            for (let i = 0; i < 30; i++) {
                                                particles.push(new Particle(
                                                    strikeX,
                                                    canvas.height - 50,
                                                    '#ffd700',
                                                    (Math.random() - 0.5) * 15,
                                                    -Math.random() * 10,
                                                    40
                                                ));
                                            }
                                        }, 400);
                                    }, strike * 200);
                                }
                            }
                        } else if (this.attackPattern === 1) {
                            // Tornado - creates spinning wind vortex that pulls player
                            if (this.patternTimer % 180 === 0) {
                                const tornadoX = this.x;
                                const tornadoY = this.y;
                                
                                // Tornado particles (spiraling outward)
                                for (let i = 0; i < 200; i++) {
                                    setTimeout(() => {
                                        const angle = (i / 10) + Date.now() / 200;
                                        const radius = (i / 5);
                                        particles.push(new Particle(
                                            tornadoX + Math.cos(angle) * radius,
                                            tornadoY + Math.sin(angle) * radius,
                                            '#b0e0e6',
                                            Math.cos(angle) * 2,
                                            Math.sin(angle) * 2,
                                            40
                                        ));
                                    }, i * 20);
                                }
                                
                                // Spiral projectiles
                                for (let wave = 0; wave < 3; wave++) {
                                    setTimeout(() => {
                                        for (let i = 0; i < 12; i++) {
                                            const angle = (Math.PI * 2 / 12) * i + wave * 0.3;
                                            projectiles.push(new Projectile(tornadoX, tornadoY, angle, 5 + wave, 'enemy'));
                                        }
                                    }, wave * 600);
                                }
                            }
                        } else {
                            // Thunder Clap - shockwave expanding from boss
                            if (this.patternTimer % 110 === 0) {
                                // Charge up
                                for (let i = 0; i < 30; i++) {
                                    particles.push(new Particle(
                                        this.x + (Math.random() - 0.5) * 60,
                                        this.y + (Math.random() - 0.5) * 60,
                                        '#4169e1',
                                        (Math.random() - 0.5) * 8,
                                        (Math.random() - 0.5) * 8,
                                        50
                                    ));
                                }
                                
                                // Expanding shockwave
                                setTimeout(() => {
                                    for (let ring = 1; ring <= 3; ring++) {
                                        setTimeout(() => {
                                            for (let i = 0; i < 20; i++) {
                                                const angle = (Math.PI * 2 / 20) * i;
                                                projectiles.push(new Projectile(this.x, this.y, angle, 6 + ring, 'enemy'));
                                            }
                                        }, ring * 200);
                                    }
                                }, 500);
                            }
                        }
                        break;
                }
            }

            draw() {
                // Boss aura/glow effect
                const pulseIntensity = 0.7 + Math.sin(Date.now() / 300) * 0.3;
                ctx.globalAlpha = 0.2 * pulseIntensity;
                const auraGradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.width * 2);
                auraGradient.addColorStop(0, this.color);
                auraGradient.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = auraGradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.width * 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.facing, 1);
                
                const wobble = Math.sin(this.animFrame / 10) * 2;
                
                // Detailed boss designs with textures
                switch(this.type) {
                    case 'Crimson Knight':
                        // Armor body with metallic texture
                        const armorGrad = ctx.createLinearGradient(-this.width/2, 0, this.width/2, 0);
                        armorGrad.addColorStop(0, '#8b0000');
                        armorGrad.addColorStop(0.5, '#b22222');
                        armorGrad.addColorStop(1, '#8b0000');
                        ctx.fillStyle = armorGrad;
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        // Armor plates
                        ctx.strokeStyle = '#4a0000';
                        ctx.lineWidth = 2;
                        for (let i = 0; i < 5; i++) {
                            ctx.strokeRect(-this.width/2 + 2, -this.height/2 + i * 12, this.width - 4, 10);
                        }
                        
                        // Golden trim
                        ctx.fillStyle = '#ffd700';
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, 6);
                        ctx.fillRect(-this.width / 2, this.height / 2 - 6, this.width, 6);
                        ctx.fillRect(-this.width / 2, -this.height / 4, this.width, 3);
                        
                        // Detailed crown
                        ctx.fillStyle = '#ffd700';
                        ctx.fillRect(-this.width/2, -this.height/2 - 12, this.width, 4);
                        for (let i = -2; i <= 2; i++) {
                            const crownX = i * 10;
                            ctx.fillRect(crownX - 3, -this.height / 2 - 12, 6, 16);
                            ctx.fillStyle = '#ff0000';
                            ctx.beginPath();
                            ctx.arc(crownX, -this.height/2 - 14, 3, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.fillStyle = '#ffd700';
                        }
                        
                        // Massive sword
                        ctx.fillStyle = '#696969';
                        ctx.fillRect(this.width / 2 - 2, -this.height / 2 - 10, 12, this.height + 20);
                        // Blade shine
                        ctx.fillStyle = '#c0c0c0';
                        ctx.fillRect(this.width / 2 + 2, -this.height / 2 - 10, 4, this.height + 20);
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(this.width / 2 + 4, -this.height / 2 - 10, 1, this.height + 20);
                        // Crossguard
                        ctx.fillStyle = '#ffd700';
                        ctx.fillRect(this.width / 2 - 10, -this.height / 2 + 10, 28, 8);
                        // Hilt
                        ctx.fillStyle = '#8b4513';
                        ctx.fillRect(this.width / 2 + 2, -this.height / 2, 4, 15);
                        
                        // Shield
                        ctx.fillStyle = '#696969';
                        ctx.beginPath();
                        ctx.arc(-this.width/2 - 10, 0, 18, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#ffd700';
                        ctx.beginPath();
                        ctx.moveTo(-this.width/2 - 10, -15);
                        ctx.lineTo(-this.width/2 - 5, -5);
                        ctx.lineTo(-this.width/2 - 10, 15);
                        ctx.lineTo(-this.width/2 - 15, -5);
                        ctx.closePath();
                        ctx.fill();
                        break;
                        
                    case 'Shadow Lord':
                        // Shadow trails
                        ctx.globalAlpha = 0.3;
                        ctx.fillStyle = '#000000';
                        for (let i = 0; i < 4; i++) {
                            const offset = i * 10;
                            ctx.fillRect(-this.width/2 - offset, -this.height/2, this.width, this.height);
                        }
                        ctx.globalAlpha = 1;
                        
                        // Dark cloak with texture
                        const cloakGrad = ctx.createLinearGradient(0, -this.height/2, 0, this.height/2);
                        cloakGrad.addColorStop(0, '#1a1a1a');
                        cloakGrad.addColorStop(0.5, '#2a2a2a');
                        cloakGrad.addColorStop(1, '#0a0a0a');
                        ctx.fillStyle = cloakGrad;
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        // Tattered cloak edges
                        ctx.fillStyle = '#000000';
                        for (let i = 0; i < 8; i++) {
                            const x = -this.width/2 + i * 7;
                            const length = 5 + Math.sin(Date.now()/100 + i) * 3;
                            ctx.fillRect(x, this.height/2, 5, length);
                        }
                        
                        // Glowing eyes
                        ctx.fillStyle = '#ff0000';
                        ctx.shadowColor = '#ff0000';
                        ctx.shadowBlur = 15;
                        ctx.globalAlpha = 0.9 + Math.sin(Date.now() / 200) * 0.1;
                        ctx.beginPath();
                        ctx.arc(-8, -this.height / 2 + 18, 6, 0, Math.PI * 2);
                        ctx.arc(8, -this.height / 2 + 18, 6, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                        ctx.globalAlpha = 1;
                        
                        // Shadow blades
                        ctx.fillStyle = '#4a4a4a';
                        for (let i = 0; i < 2; i++) {
                            const side = i === 0 ? -1 : 1;
                            const offset = side * (this.width/2 + 5);
                            ctx.save();
                            ctx.translate(offset, wobble);
                            ctx.rotate(side * Math.PI / 6);
                            ctx.fillRect(-3, -25, 6, 40);
                            ctx.fillStyle = '#6a6a6a';
                            ctx.fillRect(-1, -25, 2, 40);
                            ctx.restore();
                        }
                        break;
                        
                    case 'Frost Warden':
                        // Icy body
                        const iceBodyGrad = ctx.createLinearGradient(0, -this.height/2, 0, this.height/2);
                        iceBodyGrad.addColorStop(0, '#87ceeb');
                        iceBodyGrad.addColorStop(0.5, '#00bfff');
                        iceBodyGrad.addColorStop(1, '#4682b4');
                        ctx.fillStyle = iceBodyGrad;
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        // Ice crystal texture
                        ctx.strokeStyle = '#b0e0e6';
                        ctx.lineWidth = 1;
                        for (let i = 0; i < 6; i++) {
                            const x = -this.width/2 + Math.random() * this.width;
                            const y = -this.height/2 + Math.random() * this.height;
                            ctx.beginPath();
                            for (let j = 0; j < 6; j++) {
                                const angle = (Math.PI * 2 / 6) * j;
                                const px = x + Math.cos(angle) * 4;
                                const py = y + Math.sin(angle) * 4;
                                if (j === 0) ctx.moveTo(px, py);
                                else ctx.lineTo(px, py);
                            }
                            ctx.closePath();
                            ctx.stroke();
                        }
                        
                        // Ice crown with spikes
                        ctx.fillStyle = '#ffffff';
                        for (let i = 0; i < 7; i++) {
                            const x = (i - 3) * 8;
                            const height = 15 + (i % 2) * 5;
                            ctx.beginPath();
                            ctx.moveTo(x, -this.height / 2);
                            ctx.lineTo(x - 4, -this.height / 2 - height);
                            ctx.lineTo(x + 4, -this.height / 2 - height);
                            ctx.closePath();
                            ctx.fill();
                        }
                        
                        // Frost aura
                        ctx.globalAlpha = 0.4;
                        const frostAura = ctx.createRadialGradient(0, 0, 0, 0, 0, this.width);
                        frostAura.addColorStop(0, '#00ffff');
                        frostAura.addColorStop(1, 'rgba(0, 255, 255, 0)');
                        ctx.fillStyle = frostAura;
                        ctx.beginPath();
                        ctx.arc(0, 0, this.width * 1.2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                        
                        // Ice staff
                        ctx.fillStyle = '#87ceeb';
                        ctx.fillRect(-this.width/2 - 15, -this.height/2, 8, this.height + 15);
                        ctx.fillStyle = '#00ffff';
                        ctx.beginPath();
                        ctx.arc(-this.width/2 - 11, -this.height/2 - 10, 12, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        break;
                        
                    case 'Flame Tyrant':
                        // Molten armor
                        const lavaGrad = ctx.createLinearGradient(0, -this.height/2, 0, this.height/2);
                        lavaGrad.addColorStop(0, '#ff4500');
                        lavaGrad.addColorStop(0.5, '#ff6347');
                        lavaGrad.addColorStop(1, '#8b0000');
                        ctx.fillStyle = lavaGrad;
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        // Lava cracks
                        ctx.strokeStyle = '#ffff00';
                        ctx.lineWidth = 2;
                        for (let i = 0; i < 5; i++) {
                            const startY = -this.height/2 + i * 12;
                            ctx.beginPath();
                            ctx.moveTo(-this.width/2, startY);
                            ctx.lineTo(-this.width/2 + 10, startY + 6);
                            ctx.lineTo(-this.width/2 + 20, startY + 3);
                            ctx.lineTo(this.width/2, startY + 8);
                            ctx.stroke();
                        }
                        
                        // Flame crown/horns
                        ctx.fillStyle = '#ff0000';
                        for (let i = 0; i < 5; i++) {
                            const x = (i - 2) * 10;
                            const flameHeight = 15 + Math.sin(Date.now() / 100 + i) * 5;
                            ctx.beginPath();
                            ctx.moveTo(x, -this.height / 2);
                            ctx.lineTo(x - 6, -this.height / 2 - flameHeight);
                            ctx.lineTo(x, -this.height / 2 - flameHeight + 5);
                            ctx.lineTo(x + 6, -this.height / 2 - flameHeight);
                            ctx.closePath();
                            ctx.fill();
                        }
                        
                        // Demon horns
                        ctx.fillStyle = '#8b0000';
                        ctx.beginPath();
                        ctx.arc(-18, -this.height/2 + 8, 8, 0, Math.PI * 2);
                        ctx.arc(18, -this.height/2 + 8, 8, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Flame particles around boss
                        if (Math.random() < 0.3) {
                            particles.push(new Particle(
                                this.x + (Math.random() - 0.5) * this.width,
                                this.y + (Math.random() - 0.5) * this.height,
                                ['#ff4500', '#ff6347', '#ffff00'][Math.floor(Math.random() * 3)],
                                (Math.random() - 0.5) * 2,
                                -Math.random() * 3,
                                30
                            ));
                        }
                        break;
                        
                    case 'Stone Golem':
                        // Rocky body
                        ctx.fillStyle = '#696969';
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        // Stone blocks texture
                        ctx.strokeStyle = '#2f4f4f';
                        ctx.lineWidth = 3;
                        for (let y = 0; y < 4; y++) {
                            for (let x = 0; x < 2; x++) {
                                const bx = -this.width/2 + x * (this.width/2);
                                const by = -this.height/2 + y * (this.height/4);
                                ctx.strokeRect(bx, by, this.width/2, this.height/4);
                            }
                        }
                        
                        // Moss/cracks
                        ctx.fillStyle = '#228b22';
                        for (let i = 0; i < 8; i++) {
                            const x = -this.width/2 + Math.random() * this.width;
                            const y = -this.height/2 + Math.random() * this.height;
                            ctx.fillRect(x, y, 4, 6);
                        }
                        
                        // Glowing core
                        ctx.fillStyle = '#ff4500';
                        ctx.shadowColor = '#ff4500';
                        ctx.shadowBlur = 10;
                        ctx.beginPath();
                        ctx.arc(0, 0, 8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                        
                        // Massive fists
                        ctx.fillStyle = '#808080';
                        for (let i = 0; i < 2; i++) {
                            const side = i === 0 ? -1 : 1;
                            const fistX = side * (this.width/2 + 10);
                            ctx.fillRect(fistX - 8, 5 + wobble * side, 16, 20);
                            // Knuckles
                            ctx.fillStyle = '#696969';
                            for (let j = 0; j < 3; j++) {
                                ctx.fillRect(fistX - 6 + j * 4, 5 + wobble * side, 3, 8);
                            }
                            ctx.fillStyle = '#808080';
                        }
                        break;
                        
                    case 'Toxic Assassin':
                        // Toxic green body
                        const toxicGrad = ctx.createLinearGradient(0, -this.height/2, 0, this.height/2);
                        toxicGrad.addColorStop(0, '#32cd32');
                        toxicGrad.addColorStop(0.5, '#228b22');
                        toxicGrad.addColorStop(1, '#006400');
                        ctx.fillStyle = toxicGrad;
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        // Poison drips
                        ctx.fillStyle = '#00ff00';
                        ctx.globalAlpha = 0.7;
                        for (let i = 0; i < 6; i++) {
                            const x = -this.width/2 + i * 8;
                            const dripLength = 5 + Math.sin(Date.now()/150 + i) * 4;
                            ctx.fillRect(x, this.height/2, 4, dripLength);
                        }
                        ctx.globalAlpha = 1;
                        
                        // Mask/hood
                        ctx.fillStyle = '#0a0a0a';
                        ctx.fillRect(-this.width/2 + 5, -this.height/2, this.width - 10, 20);
                        
                        // Glowing toxic eyes
                        ctx.fillStyle = '#00ff00';
                        ctx.shadowColor = '#00ff00';
                        ctx.shadowBlur = 10;
                        ctx.beginPath();
                        ctx.arc(-8, -this.height/2 + 12, 4, 0, Math.PI * 2);
                        ctx.arc(8, -this.height/2 + 12, 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                        
                        // Poison daggers
                        for (let i = 0; i < 2; i++) {
                            const side = i === 0 ? -1 : 1;
                            ctx.fillStyle = '#c0c0c0';
                            ctx.save();
                            ctx.translate(side * (this.width/2 + 5), wobble * side);
                            ctx.rotate(side * -Math.PI / 4);
                            ctx.fillRect(-2, -15, 4, 25);
                            ctx.fillStyle = '#00ff00';
                            ctx.fillRect(-1, -15, 2, 10);
                            ctx.restore();
                        }
                        
                        // Toxic aura particles
                        if (Math.random() < 0.2) {
                            particles.push(new Particle(
                                this.x + (Math.random() - 0.5) * this.width * 1.5,
                                this.y + (Math.random() - 0.5) * this.height * 1.5,
                                '#00ff00',
                                (Math.random() - 0.5),
                                -Math.random() * 2,
                                40
                            ));
                        }
                        break;
                        
                    case 'Thunder King':
                        // Electric armor
                        const thunderGrad = ctx.createLinearGradient(0, -this.height/2, 0, this.height/2);
                        thunderGrad.addColorStop(0, '#ffd700');
                        thunderGrad.addColorStop(0.5, '#ffff00');
                        thunderGrad.addColorStop(1, '#daa520');
                        ctx.fillStyle = thunderGrad;
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        // Lightning bolts on armor
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 2;
                        ctx.shadowColor = '#ffff00';
                        ctx.shadowBlur = 5;
                        for (let i = 0; i < 3; i++) {
                            ctx.beginPath();
                            ctx.moveTo(-this.width/2 + i * 12, -this.height/2);
                            ctx.lineTo(-this.width/2 + i * 12 + 5, -this.height/2 + 15);
                            ctx.lineTo(-this.width/2 + i * 12 + 2, -this.height/2 + 20);
                            ctx.lineTo(-this.width/2 + i * 12 + 7, this.height/2);
                            ctx.stroke();
                        }
                        ctx.shadowBlur = 0;
                        
                        // Thunder crown
                        ctx.fillStyle = '#ffffff';
                        for (let i = -2; i <= 2; i++) {
                            ctx.beginPath();
                            ctx.moveTo(i * 8, -this.height/2);
                            ctx.lineTo(i * 8 - 4, -this.height/2 - 12);
                            ctx.lineTo(i * 8, -this.height/2 - 18);
                            ctx.lineTo(i * 8 + 4, -this.height/2 - 12);
                            ctx.closePath();
                            ctx.fill();
                        }
                        
                        // Electric orbs
                        ctx.fillStyle = '#ffffff';
                        ctx.shadowColor = '#ffff00';
                        ctx.shadowBlur = 15;
                        for (let i = 0; i < 2; i++) {
                            const side = i === 0 ? -1 : 1;
                            const orbX = side * (this.width/2 + 12);
                            const orbY = wobble * side;
                            ctx.beginPath();
                            ctx.arc(orbX, orbY, 8, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        ctx.shadowBlur = 0;
                        
                        // Lightning particles
                        if (Math.random() < 0.4) {
                            particles.push(new Particle(
                                this.x + (Math.random() - 0.5) * this.width * 2,
                                this.y + (Math.random() - 0.5) * this.height * 2,
                                ['#ffff00', '#ffffff'][Math.floor(Math.random() * 2)],
                                (Math.random() - 0.5) * 4,
                                (Math.random() - 0.5) * 4,
                                20
                            ));
                        }
                        break;
                        
                    case 'Necromancer':
                        // Dark robes
                        const robeGrad = ctx.createLinearGradient(0, -this.height/2, 0, this.height/2);
                        robeGrad.addColorStop(0, '#2f0f4f');
                        robeGrad.addColorStop(0.5, '#4b0082');
                        robeGrad.addColorStop(1, '#1a0033');
                        ctx.fillStyle = robeGrad;
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        // Skull patterns
                        ctx.fillStyle = '#ffffff';
                        for (let i = 0; i < 3; i++) {
                            const y = -this.height/2 + 10 + i * 15;
                            // Mini skulls
                            ctx.fillRect(-5, y, 10, 8);
                            ctx.fillStyle = '#000000';
                            ctx.fillRect(-4, y + 1, 2, 2);
                            ctx.fillRect(2, y + 1, 2, 2);
                            ctx.fillStyle = '#ffffff';
                        }
                        
                        // Hood
                        ctx.fillStyle = '#0a0a0a';
                        ctx.beginPath();
                        ctx.arc(0, -this.height/2 + 10, 20, Math.PI, 0);
                        ctx.fill();
                        
                        // Skull face
                        ctx.fillStyle = '#f0f0f0';
                        ctx.fillRect(-10, -this.height/2 + 10, 20, 15);
                        ctx.fillStyle = '#000000';
                        ctx.fillRect(-8, -this.height/2 + 14, 4, 4);
                        ctx.fillRect(4, -this.height/2 + 14, 4, 4);
                        ctx.fillRect(-3, -this.height/2 + 20, 6, 3);
                        
                        // Staff with skull
                        ctx.strokeStyle = '#4b0082';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.moveTo(-this.width/2 - 10, this.height/2);
                        ctx.lineTo(-this.width/2 - 10, -this.height/2 - 10);
                        ctx.stroke();
                        
                        ctx.fillStyle = '#f0f0f0';
                        ctx.fillRect(-this.width/2 - 18, -this.height/2 - 20, 16, 14);
                        ctx.fillStyle = '#000000';
                        ctx.fillRect(-this.width/2 - 16, -this.height/2 - 17, 4, 4);
                        ctx.fillRect(-this.width/2 - 8, -this.height/2 - 17, 4, 4);
                        
                        // Soul particles
                        if (Math.random() < 0.3) {
                            particles.push(new Particle(
                                this.x + (Math.random() - 0.5) * this.width * 2,
                                this.y + (Math.random() - 0.5) * this.height * 2,
                                '#8b008b',
                                (Math.random() - 0.5) * 2,
                                -Math.random() * 3,
                                50
                            ));
                        }
                        break;
                        
                    case 'Blood Reaper':
                        // Crimson armor
                        const bloodGrad = ctx.createLinearGradient(0, -this.height/2, 0, this.height/2);
                        bloodGrad.addColorStop(0, '#8b0000');
                        bloodGrad.addColorStop(0.5, '#dc143c');
                        bloodGrad.addColorStop(1, '#4a0000');
                        ctx.fillStyle = bloodGrad;
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        // Blood drips
                        ctx.fillStyle = '#dc143c';
                        ctx.globalAlpha = 0.8;
                        for (let i = 0; i < 8; i++) {
                            const x = -this.width/2 + i * 6;
                            const dripLength = 4 + Math.sin(Date.now()/100 + i) * 3;
                            ctx.fillRect(x, this.height/2, 3, dripLength);
                        }
                        ctx.globalAlpha = 1;
                        
                        // Skull helmet
                        ctx.fillStyle = '#696969';
                        ctx.fillRect(-15, -this.height/2, 30, 25);
                        ctx.fillStyle = '#000000';
                        ctx.fillRect(-12, -this.height/2 + 8, 8, 8);
                        ctx.fillRect(4, -this.height/2 + 8, 8, 8);
                        for (let i = 0; i < 5; i++) {
                            ctx.fillRect(-10 + i * 4, -this.height/2 + 18, 3, 5);
                        }
                        
                        // Giant scythe
                        ctx.strokeStyle = '#2f2f2f';
                        ctx.lineWidth = 5;
                        ctx.beginPath();
                        ctx.moveTo(this.width/2, this.height/2);
                        ctx.lineTo(this.width/2, -this.height/2 - 15);
                        ctx.stroke();
                        
                        ctx.fillStyle = '#c0c0c0';
                        ctx.beginPath();
                        ctx.arc(this.width/2, -this.height/2 - 15, 15, Math.PI, 1.5 * Math.PI);
                        ctx.lineTo(this.width/2 + 20, -this.height/2 - 10);
                        ctx.arc(this.width/2, -this.height/2 - 15, 12, 1.5 * Math.PI, Math.PI);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Blood on scythe
                        ctx.fillStyle = '#dc143c';
                        ctx.fillRect(this.width/2 + 10, -this.height/2 - 18, 8, 4);
                        break;
                        
                    case 'Void Walker':
                        // Void body - constantly shifting
                        ctx.globalAlpha = 0.8;
                        const voidGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, this.width);
                        voidGrad.addColorStop(0, '#483d8b');
                        voidGrad.addColorStop(0.5, '#2f2f4f');
                        voidGrad.addColorStop(1, '#191970');
                        ctx.fillStyle = voidGrad;
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        ctx.globalAlpha = 1;
                        
                        // Void distortion effect
                        ctx.globalAlpha = 0.3;
                        for (let i = 0; i < 3; i++) {
                            const offset = Math.sin(Date.now()/100 + i) * 5;
                            ctx.fillStyle = i % 2 === 0 ? '#6a5acd' : '#4b0082';
                            ctx.fillRect(-this.width/2 + offset, -this.height/2, this.width, this.height);
                        }
                        ctx.globalAlpha = 1;
                        
                        // Cosmic eyes
                        ctx.fillStyle = '#ffffff';
                        ctx.shadowColor = '#9370db';
                        ctx.shadowBlur = 20;
                        ctx.beginPath();
                        ctx.arc(-8, -this.height/2 + 15, 6, 0, Math.PI * 2);
                        ctx.arc(8, -this.height/2 + 15, 6, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                        
                        // Void tendrils
                        ctx.strokeStyle = '#483d8b';
                        ctx.lineWidth = 3;
                        for (let i = 0; i < 4; i++) {
                            const angle = (Math.PI * 2 / 4) * i + Date.now() / 500;
                            const length = 20 + Math.sin(Date.now()/200 + i) * 5;
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.quadraticCurveTo(
                                Math.cos(angle) * 15,
                                Math.sin(angle) * 15,
                                Math.cos(angle) * length,
                                Math.sin(angle) * length
                            );
                            ctx.stroke();
                        }
                        
                        // Void particles
                        if (Math.random() < 0.4) {
                            particles.push(new Particle(
                                this.x + (Math.random() - 0.5) * this.width * 2,
                                this.y + (Math.random() - 0.5) * this.height * 2,
                                ['#483d8b', '#6a5acd', '#9370db'][Math.floor(Math.random() * 3)],
                                (Math.random() - 0.5) * 3,
                                (Math.random() - 0.5) * 3,
                                45
                            ));
                        }
                        break;
                        
                    default:
                        ctx.fillStyle = this.color;
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        break;
                }
                
                ctx.restore();
                
                // Epic Boss Health Bar
                const barWidth = this.width * 2;
                const barHeight = 12;
                const barY = this.y - this.height / 2 - 35;
                
                // Background shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.fillRect(this.x - barWidth / 2 - 2, barY - 2, barWidth + 4, barHeight + 4);
                
                // Bar border
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 3;
                ctx.strokeRect(this.x - barWidth / 2, barY, barWidth, barHeight);
                
                // Dark background
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(this.x - barWidth / 2, barY, barWidth, barHeight);
                
                // Health fill with gradient
                const healthPercent = this.health / this.maxHealth;
                const healthGrad = ctx.createLinearGradient(this.x - barWidth/2, 0, this.x + barWidth/2, 0);
                if (healthPercent > 0.5) {
                    healthGrad.addColorStop(0, '#ff0000');
                    healthGrad.addColorStop(1, '#ff4500');
                } else if (healthPercent > 0.25) {
                    healthGrad.addColorStop(0, '#ff8c00');
                    healthGrad.addColorStop(1, '#ffa500');
                } else {
                    healthGrad.addColorStop(0, '#ffd700');
                    healthGrad.addColorStop(1, '#ff0000');
                }
                ctx.fillStyle = healthGrad;
                ctx.fillRect(this.x - barWidth / 2, barY, barWidth * healthPercent, barHeight);
                
                // Health shine effect
                ctx.globalAlpha = 0.4;
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(this.x - barWidth / 2, barY + 2, barWidth * healthPercent, 3);
                ctx.globalAlpha = 1;
                
                // Boss name with shadow
                ctx.fillStyle = '#000000';
                ctx.font = 'bold 18px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText(this.type, this.x + 1, barY - 13);
                ctx.fillStyle = '#ffd700';
                ctx.shadowColor = '#ff8c00';
                ctx.shadowBlur = 8;
                ctx.fillText(this.type, this.x, barY - 14);
                ctx.shadowBlur = 0;
                
                // Health text
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 10px Courier New';
                ctx.fillText(Math.floor(this.health) + ' / ' + this.maxHealth, this.x, barY + 10);
            }

            takeDamage(damage) {
                this.health -= damage;
                this.health = Math.max(0, this.health);
                
                for (let i = 0; i < 20; i++) {
                    particles.push(new Particle(
                        this.x,
                        this.y,
                        this.color,
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 10,
                        35
                    ));
                }
            }
        }

        // Room class (keeping original castle look)
        class Room {
            constructor(seed, isBossRoom = false, isSafeRoom = false) {
                this.seed = seed;
                this.isBossRoom = isBossRoom;
                this.isSafeRoom = isSafeRoom;
                this.enemies = [];
                this.boss = null;
                this.platforms = [];
                this.cleared = false;
                
                // Seeded random
                function rand() {
                    seed = (seed * 9301 + 49297) % 233280;
                    return seed / 233280;
                }
                
                // Generate platforms
                const platformCount = 3 + Math.floor(rand() * 4);
                for (let i = 0; i < platformCount; i++) {
                    this.platforms.push({
                        x: 100 + rand() * (canvas.width - 300),
                        y: 200 + rand() * 300,
                        width: 100 + rand() * 150,
                        height: 15
                    });
                }
                
                // Safe spawn/exit platforms
                this.platforms.push({
                    x: 50,
                    y: canvas.height - 150,
                    width: 200,
                    height: 15
                });
                
                this.platforms.push({
                    x: canvas.width - 250,
                    y: canvas.height - 150,
                    width: 200,
                    height: 15
                });
                
                // Safe rooms have no enemies
                if (this.isSafeRoom) {
                    // Empty room - safe zone!
                } else if (this.isBossRoom) {
                    const bossTypes = [
                        'Crimson Knight', 'Shadow Lord', 'Frost Warden', 'Flame Tyrant',
                        'Stone Golem', 'Toxic Assassin', 'Thunder King', 'Necromancer',
                        'Blood Reaper', 'Void Walker', 'Crystal Sage', 'Iron Colossus',
                        'Phantom Assassin', 'Plague Doctor', 'Storm Herald'
                    ];
                    const bossType = bossTypes[Math.floor(rand() * bossTypes.length)];
                    this.boss = new Boss(canvas.width / 2, canvas.height - 200, bossType);
                } else {
                    let baseEnemyCount = 2 + Math.floor(rand() * 4);
                    
                    if (this.seed < 3 * 12345) {
                        baseEnemyCount = 1 + Math.floor(rand() * 2);
                    } else if (this.seed < 5 * 12345) {
                        baseEnemyCount = 2 + Math.floor(rand() * 2);
                    }
                    
                    const enemyCount = Math.min(baseEnemyCount, this.platforms.length);
                    const usedPlatforms = [];
                    const enemyTypes = ['basic', 'advanced', 'heavy', 'assassin', 'mage'];
                    
                    for (let i = 0; i < enemyCount; i++) {
                        let platformIndex;
                        let attempts = 0;
                        do {
                            platformIndex = Math.floor(rand() * this.platforms.length);
                            attempts++;
                        } while (usedPlatforms.includes(platformIndex) && attempts < 20);
                        
                        if (!usedPlatforms.includes(platformIndex)) {
                            usedPlatforms.push(platformIndex);
                            const platform = this.platforms[platformIndex];
                            
                            const typeRoll = rand();
                            let type;
                            
                            if (this.seed < 3 * 12345) {
                                if (typeRoll < 0.6) type = 'basic';
                                else if (typeRoll < 0.9) type = 'advanced';
                                else type = 'assassin';
                            } else if (this.seed < 5 * 12345) {
                                if (typeRoll < 0.35) type = 'basic';
                                else if (typeRoll < 0.6) type = 'advanced';
                                else if (typeRoll < 0.75) type = 'heavy';
                                else if (typeRoll < 0.9) type = 'assassin';
                                else type = 'mage';
                            } else {
                                if (typeRoll < 0.3) type = 'basic';
                                else if (typeRoll < 0.55) type = 'advanced';
                                else if (typeRoll < 0.7) type = 'heavy';
                                else if (typeRoll < 0.85) type = 'assassin';
                                else type = 'mage';
                            }
                            
                            this.enemies.push(new Enemy(
                                platform.x + platform.width / 2,
                                platform.y - 40,
                                type
                            ));
                        }
                    }
                }
            }

            draw() {
                // Background gradient (castle stone walls)
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                
                // Safe rooms have green tint
                if (this.isSafeRoom) {
                    gradient.addColorStop(0, '#2a4a2a');
                    gradient.addColorStop(1, '#1a2a1a');
                } else {
                    gradient.addColorStop(0, '#3a3a3a');
                    gradient.addColorStop(1, '#1a1a1a');
                }
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Safe room healing aura
                if (this.isSafeRoom) {
                    ctx.globalAlpha = 0.1 + Math.sin(Date.now() / 500) * 0.05;
                    const auraGrad = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, canvas.width/2);
                    auraGrad.addColorStop(0, '#00ff00');
                    auraGrad.addColorStop(1, 'rgba(0, 255, 0, 0)');
                    ctx.fillStyle = auraGrad;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.globalAlpha = 1;
                }
                
                // Stone wall texture
                for (let i = 0; i < 20; i++) {
                    for (let j = 0; j < 15; j++) {
                        const x = i * 60 + (j % 2) * 30;
                        const y = j * 50;
                        ctx.strokeStyle = this.isSafeRoom ? '#3a5a3a' : '#2a2a2a';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x, y, 60, 50);
                    }
                }
                
                // Torches (green for safe rooms)
                for (let i = 0; i < 5; i++) {
                    const x = 150 + i * 220;
                    const y = 80;
                    
                    const torchColor = this.isSafeRoom ? 'rgba(0, 255, 100, 0.15)' : 'rgba(255, 140, 0, 0.15)';
                    const torchGradient = ctx.createRadialGradient(x, y, 0, x, y, 60);
                    torchGradient.addColorStop(0, torchColor);
                    torchGradient.addColorStop(1, torchColor.replace('0.15', '0'));
                    ctx.fillStyle = torchGradient;
                    ctx.fillRect(x - 60, y - 60, 120, 120);
                    
                    ctx.fillStyle = this.isSafeRoom ? '#00ff64' : '#ff8c00';
                    ctx.globalAlpha = 0.8 + Math.sin(Date.now() / 100 + i) * 0.2;
                    ctx.beginPath();
                    ctx.ellipse(x, y, 6, 10 + Math.sin(Date.now() / 150 + i) * 3, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
                
                // Platforms
                for (const platform of this.platforms) {
                    ctx.fillStyle = 'rgba(0,0,0,0.4)';
                    ctx.fillRect(platform.x + 5, platform.y + 5, platform.width, platform.height);
                    
                    const platformGradient = ctx.createLinearGradient(0, platform.y, 0, platform.y + platform.height);
                    platformGradient.addColorStop(0, '#5a5a5a');
                    platformGradient.addColorStop(1, '#3a3a3a');
                    ctx.fillStyle = platformGradient;
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                    
                    ctx.fillStyle = '#6a6a6a';
                    ctx.fillRect(platform.x, platform.y, platform.width, 3);
                    
                    ctx.strokeStyle = '#2a2a2a';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < 3; i++) {
                        const crackX = platform.x + (platform.width / 4) * (i + 0.5);
                        ctx.beginPath();
                        ctx.moveTo(crackX, platform.y);
                        ctx.lineTo(crackX + 5, platform.y + platform.height);
                        ctx.stroke();
                    }
                }
                
                // Ground
                ctx.fillStyle = '#2a2a2a';
                ctx.fillRect(0, canvas.height - 50, canvas.width, 50);
                
                ctx.strokeStyle = '#1a1a1a';
                ctx.lineWidth = 2;
                for (let i = 0; i < canvas.width / 60; i++) {
                    ctx.strokeRect(i * 60, canvas.height - 50, 60, 50);
                }
                
                ctx.fillStyle = '#4a4a4a';
                ctx.fillRect(0, canvas.height - 50, canvas.width, 3);
                
                // Door
                if (this.enemies.length === 0 && !this.cleared) {
                    this.cleared = true;
                }
                
                if (this.cleared || this.enemies.length === 0) {
                    const doorX = canvas.width - 60;
                    const doorY = canvas.height - 180;
                    
                    ctx.fillStyle = '#4a4a4a';
                    ctx.fillRect(doorX, doorY, 50, 130);
                    
                    ctx.beginPath();
                    ctx.arc(doorX + 25, doorY + 130, 25, Math.PI, 0);
                    ctx.fill();
                    
                    ctx.fillStyle = '#0a0a0a';
                    ctx.fillRect(doorX + 5, doorY + 20, 40, 110);
                    
                    const doorGradient = ctx.createRadialGradient(doorX + 25, doorY + 75, 0, doorX + 25, doorY + 75, 50);
                    doorGradient.addColorStop(0, 'rgba(255, 215, 0, 0.4)');
                    doorGradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                    ctx.fillStyle = doorGradient;
                    ctx.fillRect(doorX - 20, doorY, 90, 130);
                    
                    ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 300) * 0.3;
                    ctx.fillStyle = '#ffd700';
                    ctx.fillRect(doorX + 5, doorY + 20, 40, 110);
                    ctx.globalAlpha = 1;
                    
                    ctx.strokeStyle = '#6a6a6a';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(doorX, doorY, 50, 130);
                    
                    ctx.fillStyle = '#ffd700';
                    ctx.font = '20px Courier New';
                    ctx.textAlign = 'center';
                    ctx.globalAlpha = 0.7 + Math.sin(Date.now() / 300) * 0.3;
                    ctx.fillText('→', doorX + 25, doorY - 10);
                    ctx.globalAlpha = 1;
                }
                
                // Safe room indicator text
                if (this.isSafeRoom) {
                    ctx.fillStyle = '#00ff00';
                    ctx.font = 'bold 36px Courier New';
                    ctx.textAlign = 'center';
                    ctx.shadowColor = 'rgba(0, 255, 0, 0.8)';
                    ctx.shadowBlur = 15;
                    ctx.globalAlpha = 0.8 + Math.sin(Date.now() / 500) * 0.2;
                    ctx.fillText('🛡️ SAFE ROOM 🛡️', canvas.width / 2, 100);
                    ctx.font = '20px Courier New';
                    ctx.fillText('Checkpoint Saved', canvas.width / 2, 140);
                    ctx.globalAlpha = 1;
                    ctx.shadowBlur = 0;
                }
            }
        }

        // MASSIVE Upgrade system with 45+ upgrades including mythics
        const upgradeDefinitions = {
            // COMMON (Basic improvements)
            maxHealth: { name: 'Vitality', desc: 'Increase max health', rarity: 'common', maxLevel: 10, type: 'passive' },
            damage: { name: 'Power', desc: 'Increase base damage', rarity: 'common', maxLevel: 10, type: 'passive' },
            attackSpeed: { name: 'Swiftness', desc: 'Attack faster', rarity: 'common', maxLevel: 8, type: 'passive' },
            speed: { name: 'Agility', desc: 'Move faster', rarity: 'common', maxLevel: 6, type: 'passive' },
            lifesteal: { name: 'Blood Hunger', desc: 'Steal health on hit', rarity: 'common', maxLevel: 5, type: 'passive' },
            thorns: { name: 'Thorns', desc: 'Reflect damage', rarity: 'common', maxLevel: 5, type: 'passive' },
            
            // UNCOMMON (Enhanced abilities)
            multishot: { name: 'Multishot', desc: 'Fire multiple knives', rarity: 'uncommon', maxLevel: 4, type: 'passive' },
            rapidFire: { name: 'Rapid Fire', desc: 'Throw knives faster', rarity: 'uncommon', maxLevel: 5, type: 'passive' },
            critChance: { name: 'Precision', desc: 'Increase crit chance', rarity: 'uncommon', maxLevel: 8, type: 'passive' },
            critDamage: { name: 'Execution', desc: 'Increase crit damage', rarity: 'uncommon', maxLevel: 6, type: 'passive' },
            dashAttack: { name: 'Dash Attack', desc: 'Damage while dashing', rarity: 'uncommon', maxLevel: 3, type: 'passive' },
            vampiricAura: { name: 'Vampiric Aura', desc: 'Drain nearby enemies', rarity: 'uncommon', maxLevel: 4, type: 'passive' },
            ironSkin: { name: 'Iron Skin', desc: 'Reduce damage taken', rarity: 'uncommon', maxLevel: 5, type: 'passive' },
            swiftness: { name: 'Enhanced Swiftness', desc: 'Greatly increase speed', rarity: 'uncommon', maxLevel: 4, type: 'passive' },
            
            // RARE (Special effects)
            poisonDagger: { name: 'Poison Blade', desc: 'Poison enemies (DoT)', rarity: 'rare', maxLevel: 4, type: 'passive' },
            frozenTouch: { name: 'Frozen Touch', desc: 'Slow enemies on hit', rarity: 'rare', maxLevel: 4, type: 'passive' },
            explosiveKnives: { name: 'Explosive Knives', desc: 'Knives explode', rarity: 'rare', maxLevel: 3, type: 'passive' },
            chainLightning: { name: 'Chain Lightning', desc: 'Lightning chains', rarity: 'rare', maxLevel: 3, type: 'passive' },
            piercing: { name: 'Piercing Shot', desc: 'Shots pierce', rarity: 'rare', maxLevel: 1, type: 'passive' },
            doubleJump: { name: 'Double Jump', desc: 'Jump in mid-air', rarity: 'rare', maxLevel: 1, type: 'passive' },
            ghostWalk: { name: 'Ghost Walk', desc: 'Phase through attacks', rarity: 'rare', maxLevel: 3, type: 'passive' },
            bloodRage: { name: 'Blood Rage', desc: 'Gain speed on kill', rarity: 'rare', maxLevel: 4, type: 'passive' },
            executeThreshold: { name: 'Execute', desc: 'Instant kill low HP enemies', rarity: 'rare', maxLevel: 3, type: 'passive' },
            ricochet: { name: 'Ricochet', desc: 'Knives bounce', rarity: 'rare', maxLevel: 3, type: 'passive' },
            magneticKnives: { name: 'Magnetic Knives', desc: 'Knives seek enemies', rarity: 'rare', maxLevel: 2, type: 'passive' },
            
            // NEW RARE UPGRADES
            deathMark: { name: 'Death Mark', desc: 'Mark enemies for extra damage', rarity: 'rare', maxLevel: 4, type: 'passive' },
            voidWalk: { name: 'Void Walk', desc: 'Dash through enemies dealing damage', rarity: 'rare', maxLevel: 3, type: 'passive' },
            soulHarvest: { name: 'Soul Harvest', desc: 'Restore health on kill', rarity: 'rare', maxLevel: 5, type: 'passive' },
            reflection: { name: 'Reflection', desc: 'Deal damage back when hit', rarity: 'rare', maxLevel: 4, type: 'passive' },
            arcaneShield: { name: 'Arcane Shield', desc: 'Projectiles may miss', rarity: 'rare', maxLevel: 3, type: 'passive' },
            regeneration: { name: 'Regeneration', desc: 'Slowly restore health', rarity: 'rare', maxLevel: 6, type: 'passive' },
            evasion: { name: 'Evasion', desc: 'Chance to dodge attacks', rarity: 'rare', maxLevel: 4, type: 'passive' },
            bloodShield: { name: 'Blood Shield', desc: 'Chance to block 50% damage', rarity: 'rare', maxLevel: 4, type: 'passive' },
            
            // NEW COMMON UPGRADES
            resilience: { name: 'Resilience', desc: '+10 max health per level', rarity: 'common', maxLevel: 8, type: 'passive' },
            sharpening: { name: 'Sharpening', desc: '+5% damage per level', rarity: 'common', maxLevel: 10, type: 'passive' },
            conditioning: { name: 'Conditioning', desc: 'Reduce cooldowns', rarity: 'common', maxLevel: 6, type: 'passive' },
            fortify: { name: 'Fortify', desc: 'Increase defense', rarity: 'common', maxLevel: 7, type: 'passive' },
            haste: { name: 'Haste', desc: 'Move and attack faster', rarity: 'common', maxLevel: 5, type: 'passive' },
            
            // NEW UNCOMMON UPGRADES
            shadowStep: { name: 'Shadow Step', desc: 'Short dash leaves afterimage', rarity: 'uncommon', maxLevel: 4, type: 'passive' },
            venomous: { name: 'Venomous', desc: 'Attacks inflict poison', rarity: 'uncommon', maxLevel: 5, type: 'passive' },
            momentum: { name: 'Momentum', desc: 'Moving increases damage', rarity: 'uncommon', maxLevel: 4, type: 'passive' },
            backstab: { name: 'Backstab', desc: 'Bonus damage from behind', rarity: 'uncommon', maxLevel: 5, type: 'passive' },
            adrenaline: { name: 'Adrenaline', desc: 'Gain speed on low HP', rarity: 'uncommon', maxLevel: 4, type: 'passive' },
            predator: { name: 'Predator', desc: 'Track wounded enemies', rarity: 'uncommon', maxLevel: 3, type: 'passive' },
            reaper: { name: 'Reaper', desc: 'Heal when enemy dies', rarity: 'uncommon', maxLevel: 5, type: 'passive' },
            quickdraw: { name: 'Quickdraw', desc: 'First attack is instant', rarity: 'uncommon', maxLevel: 3, type: 'passive' },
            
            // MORE RARE UPGRADES
            bladestorm: { name: 'Bladestorm', desc: 'Knives spin around you', rarity: 'rare', maxLevel: 4, type: 'passive' },
            frostbite: { name: 'Frostbite', desc: 'Freeze enemies on crit', rarity: 'rare', maxLevel: 3, type: 'passive' },
            firebreath: { name: 'Fire Breath', desc: 'Dash shoots flames', rarity: 'rare', maxLevel: 3, type: 'passive' },
            shockwave: { name: 'Shockwave', desc: 'Attacks create shockwaves', rarity: 'rare', maxLevel: 4, type: 'passive' },
            blink: { name: 'Blink', desc: 'Teleport on dash', rarity: 'rare', maxLevel: 2, type: 'passive' },
            overcharge: { name: 'Overcharge', desc: 'Every 5th attack is empowered', rarity: 'rare', maxLevel: 3, type: 'passive' },
            lastStand: { name: 'Last Stand', desc: 'Survive fatal blow once per room', rarity: 'rare', maxLevel: 1, type: 'passive' },
            spiritGuard: { name: 'Spirit Guard', desc: 'Spectral shields orbit you', rarity: 'rare', maxLevel: 3, type: 'passive' },
            
            // EPIC (Powerful abilities)
            multiStrike: { name: 'Multi-Strike', desc: 'Attack multiple times', rarity: 'epic', maxLevel: 3, type: 'passive' },
            bladeDance: { name: 'Blade Dance', desc: 'Move while attacking', rarity: 'epic', maxLevel: 3, type: 'passive' },
            berserkerRage: { name: 'Berserker Rage', desc: 'More damage at low health', rarity: 'epic', maxLevel: 4, type: 'passive' },
            assassination: { name: 'Assassination', desc: 'Massive first hit damage', rarity: 'epic', maxLevel: 3, type: 'passive' },
            execution: { name: 'Executioner', desc: 'Instantly kill low HP', rarity: 'epic', maxLevel: 3, type: 'passive' },
            rage: { name: 'Rage', desc: 'Gain damage on kills', rarity: 'epic', maxLevel: 5, type: 'passive' },
            berserk: { name: 'Berserk', desc: 'High risk high reward', rarity: 'epic', maxLevel: 3, type: 'passive' },
            whirlwind: { name: 'Whirlwind', desc: 'Spin projectiles around you', rarity: 'epic', maxLevel: 3, type: 'passive' },
            criticalMass: { name: 'Critical Mass', desc: 'Crits create explosions', rarity: 'epic', maxLevel: 3, type: 'passive' },
            shadowBurst: { name: 'Shadow Burst', desc: 'Attacks may burst outward', rarity: 'epic', maxLevel: 3, type: 'passive' },
            timeWarp: { name: 'Time Warp', desc: 'Special: Slow all enemies', rarity: 'epic', maxLevel: 3, type: 'special' },
            
            // NEW EPIC UPGRADES
            immortal: { name: 'Immortal', desc: 'Cannot drop below 1 HP for 3s', rarity: 'epic', maxLevel: 2, type: 'passive' },
            juggernaut: { name: 'Juggernaut', desc: 'Unstoppable when dashing', rarity: 'epic', maxLevel: 3, type: 'passive' },
            deadeye: { name: 'Deadeye', desc: '100% crit on first hit', rarity: 'epic', maxLevel: 2, type: 'passive' },
            bladeMaster: { name: 'Blade Master', desc: 'Every 3rd attack hits twice', rarity: 'epic', maxLevel: 4, type: 'passive' },
            voidRift: { name: 'Void Rift', desc: 'Attacks create void portals', rarity: 'epic', maxLevel: 3, type: 'passive' },
            phoenixRising: { name: 'Phoenix Rising', desc: 'Revive once per room', rarity: 'epic', maxLevel: 1, type: 'passive' },
            chaosTheory: { name: 'Chaos Theory', desc: 'Random powerful effects', rarity: 'epic', maxLevel: 4, type: 'passive' },
            massacreMode: { name: 'Massacre Mode', desc: '5 kills = massive buffs', rarity: 'epic', maxLevel: 3, type: 'passive' },
            
            // LEGENDARY (Active abilities)
            shadowClone: { name: 'Shadow Clone', desc: 'Summon fighting clone', rarity: 'legendary', type: 'special', cooldown: 300 },
            fireStorm: { name: 'Fire Storm', desc: 'Rain fire from above', rarity: 'legendary', type: 'special', cooldown: 300 },
            timeStop: { name: 'Time Stop', desc: 'Freeze all enemies', rarity: 'legendary', type: 'special', cooldown: 300 },
            phantomStrike: { name: 'Phantom Strike', desc: 'Teleport to enemy', rarity: 'legendary', type: 'special', cooldown: 300 },
            teleportStrike: { name: 'Teleport Strike', desc: 'Teleport and strike', rarity: 'legendary', type: 'special', cooldown: 300 },
            deathWave: { name: 'Death Wave', desc: 'Send waves of death', rarity: 'legendary', type: 'special', cooldown: 300 },
            meteorStrike: { name: 'Meteor Strike', desc: 'Rain meteors', rarity: 'legendary', type: 'special', cooldown: 300 },
            
            // NEW LEGENDARY ABILITIES
            blackHole: { name: 'Black Hole', desc: 'Pulls all enemies to center', rarity: 'legendary', type: 'special', cooldown: 300 },
            dragonBreath: { name: 'Dragon Breath', desc: 'Massive fire cone', rarity: 'legendary', type: 'special', cooldown: 300 },
            voidShift: { name: 'Void Shift', desc: 'Become invincible shadow', rarity: 'legendary', type: 'special', cooldown: 300 },
            obliterate: { name: 'Obliterate', desc: 'Delete target from existence', rarity: 'legendary', type: 'special', cooldown: 300 },
            chainReaction: { name: 'Chain Reaction', desc: 'Kill one, explode all', rarity: 'legendary', type: 'special', cooldown: 300 },
            soulCollector: { name: 'Soul Collector', desc: 'Drain all enemy life', rarity: 'legendary', type: 'special', cooldown: 300 },
            
            // MYTHIC (Game-changing abilities) - OVERPOWERED!
            godMode: { name: '⚡ GOD MODE ⚡', desc: 'Invincible + 10x damage for 5s', rarity: 'mythic', type: 'special', cooldown: 300 },
            omniSlash: { name: '⚡ OMNI SLASH ⚡', desc: 'Dash through all enemies', rarity: 'mythic', type: 'special', cooldown: 300 },
            armageddon: { name: '⚡ ARMAGEDDON ⚡', desc: 'Meteor apocalypse', rarity: 'mythic', type: 'special', cooldown: 300 },
            infinityEdge: { name: '⚡ INFINITY EDGE ⚡', desc: 'Summon 20 homing blades', rarity: 'mythic', type: 'special', cooldown: 300 },
            divineShield: { name: '⚡ DIVINE SHIELD ⚡', desc: 'Invulnerable for 4s', rarity: 'mythic', type: 'special', cooldown: 300 },
            stormCaller: { name: '⚡ STORM CALLER ⚡', desc: 'Lightning strikes all', rarity: 'mythic', type: 'special', cooldown: 300 },
            timestrike: { name: '⚡ TIME STRIKE ⚡', desc: 'Stop time for 5s', rarity: 'mythic', type: 'special', cooldown: 300 },
            soulReaper: { name: '⚡ SOUL REAPER ⚡', desc: 'Instantly kill all normal enemies', rarity: 'mythic', type: 'special', cooldown: 300 },
            ragnarok: { name: '⚡ RAGNAROK ⚡', desc: 'Screen-wide explosion', rarity: 'mythic', type: 'special', cooldown: 300 },
            
            // NEW MYTHIC ABILITIES
            apocalypse: { name: '⚡ APOCALYPSE ⚡', desc: 'Summon the end times', rarity: 'mythic', type: 'special', cooldown: 300 },
            universeRewrite: { name: '⚡ UNIVERSE REWRITE ⚡', desc: 'Reset boss to 1 HP', rarity: 'mythic', type: 'special', cooldown: 300 },
            omnipotence: { name: '⚡ OMNIPOTENCE ⚡', desc: 'Become unkillable for 10s', rarity: 'mythic', type: 'special', cooldown: 300 },
            galaxyCollapse: { name: '⚡ GALAXY COLLAPSE ⚡', desc: 'Pull everything to death', rarity: 'mythic', type: 'special', cooldown: 300 },
            voidAnnihilation: { name: '⚡ VOID ANNIHILATION ⚡', desc: 'Erase all enemies', rarity: 'mythic', type: 'special', cooldown: 300 },
            
            // EVEN MORE MYTHIC ABILITIES
            dimensionRift: { name: '⚡ DIMENSION RIFT ⚡', desc: 'Banish all to the void', rarity: 'mythic', type: 'special', cooldown: 300 },
            deathStar: { name: '⚡ DEATH STAR ⚡', desc: 'Orbital laser annihilation', rarity: 'mythic', type: 'special', cooldown: 300 },
            bigBang: { name: '⚡ BIG BANG ⚡', desc: 'Universe-ending explosion', rarity: 'mythic', type: 'special', cooldown: 300 },
            infinityGauntlet: { name: '⚡ INFINITY GAUNTLET ⚡', desc: 'Snap away half of all enemies', rarity: 'mythic', type: 'special', cooldown: 300 },
            judgmentDay: { name: '⚡ JUDGMENT DAY ⚡', desc: 'Divine judgment on all foes', rarity: 'mythic', type: 'special', cooldown: 300 },
            cosmicPower: { name: '⚡ COSMIC POWER ⚡', desc: 'Become one with the universe', rarity: 'mythic', type: 'special', cooldown: 300 },
            realityBend: { name: '⚡ REALITY BEND ⚡', desc: 'Rewrite the laws of physics', rarity: 'mythic', type: 'special', cooldown: 300 },
            superNova: { name: '⚡ SUPERNOVA ⚡', desc: 'Explode like a dying star', rarity: 'mythic', type: 'special', cooldown: 300 },
            timeLord: { name: '⚡ TIME LORD ⚡', desc: 'Control time itself', rarity: 'mythic', type: 'special', cooldown: 300 },
            godSlayer: { name: '⚡ GOD SLAYER ⚡', desc: 'Deal 9999 damage to boss', rarity: 'mythic', type: 'special', cooldown: 300 }
        };

        function getRandomUpgrades(count = 3) {
            const available = [];
            
            // If mythic mode, ONLY show mythic upgrades!
            if (mythicMode) {
                for (const [key, upgrade] of Object.entries(upgradeDefinitions)) {
                    if (upgrade.rarity === 'mythic') {
                        const currentLevel = player.upgrades[key] || 0;
                        if (!upgrade.maxLevel || currentLevel < upgrade.maxLevel) {
                            available.push(key);
                        }
                    }
                }
            } else {
                // Normal mode - mythics now have a small chance!
                const rarityWeights = {
                    common: 35,
                    uncommon: 25,
                    rare: 18,
                    epic: 12,
                    legendary: 7,
                    mythic: 3  // NEW: Mythics can drop in normal mode!
                };
                
                for (const [key, upgrade] of Object.entries(upgradeDefinitions)) {
                    const currentLevel = player.upgrades[key] || 0;
                    if (!upgrade.maxLevel || currentLevel < upgrade.maxLevel) {
                        const weight = rarityWeights[upgrade.rarity] || 1;
                        for (let i = 0; i < weight; i++) {
                            available.push(key);
                        }
                    }
                }
            }
            
            if (available.length === 0) return [];
            
            // Shuffle
            for (let i = available.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [available[i], available[j]] = [available[j], available[i]];
            }
            
            // Get unique upgrades
            const selected = [];
            const seen = new Set();
            for (const key of available) {
                if (!seen.has(key)) {
                    selected.push(key);
                    seen.add(key);
                }
                if (selected.length >= count) break;
            }
            
            return selected;
        }

        function showUpgradeScreen() {
            const upgradeScreen = document.getElementById('upgradeScreen');
            const upgradeOptions = document.getElementById('upgradeOptions');
            
            upgradeOptions.innerHTML = '';
            const selectedUpgrades = getRandomUpgrades(3);
            
            selectedUpgrades.forEach(upgradeKey => {
                const upgrade = upgradeDefinitions[upgradeKey];
                const currentLevel = player.upgrades[upgradeKey] || 0;
                
                const card = document.createElement('div');
                card.className = 'upgrade-card';
                if (upgrade.rarity === 'mythic') {
                    card.classList.add('mythic');
                }
                
                let levelText = '';
                if (upgrade.maxLevel) {
                    levelText = `<div class="level">Level ${currentLevel} → ${currentLevel + 1}</div>`;
                }
                
                card.innerHTML = `
                    <h3>${upgrade.name}</h3>
                    ${levelText}
                    <p>${upgrade.desc}</p>
                    <p style="color: ${
                        upgrade.rarity === 'mythic' ? '#ff00ff' :
                        upgrade.rarity === 'legendary' ? '#ff8c00' :
                        upgrade.rarity === 'epic' ? '#9400d3' :
                        upgrade.rarity === 'rare' ? '#4169e1' :
                        upgrade.rarity === 'uncommon' ? '#228b22' : '#808080'
                    }; font-size: 12px; margin-top: 8px;">${upgrade.rarity.toUpperCase()}</p>
                `;
                
                card.addEventListener('click', () => {
                    applyUpgrade(upgradeKey);
                    upgradeScreen.style.display = 'none';
                    showingUpgrade = false;
                    
                    // Upgrade particles
                    for (let i = 0; i < 50; i++) {
                        particles.push(new Particle(
                            player.x,
                            player.y,
                            upgrade.rarity === 'mythic' ? '#ff00ff' : '#ffd700',
                            (Math.random() - 0.5) * 12,
                            (Math.random() - 0.5) * 12,
                            40
                        ));
                    }
                });
                
                upgradeOptions.appendChild(card);
            });
            
            upgradeScreen.style.display = 'flex';
        }

        function applyUpgrade(upgradeKey) {
            const upgrade = upgradeDefinitions[upgradeKey];
            
            if (upgrade.maxLevel) {
                player.upgrades[upgradeKey] = (player.upgrades[upgradeKey] || 0) + 1;
            } else {
                player.upgrades[upgradeKey] = 1;
            }
            
            // Apply upgrade effects
            switch(upgradeKey) {
                case 'maxHealth':
                    player.maxHealth = 150 + player.upgrades.maxHealth * 25;
                    player.health = Math.min(player.health + 25, player.maxHealth);
                    break;
                case 'damage':
                    // Handled in takeDamage calculation
                    break;
                case 'speed':
                case 'swiftness':
                    player.speed = 5 + (player.upgrades.speed + player.upgrades.swiftness) * 0.8;
                    break;
                case 'doubleJump':
                    player.hasDoubleJump = true;
                    break;
            }
            
            // Special ability assignment - NOW SUPPORTS 6 SLOTS!
            if (upgrade.type === 'special') {
                if (!player.special1) {
                    player.special1 = upgradeKey;
                } else if (!player.special2) {
                    player.special2 = upgradeKey;
                } else if (!player.special3) {
                    player.special3 = upgradeKey;
                } else if (!player.special4) {
                    player.special4 = upgradeKey;
                } else if (!player.special5) {
                    player.special5 = upgradeKey;
                } else if (!player.special6) {
                    player.special6 = upgradeKey;
                } else {
                    // All 6 slots full - replace oldest (special1)
                    player.special1 = upgradeKey;
                }
                updateSpecialAbilitiesUI();
            }
        }
        
        function updateSpecialAbilitiesUI() {
            const listElement = document.getElementById('specialAbilitiesList');
            listElement.innerHTML = '';
            
            const specialSlots = [
                { key: 'Q', ability: player.special1, cooldown: player.special1Cooldown },
                { key: 'E', ability: player.special2, cooldown: player.special2Cooldown },
                { key: 'R', ability: player.special3, cooldown: player.special3Cooldown },
                { key: 'F', ability: player.special4, cooldown: player.special4Cooldown },
                { key: 'C', ability: player.special5, cooldown: player.special5Cooldown },
                { key: 'V', ability: player.special6, cooldown: player.special6Cooldown }
            ];
            
            let hasAny = false;
            for (const slot of specialSlots) {
                if (slot.ability) {
                    hasAny = true;
                    const abilityDef = upgradeDefinitions[slot.ability];
                    const ready = slot.cooldown <= 0;
                    
                    const div = document.createElement('div');
                    div.style.marginBottom = '5px';
                    div.style.color = ready ? '#00ff00' : '#ff6666';
                    div.innerHTML = `[${slot.key}] ${abilityDef.name}${ready ? ' ✓' : ' (' + Math.ceil(slot.cooldown/60) + 's)'}`;
                    listElement.appendChild(div);
                }
            }
            
            if (!hasAny) {
                listElement.innerHTML = '<div style="color: #888;">None equipped</div>';
            }
            
            // Update keybinds display
            updateKeybindsDisplay();
        }
        
        function updateKeybindsDisplay() {
            const additionalKeybinds = document.getElementById('additionalKeybinds');
            additionalKeybinds.innerHTML = '';
            
            // ALL 6 SPECIAL ABILITY SLOTS!
            const specialSlots = [
                { key: 'Q', ability: player.special1, def: upgradeDefinitions[player.special1] },
                { key: 'E', ability: player.special2, def: upgradeDefinitions[player.special2] },
                { key: 'R', ability: player.special3, def: upgradeDefinitions[player.special3] },
                { key: 'F', ability: player.special4, def: upgradeDefinitions[player.special4] },
                { key: 'C', ability: player.special5, def: upgradeDefinitions[player.special5] },
                { key: 'V', ability: player.special6, def: upgradeDefinitions[player.special6] }
            ];
            
            for (const slot of specialSlots) {
                if (slot.ability && slot.def) {
                    const div = document.createElement('div');
                    div.className = 'keybind-item';
                    div.innerHTML = `
                        <span class="keybind-key">[${slot.key}]</span>
                        <span class="keybind-ability">${slot.def.name}</span>
                    `;
                    additionalKeybinds.appendChild(div);
                }
            }
        }
        
        function initializeMythicPanel() {
            const panel = document.getElementById('mythicAbilityList');
            panel.innerHTML = '';
            
            // Group abilities by rarity
            const rarityOrder = ['mythic', 'legendary', 'epic', 'rare', 'uncommon', 'common'];
            const rarityColors = {
                'mythic': '#ff00ff',
                'legendary': '#ffd700',
                'epic': '#a020f0',
                'rare': '#0080ff',
                'uncommon': '#00ff00',
                'common': '#ffffff'
            };
            
            for (const rarity of rarityOrder) {
                // Get all abilities of this rarity
                const abilitiesOfRarity = Object.entries(upgradeDefinitions)
                    .filter(([key, upgrade]) => upgrade.rarity === rarity);
                
                if (abilitiesOfRarity.length === 0) continue;
                
                // Add rarity header
                const headerDiv = document.createElement('div');
                headerDiv.className = 'rarity-header';
                headerDiv.dataset.rarity = rarity;
                headerDiv.style.cssText = `
                    margin-top: 15px;
                    padding: 8px;
                    background: linear-gradient(135deg, ${rarityColors[rarity]}33, ${rarityColors[rarity]}11);
                    border-left: 4px solid ${rarityColors[rarity]};
                    font-size: 14px;
                    font-weight: bold;
                    color: ${rarityColors[rarity]};
                    text-transform: uppercase;
                    letter-spacing: 1px;
                    text-shadow: 0 0 10px ${rarityColors[rarity]};
                `;
                headerDiv.textContent = `${rarity} (${abilitiesOfRarity.length})`;
                panel.appendChild(headerDiv);
                
                // Add all abilities of this rarity
                for (const [key, upgrade] of abilitiesOfRarity) {
                    const abilityDiv = document.createElement('div');
                    abilityDiv.className = 'mythic-ability';
                    abilityDiv.dataset.ability = key;
                    abilityDiv.dataset.rarity = rarity;
                    abilityDiv.dataset.name = upgrade.name.toLowerCase();
                    abilityDiv.style.borderLeft = `3px solid ${rarityColors[rarity]}`;
                    
                    abilityDiv.innerHTML = `
                        <span class="mythic-ability-name" style="color: ${rarityColors[rarity]};">
                            ${upgrade.name}
                            ${upgrade.type === 'special' ? ' ⚡' : ''}
                        </span>
                        <div class="mythic-ability-toggle"></div>
                    `;
                    
                    abilityDiv.addEventListener('click', () => {
                        toggleMythicAbility(key, abilityDiv);
                    });
                    
                    panel.appendChild(abilityDiv);
                }
            }
            
            // Add search functionality
            const searchBox = document.getElementById('abilitySearch');
            searchBox.addEventListener('input', (e) => {
                const searchTerm = e.target.value.toLowerCase();
                const abilities = panel.querySelectorAll('.mythic-ability');
                const headers = panel.querySelectorAll('.rarity-header');
                
                abilities.forEach(ability => {
                    const abilityName = ability.dataset.name;
                    if (abilityName.includes(searchTerm)) {
                        ability.style.display = 'flex';
                    } else {
                        ability.style.display = 'none';
                    }
                });
                
                // Hide/show headers based on visible abilities
                headers.forEach(header => {
                    const rarity = header.dataset.rarity;
                    const visibleInRarity = Array.from(abilities).some(
                        a => a.dataset.rarity === rarity && a.style.display !== 'none'
                    );
                    header.style.display = visibleInRarity ? 'block' : 'none';
                });
            });
        }
        
        function toggleMythicAbility(abilityKey, element) {
            const upgrade = upgradeDefinitions[abilityKey];
            
            if (element.classList.contains('active')) {
                // Deactivate
                element.classList.remove('active');
                
                if (upgrade.type === 'special') {
                    // Remove from special slots
                    if (player.special1 === abilityKey) player.special1 = null;
                    if (player.special2 === abilityKey) player.special2 = null;
                } else {
                    // Remove upgrade
                    player.upgrades[abilityKey] = 0;
                }
            } else {
                // Activate
                element.classList.add('active');
                
                if (upgrade.type === 'special') {
                    // Add to special slot
                    if (!player.special1) {
                        player.special1 = abilityKey;
                    } else if (!player.special2) {
                        player.special2 = abilityKey;
                    } else {
                        player.special1 = abilityKey; // Replace special1
                    }
                } else {
                    // Max out upgrade
                    player.upgrades[abilityKey] = upgrade.maxLevel || 10;
                }
                
                // Apply special effects
                applyUpgrade(abilityKey);
            }
            
            // Update UI
            updateSpecialAbilitiesUI();
        }
        
        // Mythic panel toggle button
        document.getElementById('mythicToggleBtn').addEventListener('click', () => {
            const panel = document.getElementById('mythicPanel');
            if (panel.style.display === 'none' || panel.style.display === '') {
                panel.style.display = 'block';
            } else {
                panel.style.display = 'none';
            }
        });

        // Game state
        let player = new Player(100, 300);
        let currentRoom = new Room(1);
        let roomNumber = 1;
        let particles = [];
        let projectiles = [];
        let shadowClones = [];
        let gameStarted = false;
        let showingUpgrade = false;
        let gameOver = false;
        
        // SECRET CHEAT CODE SYSTEM
        let cheatCode = '';
        let mythicMode = false;
        
        // Input
        const keys = {};
        const mouse = { x: 0, y: 0 };
        
        // Event listeners
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            
            // CHEAT CODE DETECTION
            cheatCode += e.key.toLowerCase();
            if (cheatCode.length > 20) cheatCode = cheatCode.slice(-20);
            
            if (cheatCode.includes('goldengod')) {
                if (!mythicMode) {
                    mythicMode = true;
                    cheatCode = '';
                    
                    // GOLDEN GOD MODE ACTIVATION!
                    for (let i = 0; i < 300; i++) {
                        particles.push(new Particle(
                            Math.random() * canvas.width,
                            Math.random() * canvas.height,
                            ['#ffd700', '#ffaa00', '#ffed4e'][Math.floor(Math.random() * 3)],
                            (Math.random() - 0.5) * 25,
                            (Math.random() - 0.5) * 25,
                            80
                        ));
                    }
                    
                    // Show mythic toggle button
                    document.getElementById('mythicToggleBtn').style.display = 'block';
                    
                    // Initialize mythic panel
                    initializeMythicPanel();
                    
                    console.log('⚡ GOD MODE ACTIVATED - ALL ABILITIES UNLOCKED! ⚡');
                }
            }
            
            if (!gameStarted) {
                return;
            }
            
            // Jump
            if (e.key === ' ' || e.key === 'w' || e.key.toLowerCase() === 'arrowup') {
                if (player.onGround) {
                    player.vy = -player.jumpPower;
                } else if (player.upgrades.doubleJump && !player.hasDoubleJumped) {
                    player.vy = -player.jumpPower;
                    player.hasDoubleJumped = true;
                }
            }
            
            // Dash
            if (e.key.toLowerCase() === 'k') {
                player.dash();
            }
            
            // Specials - ALL 6 SLOTS!
            if (e.key.toLowerCase() === 'q') {
                player.useSpecial1();
            }
            if (e.key.toLowerCase() === 'e') {
                player.useSpecial2();
            }
            if (e.key.toLowerCase() === 'r') {
                player.useSpecial3();
            }
            if (e.key.toLowerCase() === 'f') {
                player.useSpecial4();
            }
            if (e.key.toLowerCase() === 'c') {
                player.useSpecial5();
            }
            if (e.key.toLowerCase() === 'v') {
                player.useSpecial6();
            }
        });
        
        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });
        
        canvas.addEventListener('mousedown', () => {
            if (gameStarted && !gameOver) {
                player.attack();
            }
        });
        
        // Game loop
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Always draw the room (even during upgrade/safe room screens)
            if (gameStarted && !gameOver) {
                currentRoom.draw();
            }
            
            if (!gameStarted || gameOver || showingUpgrade) {
                requestAnimationFrame(gameLoop);
                return;
            }
            
            // Player input
            if (!player.dashing) {
                if (keys['a'] || keys['arrowleft']) {
                    player.vx = -player.speed;
                    player.facing = -1;
                } else if (keys['d'] || keys['arrowright']) {
                    player.vx = player.speed;
                    player.facing = 1;
                } else {
                    player.vx *= 0.8;
                }
            }
            
            // Ranged attack
            if (keys['l']) {
                player.shootRanged();
            }
            
            // Dagger attack (j)
            if (keys['j']) {
                player.attack();
            }
            
            // Update
            player.update();
            
            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                particles[i].draw();
                if (particles[i].life <= 0) {
                    particles.splice(i, 1);
                }
            }
            
            // Update projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                if (!projectiles[i].update()) {
                    projectiles.splice(i, 1);
                } else {
                    projectiles[i].draw();
                    
                    // Collision detection
                    const proj = projectiles[i];
                    
                    if (proj.owner === 'player') {
                        let hitSomething = false;
                        
                        // vs enemies
                        for (let j = currentRoom.enemies.length - 1; j >= 0; j--) {
                            const enemy = currentRoom.enemies[j];
                            const dist = Math.sqrt((proj.x - enemy.x)**2 + (proj.y - enemy.y)**2);
                            if (dist < enemy.width / 2 + 8) {
                                const damage = player.attackDamage * (1 + player.upgrades.damage * 0.15);
                                enemy.takeDamage(damage);
                                
                                // EXPLOSIVE KNIVES
                                if (proj.explosive) {
                                    // Create explosion particles
                                    for (let k = 0; k < 30; k++) {
                                        particles.push(new Particle(
                                            proj.x, proj.y,
                                            ['#ff4500', '#ff8c00', '#ffa500'][Math.floor(Math.random() * 3)],
                                            (Math.random() - 0.5) * 15,
                                            (Math.random() - 0.5) * 15,
                                            40
                                        ));
                                    }
                                    
                                    // Explosion damage to nearby enemies
                                    const explosionRadius = 80;
                                    for (let k = currentRoom.enemies.length - 1; k >= 0; k--) {
                                        if (k === j) continue;
                                        const eDist = Math.sqrt((proj.x - currentRoom.enemies[k].x)**2 + (proj.y - currentRoom.enemies[k].y)**2);
                                        if (eDist < explosionRadius) {
                                            currentRoom.enemies[k].takeDamage(damage * 0.5);
                                            if (currentRoom.enemies[k].health <= 0) {
                                                currentRoom.enemies.splice(k, 1);
                                                if (k < j) j--;
                                            }
                                        }
                                    }
                                }
                                
                                if (enemy.health <= 0) {
                                    currentRoom.enemies.splice(j, 1);
                                }
                                
                                hitSomething = true;
                                
                                // PIERCING - projectile continues
                                if (player.upgrades.piercing > 0) {
                                    // Don't remove projectile, let it pierce through
                                } else if (player.upgrades.ricochet > 0 && player.upgrades.ricochet <= 3) {
                                    // RICOCHET - bounce to another enemy
                                    let nearestEnemy = null;
                                    let nearestDist = Infinity;
                                    for (const e of currentRoom.enemies) {
                                        if (e === enemy) continue;
                                        const d = Math.sqrt((e.x - proj.x)**2 + (e.y - proj.y)**2);
                                        if (d < nearestDist && d < 300) {
                                            nearestDist = d;
                                            nearestEnemy = e;
                                        }
                                    }
                                    
                                    if (nearestEnemy) {
                                        const angle = Math.atan2(nearestEnemy.y - proj.y, nearestEnemy.x - proj.x);
                                        proj.vx = Math.cos(angle) * 12;
                                        proj.vy = Math.sin(angle) * 12;
                                        proj.life = 60; // Give it more life to reach target
                                    } else {
                                        projectiles.splice(i, 1);
                                    }
                                    break;
                                } else {
                                    projectiles.splice(i, 1);
                                    break;
                                }
                            }
                        }
                        
                        // vs boss
                        if (!hitSomething && currentRoom.boss && currentRoom.boss.health > 0) {
                            const dist = Math.sqrt((proj.x - currentRoom.boss.x)**2 + (proj.y - currentRoom.boss.y)**2);
                            if (dist < currentRoom.boss.width / 2 + 8) {
                                const damage = player.attackDamage * (1 + player.upgrades.damage * 0.15);
                                currentRoom.boss.takeDamage(damage);
                                
                                // EXPLOSIVE KNIVES on boss
                                if (proj.explosive) {
                                    for (let k = 0; k < 30; k++) {
                                        particles.push(new Particle(
                                            proj.x, proj.y,
                                            ['#ff4500', '#ff8c00', '#ffa500'][Math.floor(Math.random() * 3)],
                                            (Math.random() - 0.5) * 15,
                                            (Math.random() - 0.5) * 15,
                                            40
                                        ));
                                    }
                                }
                                
                                // Don't remove if piercing
                                if (!(player.upgrades.piercing > 0)) {
                                    projectiles.splice(i, 1);
                                }
                            }
                        }
                    } else {
                        // Enemy projectile vs player
                        const dist = Math.sqrt((proj.x - player.x)**2 + (proj.y - player.y)**2);
                        if (dist < player.width / 2 + 8) {
                            if (!player.dashing && !player.invincible) {
                                player.takeDamage(10);
                            }
                            projectiles.splice(i, 1);
                        }
                    }
                }
            }
            
            // Update shadow clones
            for (let i = shadowClones.length - 1; i >= 0; i--) {
                if (!shadowClones[i].update()) {
                    shadowClones.splice(i, 1);
                } else {
                    shadowClones[i].draw();
                }
            }
            
            // Update enemies
            for (const enemy of currentRoom.enemies) {
                enemy.update();
                enemy.draw();
            }
            
            // Update boss
            if (currentRoom.boss && currentRoom.boss.health > 0) {
                currentRoom.boss.update();
                currentRoom.boss.draw();
            }
            
            // Draw player
            player.draw();
            
            // Check for room transition
            const roomCleared = currentRoom.isSafeRoom || (currentRoom.boss ? 
                (currentRoom.boss.health <= 0) : 
                (currentRoom.enemies.length === 0));
                
            if (roomCleared && player.x > canvas.width - 60) {
                roomNumber++;
                
                const isSafeRoom = (roomNumber % 7 === 0);
                const isBossRoom = (roomNumber % 5 === 0) && !isSafeRoom;
                currentRoom = new Room(roomNumber * 12345, isBossRoom, isSafeRoom);
                
                player.x = 100;
                player.y = canvas.height - 200;
                player.vy = 0;
                player.vx = 0;
                
                if (isSafeRoom) {
                    // Full heal in safe room
                    player.health = player.maxHealth;
                } else {
                    // Small heal on normal room transition
                    player.health = Math.min(player.health + 20, player.maxHealth);
                }
                
                projectiles = [];
                particles = [];
                shadowClones = [];
                
                // Save checkpoint at safe rooms (every 7 rooms)
                if (isSafeRoom) {
                    const checkpoint = {
                        room: roomNumber,
                        health: player.health,
                        maxHealth: player.maxHealth,
                        upgrades: {...player.upgrades},
                        special1: player.special1,
                        special2: player.special2,
                        special3: player.special3,
                        special4: player.special4,
                        special5: player.special5,
                        special6: player.special6,
                        hasDoubleJump: player.hasDoubleJump,
                        mythicMode: mythicMode
                    };
                    localStorage.setItem('shadowAssassinCheckpoint', JSON.stringify(checkpoint));
                    
                    // Show safe room screen
                    document.getElementById('safeRoomScreen').style.display = 'flex';
                    showingUpgrade = true;
                } else if (!isBossRoom) {
                    // Show upgrade screen for normal rooms
                    showingUpgrade = true;
                    showUpgradeScreen();
                }
            }
            
            // Update UI
            document.getElementById('health').textContent = Math.floor(player.health);
            document.getElementById('healthBar').style.width = (player.health / player.maxHealth * 100) + '%';
            document.getElementById('room').textContent = roomNumber;
            const enemyCount = currentRoom.enemies.length + (currentRoom.boss && currentRoom.boss.health > 0 ? 1 : 0);
            document.getElementById('enemies').textContent = enemyCount;
            
            // Update special abilities UI
            updateSpecialAbilitiesUI();
            
            // Mythic mode indicator
            if (mythicMode) {
                ctx.fillStyle = '#ffd700';
                ctx.font = 'bold 26px Courier New';
                ctx.textAlign = 'center';
                ctx.shadowColor = 'rgba(255, 215, 0, 0.9)';
                ctx.shadowBlur = 15;
                const pulse = 0.85 + Math.sin(Date.now() / 200) * 0.15;
                ctx.globalAlpha = pulse;
                ctx.fillText('⚡ GOLDEN GOD MODE ⚡', canvas.width / 2, 30);
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
            }
            
            // Game over
            if (player.health <= 0 && !gameOver) {
                gameOver = true;
                document.getElementById('finalRoom').textContent = roomNumber;
                
                // Check if checkpoint exists and enable/disable button accordingly
                const saved = localStorage.getItem('shadowAssassinCheckpoint');
                const loadCheckpointBtn = document.getElementById('loadCheckpointBtn');
                
                if (saved) {
                    // Checkpoint exists - enable button
                    loadCheckpointBtn.disabled = false;
                    loadCheckpointBtn.style.opacity = '1';
                    loadCheckpointBtn.style.cursor = 'pointer';
                } else {
                    // No checkpoint - disable button
                    loadCheckpointBtn.disabled = true;
                    loadCheckpointBtn.style.opacity = '0.5';
                    loadCheckpointBtn.style.cursor = 'not-allowed';
                }
                
                document.getElementById('gameOverScreen').style.display = 'flex';
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        // Menu button event listeners
        document.getElementById('playBtn').addEventListener('click', () => {
            document.getElementById('mainMenu').style.display = 'none';
            gameStarted = true;
            mythicMode = false; // Reset mythic mode
            player = new Player(100, 300);
            currentRoom = new Room(1);
            roomNumber = 1;
            particles = [];
            projectiles = [];
            shadowClones = [];
            gameOver = false;
        });

        document.getElementById('settingsBtn').addEventListener('click', () => {
            document.getElementById('settingsMenu').style.display = 'flex';
        });

        document.getElementById('backBtn').addEventListener('click', () => {
            document.getElementById('settingsMenu').style.display = 'none';
        });

        // Settings toggles
        function setupToggle(toggleId, valueId, settingKey) {
            document.getElementById(toggleId).addEventListener('click', function() {
                this.classList.toggle('active');
                const isActive = this.classList.contains('active');
                document.getElementById(valueId).textContent = isActive ? 'ON' : 'OFF';
            });
        }

        setupToggle('particlesToggle', 'particlesValue', 'particlesEnabled');
        setupToggle('screenShakeToggle', 'screenShakeValue', 'screenShakeEnabled');
        setupToggle('damageNumbersToggle', 'damageNumbersValue', 'damageNumbersEnabled');
        setupToggle('fpsToggle', 'fpsValue', 'showFPS');

        document.getElementById('volumeSlider').addEventListener('input', (e) => {
            document.getElementById('volumeValue').textContent = e.target.value + '%';
        });

        document.getElementById('musicSlider').addEventListener('input', (e) => {
            document.getElementById('musicValue').textContent = e.target.value + '%';
        });

        document.getElementById('sfxSlider').addEventListener('input', (e) => {
            document.getElementById('sfxValue').textContent = e.target.value + '%';
        });
        
        // Game over buttons
        document.getElementById('playAgainBtn').addEventListener('click', () => {
            mythicMode = false; // Reset mythic mode
            player = new Player(100, 300);
            currentRoom = new Room(1);
            roomNumber = 1;
            particles = [];
            projectiles = [];
            shadowClones = [];
            gameStarted = true;
            gameOver = false;
            document.getElementById('gameOverScreen').style.display = 'none';
        });
        
        document.getElementById('loadCheckpointBtn').addEventListener('click', () => {
            // Try to load saved checkpoint
            const saved = localStorage.getItem('shadowAssassinCheckpoint');
            if (saved) {
                const checkpoint = JSON.parse(saved);
                
                mythicMode = checkpoint.mythicMode || false;
                player = new Player(100, 300);
                player.health = checkpoint.health;
                player.maxHealth = checkpoint.maxHealth;
                player.upgrades = checkpoint.upgrades;
                
                // Restore special abilities - ALL 6 SLOTS!
                player.special1 = checkpoint.special1;
                player.special2 = checkpoint.special2;
                player.special3 = checkpoint.special3 || null;
                player.special4 = checkpoint.special4 || null;
                player.special5 = checkpoint.special5 || null;
                player.special6 = checkpoint.special6 || null;
                player.hasDoubleJump = checkpoint.hasDoubleJump;
                
                roomNumber = checkpoint.room;
                
                // Determine if returning to safe room or continuing
                const isSafeRoom = (roomNumber % 7 === 0);
                const isBossRoom = (roomNumber % 5 === 0) && !isSafeRoom;
                currentRoom = new Room(roomNumber * 12345, isBossRoom, isSafeRoom);
                
                player.x = 100;
                player.y = canvas.height - 200;
                
                particles = [];
                projectiles = [];
                shadowClones = [];
                gameStarted = true;
                gameOver = false;
                document.getElementById('gameOverScreen').style.display = 'none';
            } else {
                // No checkpoint exists - button shouldn't even be clickable
                alert('No checkpoint found! You must reach a safe room (every 7 rooms) to save a checkpoint.');
            }
        });
        
        // Home button - returns to main menu
        document.getElementById('homeBtn').addEventListener('click', () => {
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'flex';
            gameStarted = false;
            gameOver = false;
            
            // Reset game state
            mythicMode = false;
            player = new Player(100, 300);
            currentRoom = new Room(1);
            roomNumber = 1;
            particles = [];
            projectiles = [];
            shadowClones = [];
        });
        
        // Safe room continue button
        document.getElementById('safeRoomContinueBtn').addEventListener('click', () => {
            document.getElementById('safeRoomScreen').style.display = 'none';
            showingUpgrade = false;
        });
        
        // Start game loop
        gameLoop();
    </script>
</body>
</html>
