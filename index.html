<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Valorant Proto: Ascent B-Site</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #0f1923; /* Val dark blue */
            color: white;
            user-select: none;
        }

        /* UI OVERLAY */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* CROSSHAIR */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background-color: #00ffaa; /* Cyan crosshair */
            transform: translate(-50%, -50%);
            border: 1px solid rgba(0,0,0,0.5);
            box-shadow: 0 0 2px black;
        }
        #crosshair.inner-h {
            position: absolute;
            width: 14px;
            height: 2px;
            background-color: #00ffaa;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        #crosshair.inner-v {
            position: absolute;
            width: 2px;
            height: 14px;
            background-color: #00ffaa;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* HUD BOTTOM */
        #hud-bottom {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 40px;
            align-items: flex-end;
        }

        .hud-stat {
            text-align: center;
        }

        .hud-value {
            font-size: 48px;
            font-weight: bold;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .hud-label {
            font-size: 12px;
            color: #ccc;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        #health-val { color: #ff4655; } /* Val Red */
        #ammo-val { color: white; }

        /* ABILITIES */
        #ability-bar {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
        }

        .ability-box {
            width: 60px;
            height: 60px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #444;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        .ability-box.active {
            border-color: #00ffaa;
            box-shadow: 0 0 10px #00ffaa;
        }
        .key-bind {
            position: absolute;
            top: 2px;
            left: 5px;
            font-size: 10px;
            color: #aaa;
        }
        .cooldown-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 0%;
            background-color: rgba(255, 70, 85, 0.7);
            transition: height 0.1s linear;
        }

        /* KILL FEED */
        #kill-feed {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 5px;
        }
        .kill-msg {
            background: linear-gradient(90deg, transparent, rgba(15, 25, 35, 0.8));
            padding: 5px 15px;
            border-right: 4px solid #ff4655;
            color: white;
            font-size: 14px;
            animation: fadeOut 3s forwards;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        @keyframes fadeOut {
            0% { opacity: 1; transform: translateX(0); }
            80% { opacity: 1; }
            100% { opacity: 0; transform: translateX(20px); }
        }

        /* AGENT SELECT / MENU */
        #menu-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('https://images.unsplash.com/photo-1550745165-9bc0b252726f?q=80&w=2070&auto=format&fit=crop') no-repeat center center/cover;
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }
        .overlay-bg {
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(15, 25, 35, 0.95);
            z-index: -1;
        }
        h1 {
            font-size: 80px;
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 5px;
            color: #ff4655;
            font-style: italic;
        }
        .map-name {
            color: white;
            font-size: 20px;
            letter-spacing: 5px;
            margin-bottom: 20px;
            text-transform: uppercase;
        }
        .agent-select {
            display: flex;
            gap: 20px;
            margin-top: 30px;
        }
        .agent-card {
            width: 200px;
            height: 300px;
            background: #1f2b35;
            border: 2px solid transparent;
            cursor: pointer;
            transition: 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            padding-bottom: 20px;
        }
        .agent-card:hover {
            border-color: #ff4655;
            transform: translateY(-10px);
        }
        .agent-card.selected {
            border-color: #00ffaa;
            background: #2a3b47;
            box-shadow: 0 0 20px rgba(0, 255, 170, 0.2);
        }
        .agent-icon {
            font-size: 60px;
            margin-bottom: auto;
            margin-top: 50px;
        }
        .agent-name {
            font-size: 24px;
            font-weight: bold;
            text-transform: uppercase;
        }
        .agent-role {
            font-size: 12px;
            color: #aaa;
            text-transform: uppercase;
        }
        #start-btn {
            margin-top: 50px;
            padding: 20px 80px;
            font-size: 24px;
            background-color: #333; /* Disabled look initially */
            color: #888;
            border: none;
            cursor: not-allowed;
            text-transform: uppercase;
            font-weight: bold;
            letter-spacing: 2px;
            clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
            transition: 0.2s;
        }
        #start-btn.ready {
            background-color: #ff4655;
            color: white;
            cursor: pointer;
            animation: pulse 2s infinite;
        }
        #start-btn.ready:hover {
            background-color: #d13644;
            transform: scale(1.05);
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 70, 85, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 70, 85, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 70, 85, 0); }
        }

        /* HIT MARKER */
        #hitmarker {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 30px;
            height: 30px;
            transform: translate(-50%, -50%) rotate(45deg);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s;
        }
    </style>
    <!-- Three.js Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
</head>
<body>

    <!-- 3D Canvas Container -->
    <div id="canvas-container"></div>

    <!-- UI Overlay -->
    <div id="ui-layer">
        <div id="crosshair">
            <div class="inner-h"></div>
            <div class="inner-v"></div>
        </div>

        <div id="kill-feed"></div>

        <div id="hitmarker">
            <div style="position:absolute; top:14px; left:0; width:30px; height:2px; background:white;"></div>
            <div style="position:absolute; top:0; left:14px; width:2px; height:30px; background:white;"></div>
        </div>

        <div id="ability-bar">
            <!-- Simplified: Just showing Signature Ability (E) -->
            <div class="ability-box" id="ability-e">
                <span class="key-bind">E</span>
                <span id="ability-icon" style="font-size: 24px;">-</span>
                <div class="cooldown-overlay" id="cooldown-e"></div>
            </div>
        </div>

        <div id="hud-bottom">
            <div class="hud-stat">
                <div class="hud-value" id="health-val">100</div>
                <div class="hud-label">Health</div>
            </div>
            <div class="hud-stat">
                <div class="hud-value" id="ammo-val">25</div>
                <div class="hud-label">Ammo</div>
            </div>
        </div>
    </div>

    <!-- Main Menu -->
    <div id="menu-screen">
        <div class="overlay-bg"></div>
        <h1>VALORANT<span style="font-size:20px; vertical-align:top;">PROTO</span></h1>
        <div class="map-name">LOCATION: ASCENT B-SITE</div>
        
        <div class="agent-select">
            <div class="agent-card" onclick="selectAgent('jett')">
                <div class="agent-icon">ðŸ’¨</div>
                <div class="agent-name">Wind</div>
                <div class="agent-role">Duelist</div>
            </div>
            <div class="agent-card" onclick="selectAgent('sage')">
                <div class="agent-icon">ðŸ§Š</div>
                <div class="agent-name">Healer</div>
                <div class="agent-role">Sentinel</div>
            </div>
            <div class="agent-card" onclick="selectAgent('phoenix')">
                <div class="agent-icon">ðŸ”¥</div>
                <div class="agent-name">Blaze</div>
                <div class="agent-role">Duelist</div>
            </div>
        </div>

        <button id="start-btn" onclick="startGame()">Select Agent First</button>
    </div>

    <script>
        // --- GAME CONFIG & STATE ---
        const gameState = {
            isPlaying: false,
            health: 100,
            ammo: 25,
            magSize: 25,
            agent: null,
            canShoot: true,
            isReloading: false,
            lastShotTime: 0,
            fireRate: 100, // ms between shots
            bots: [],
            walls: [],
            score: 0,
            canUseAbility: true
        };

        const agents = {
            'jett': { name: 'Wind', color: 0xaaccff, icon: 'ðŸ’¨', ability: 'dash' },
            'sage': { name: 'Healer', color: 0x00ffaa, icon: 'ðŸ§Š', ability: 'wall' },
            'phoenix': { name: 'Blaze', color: 0xffaa00, icon: 'ðŸ”¥', ability: 'flash' }
        };

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Sky
        scene.fog = new THREE.Fog(0x87CEEB, 10, 60);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        // Sun
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(50, 100, -50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.left = -50;
        dirLight.shadow.camera.right = 50;
        dirLight.shadow.camera.top = 50;
        dirLight.shadow.camera.bottom = -50;
        scene.add(dirLight);

        // Controls
        const controls = new THREE.PointerLockControls(camera, document.body);

        // --- ASCENT B-SITE BLOCKOUT ---
        // Coordinates simplified: Site Center is 0,0,0. B Main starts at X=-20.
        // Colors:
        const C_WALL = 0xd6cba8; // Venetian Tan
        const C_FLOOR = 0x555555; // Grey Concrete
        const C_BOX = 0x2e4a3d; // Radianite Green
        const C_ACCENT = 0x8b5a2b; // Wood/Doors

        function createWall(x, y, z, w, h, d, color) {
            const geo = new THREE.BoxGeometry(w, h, d);
            const mat = new THREE.MeshStandardMaterial({ color: color });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, y + h/2, z); // pivot from bottom
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            gameState.walls.push(mesh);
        }

        function createMap() {
            // 1. Floor (Huge Plane)
            const floorGeo = new THREE.PlaneGeometry(200, 200);
            const floorMat = new THREE.MeshStandardMaterial({ color: C_FLOOR });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // 2. B Main (Tunnel Entrance)
            // Player starts here (-30, 0, 0)
            createWall(-35, 0, 5, 30, 6, 1, C_WALL); // Left wall
            createWall(-35, 0, -5, 30, 6, 1, C_WALL); // Right wall
            createWall(-20, 0, 0, 1, 6, 11, C_WALL); // Archway Top simplified as blockers? No, archway needs gap.
            // B Main Archway (Simulated by 2 pillars and a top beam)
            createWall(-20, 0, 6, 2, 8, 4, C_WALL); // Left Pillar
            createWall(-20, 0, -6, 2, 8, 4, C_WALL); // Right Pillar
            createWall(-20, 6, 0, 2, 2, 16, C_WALL); // Top Beam

            // 3. Site Boundaries
            // Back Wall (CT Side)
            createWall(20, 0, 0, 1, 8, 40, C_WALL); 
            // Left Wall (Boathouse Side)
            createWall(0, 0, -20, 40, 8, 1, C_WALL);
            // Right Wall (Market Side)
            createWall(0, 0, 20, 40, 8, 1, C_WALL);

            // 4. Site Structures
            // "Default" Box (Green)
            createWall(-5, 0, 2, 3, 2.5, 3, C_BOX);
            createWall(-5, 2.5, 2, 3, 0.5, 3, 0x444444); // Metal trim

            // "Boathouse" (The shed in the back left)
            // It's a small building at approx (10, 0, -15)
            createWall(10, 0, -15, 8, 5, 8, C_WALL); 
            createWall(10, 0, -11, 4, 3, 0.2, C_ACCENT); // Door/Window visual

            // "Market Stairs" / Platform (Right Side)
            createWall(5, 0, 15, 10, 3, 8, C_WALL); // Platform
            createWall(0, 0, 15, 5, 1, 4, 0x888888); // Ramp/Steps stub

            // "Switch" Area (Near CT)
            createWall(15, 0, -5, 1, 4, 4, C_WALL); // Wall hiding switch
            createWall(14, 0, -5, 1, 1.5, 1, C_ACCENT); // The switch console

            // CT Spawn Arch (Exit)
            // Gap in the back wall at (20, 0, 5)
            
            // Random cover boxes
            createWall(12, 0, 8, 2, 2, 2, C_BOX);
            createWall(-15, 0, -8, 2, 2, 2, C_BOX);
        }

        // Gun Model
        const gunGroup = new THREE.Group();
        const gunGeo = new THREE.BoxGeometry(0.15, 0.2, 0.6);
        const gunMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
        const gunMesh = new THREE.Mesh(gunGeo, gunMat);
        gunMesh.position.set(0.25, -0.2, -0.5);
        gunGroup.add(gunMesh);
        
        const gunAccentGeo = new THREE.BoxGeometry(0.05, 0.05, 0.4);
        const gunAccentMat = new THREE.MeshBasicMaterial({ color: 0xffffff }); 
        const gunAccent = new THREE.Mesh(gunAccentGeo, gunAccentMat);
        gunAccent.position.set(0.25, -0.12, -0.5);
        gunGroup.add(gunAccent);

        camera.add(gunGroup);
        scene.add(camera);

        // Bots Setup
        function spawnBotAt(x, z) {
            const group = new THREE.Group();
            
            const bodyGeo = new THREE.CapsuleGeometry(0.5, 1.5, 4, 8);
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x334455 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 1.25;
            body.userData = { isBody: true, parentBot: group };
            group.add(body);

            const headGeo = new THREE.SphereGeometry(0.3, 8, 8);
            const headMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 2.4;
            head.userData = { isHead: true, parentBot: group };
            group.add(head);

            group.position.set(x, 0, z);
            group.userData = { health: 100 };
            
            scene.add(group);
            gameState.bots.push(group);
        }

        // Spawn specific training bots
        const botLocations = [
            {x: 0, z: 0}, // Site
            {x: 10, z: -10}, // Boathouse front
            {x: 15, z: 5}, // CT
            {x: 5, z: 15}, // Market
            {x: -10, z: -10} // Corner
        ];

        // --- INPUT & MOVEMENT ---
        const keys = { w: false, a: false, s: false, d: false, space: false };
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let prevTime = performance.now();

        document.addEventListener('keydown', (e) => {
            switch(e.code) {
                case 'KeyW': keys.w = true; break;
                case 'KeyA': keys.a = true; break;
                case 'KeyS': keys.s = true; break;
                case 'KeyD': keys.d = true; break;
                case 'Space': if(velocity.y === 0) velocity.y = 12; break; // Jump
                case 'KeyR': reload(); break;
                case 'KeyE': useAbility(); break;
            }
        });

        document.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'KeyW': keys.w = false; break;
                case 'KeyA': keys.a = false; break;
                case 'KeyS': keys.s = false; break;
                case 'KeyD': keys.d = false; break;
            }
        });

        document.addEventListener('mousedown', () => {
            if(gameState.isPlaying) shoot();
        });

        // --- GAME LOGIC ---

        function selectAgent(agentKey) {
            document.querySelectorAll('.agent-card').forEach(c => c.classList.remove('selected'));
            event.currentTarget.classList.add('selected');
            
            gameState.agent = agentKey;
            
            // Enable Button
            const btn = document.getElementById('start-btn');
            btn.classList.add('ready');
            btn.innerText = "ENTER SITE";
            btn.disabled = false;
            
            document.getElementById('ability-icon').innerText = agents[agentKey].icon;
            gunAccent.material.color.setHex(agents[agentKey].color);
        }

        function startGame() {
            if (!gameState.agent) return;
            
            // UI Hide
            document.getElementById('menu-screen').style.display = 'none';
            gameState.isPlaying = true;
            
            // Generate World
            createMap();
            botLocations.forEach(loc => spawnBotAt(loc.x, loc.z));
            
            // Move Player to Spawn (B Main)
            camera.position.set(-35, 1.6, 0);
            camera.lookAt(0, 1.6, 0);

            // Lock Cursor
            controls.lock();

            resetHud();
        }

        // Pointer Lock Event Listeners to handle Escape key properly
        controls.addEventListener('unlock', function () {
            // Optional: Pause menu could go here
        });

        function resetHud() {
            gameState.health = 100;
            gameState.ammo = gameState.magSize;
            updateHud();
        }

        function updateHud() {
            document.getElementById('health-val').innerText = gameState.health;
            document.getElementById('ammo-val').innerText = gameState.ammo;
        }

        function showHitmarker() {
            const el = document.getElementById('hitmarker');
            el.style.opacity = 1;
            setTimeout(() => el.style.opacity = 0, 100);
        }

        function addKillFeed() {
            const feed = document.getElementById('kill-feed');
            const el = document.createElement('div');
            el.className = 'kill-msg';
            el.innerHTML = `<span>YOU</span> <span style="font-size:10px;">ðŸ”«</span> <span>BOT</span>`;
            feed.appendChild(el);
            setTimeout(() => el.remove(), 3000);
        }

        function shoot() {
            const now = performance.now();
            if (!gameState.canShoot || gameState.ammo <= 0 || gameState.isReloading || now - gameState.lastShotTime < gameState.fireRate) return;

            gameState.lastShotTime = now;
            gameState.ammo--;
            updateHud();

            // Recoil
            gunGroup.position.z += 0.1;
            gunGroup.rotation.x += 0.05;
            setTimeout(() => {
                gunGroup.position.z -= 0.1;
                gunGroup.rotation.x -= 0.05;
            }, 50);

            // Raycast
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

            // Hitscan objects
            const shootable = [...gameState.walls];
            gameState.bots.forEach(b => {
                b.children.forEach(c => shootable.push(c));
            });

            const intersects = raycaster.intersectObjects(shootable);

            if (intersects.length > 0) {
                const hit = intersects[0];
                const obj = hit.object;

                createImpact(hit.point, hit.face.normal);

                if (obj.userData.isHead || obj.userData.isBody) {
                    showHitmarker();
                    const damage = obj.userData.isHead ? 150 : 30; 
                    const botGroup = obj.userData.parentBot;
                    
                    botGroup.userData.health -= damage;
                    
                    if (botGroup.userData.health <= 0) {
                        killBot(botGroup);
                    }
                }
            }
        }

        function createImpact(pos, normal) {
            const geo = new THREE.BoxGeometry(0.05, 0.05, 0.05);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const spark = new THREE.Mesh(geo, mat);
            spark.position.copy(pos);
            scene.add(spark);
            setTimeout(() => scene.remove(spark), 300);
        }

        function killBot(botGroup) {
            scene.remove(botGroup);
            gameState.bots = gameState.bots.filter(b => b !== botGroup);
            addKillFeed();
            // Respawn in a random spot after delay
            setTimeout(() => {
                if(gameState.isPlaying) {
                    const loc = botLocations[Math.floor(Math.random() * botLocations.length)];
                    spawnBotAt(loc.x + (Math.random()-0.5)*2, loc.z + (Math.random()-0.5)*2);
                }
            }, 3000);
        }

        function reload() {
            if (gameState.ammo === gameState.magSize || gameState.isReloading) return;
            gameState.isReloading = true;
            gunGroup.rotation.x = -0.5;
            setTimeout(() => {
                gameState.ammo = gameState.magSize;
                gameState.isReloading = false;
                gunGroup.rotation.x = 0;
                updateHud();
            }, 1500);
        }

        function useAbility() {
            if (!gameState.canUseAbility) return;
            const abilityType = agents[gameState.agent].ability;
            startCooldown(10000);

            if (abilityType === 'dash') {
                velocity.add(direction.clone().multiplyScalar(50));
            } else if (abilityType === 'wall') {
                const wallGeo = new THREE.BoxGeometry(4, 3, 1);
                const wallMat = new THREE.MeshStandardMaterial({ color: 0x00ffaa, transparent: true, opacity: 0.8 });
                const wall = new THREE.Mesh(wallGeo, wallMat);
                
                const spawnPos = camera.position.clone().add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(4));
                spawnPos.y = 1.5;
                wall.position.copy(spawnPos);
                wall.lookAt(camera.position.x, 1.5, camera.position.z); // Face player
                
                scene.add(wall);
                gameState.walls.push(wall);
                setTimeout(() => {
                    scene.remove(wall);
                    gameState.walls = gameState.walls.filter(w => w !== wall);
                }, 10000);

            } else if (abilityType === 'flash') {
                const flashGeo = new THREE.SphereGeometry(0.3);
                const flashMat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
                const flash = new THREE.Mesh(flashGeo, flashMat);
                
                const throwDir = camera.getWorldDirection(new THREE.Vector3());
                flash.position.copy(camera.position);
                scene.add(flash);
                
                let speed = 0.8;
                const interval = setInterval(() => {
                    flash.position.add(throwDir.clone().multiplyScalar(speed));
                    speed *= 0.9;
                }, 16);

                setTimeout(() => {
                    clearInterval(interval);
                    flash.scale.set(20, 20, 20);
                    flash.material.transparent = true;
                    flash.material.opacity = 0.8;
                    setTimeout(() => scene.remove(flash), 100);
                }, 400);
            }
        }

        function startCooldown(ms) {
            gameState.canUseAbility = false;
            const overlay = document.getElementById('cooldown-e');
            overlay.style.transition = `height ${ms}ms linear`;
            overlay.style.height = '100%';
            
            // Force reflow
            overlay.offsetHeight; 

            setTimeout(() => {
                overlay.style.transition = 'none';
                overlay.style.height = '0%';
                gameState.canUseAbility = true;
            }, ms);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (gameState.isPlaying && controls.isLocked) {
                const time = performance.now();
                const delta = (time - prevTime) / 1000;

                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 9.8 * 5.0 * delta;

                direction.z = Number(keys.w) - Number(keys.s);
                direction.x = Number(keys.d) - Number(keys.a);
                direction.normalize();

                if (keys.w || keys.s) velocity.z -= direction.z * 100.0 * delta;
                if (keys.a || keys.d) velocity.x -= direction.x * 100.0 * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                
                controls.getObject().position.y += (velocity.y * delta);

                if (controls.getObject().position.y < 1.6) {
                    velocity.y = 0;
                    controls.getObject().position.y = 1.6;
                }

                prevTime = time;
            } else {
                 prevTime = performance.now();
            }

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
