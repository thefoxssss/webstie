<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shadow Assassin - Castle Infiltration</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0a;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }

        #gameCanvas {
            border: 2px solid #8b4513;
            box-shadow: 0 0 30px rgba(139, 69, 19, 0.5);
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
        }

        .health-bar {
            width: 200px;
            height: 20px;
            background: #222;
            border: 2px solid #8b4513;
            margin-top: 5px;
            position: relative;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #dc143c, #8b0000);
            transition: width 0.3s;
        }

        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #aaa;
            font-size: 12px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .title {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #fff;
            z-index: 5;
            pointer-events: none;
        }

        .title h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #8b4513;
            text-shadow: 0 0 20px rgba(139, 69, 19, 0.8);
        }

        .title p {
            font-size: 18px;
            color: #ccc;
        }

        .fade-out {
            animation: fadeOut 2s forwards;
        }

        @keyframes fadeOut {
            to { opacity: 0; }
        }

        .upgrade-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .upgrade-container {
            text-align: center;
            color: #fff;
        }

        .upgrade-title {
            font-size: 36px;
            color: #ffd700;
            margin-bottom: 30px;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .upgrade-options {
            display: flex;
            gap: 30px;
            justify-content: center;
        }

        .upgrade-card {
            background: linear-gradient(135deg, #2a2a2a, #1a1a1a);
            border: 3px solid #8b4513;
            padding: 20px;
            width: 250px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }

        .upgrade-card:hover {
            transform: translateY(-10px);
            border-color: #ffd700;
            box-shadow: 0 10px 30px rgba(255, 215, 0, 0.3);
        }

        .upgrade-card h3 {
            color: #ffd700;
            font-size: 22px;
            margin-bottom: 10px;
        }

        .upgrade-card .level {
            color: #ff8c00;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .upgrade-card p {
            color: #ccc;
            font-size: 14px;
            line-height: 1.5;
        }

        .upgrade-card.mythic {
            border-color: #ff00ff;
            animation: mythicGlow 2s ease-in-out infinite;
        }

        .upgrade-card.mythic h3 {
            color: #ff00ff;
            text-shadow: 0 0 15px #ff00ff;
        }

        @keyframes mythicGlow {
            0%, 100% {
                box-shadow: 0 0 20px rgba(255, 0, 255, 0.6), 0 0 40px rgba(255, 0, 255, 0.4);
            }
            50% {
                box-shadow: 0 0 30px rgba(255, 0, 255, 0.8), 0 0 60px rgba(255, 0, 255, 0.6);
            }
        }

        .game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .game-over-title {
            font-size: 48px;
            color: #ff0000;
            margin-bottom: 30px;
            text-shadow: 0 0 20px rgba(255, 0, 0, 0.8);
        }

        .game-over-stats {
            color: #ffd700;
            font-size: 20px;
            margin-bottom: 30px;
        }

        .button-container {
            display: flex;
            gap: 20px;
        }

        .game-button {
            background: linear-gradient(135deg, #8b4513, #654321);
            border: 3px solid #ffd700;
            padding: 15px 40px;
            color: #fff;
            font-size: 18px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }

        .game-button:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(255, 215, 0, 0.4);
            background: linear-gradient(135deg, #a0522d, #8b4513);
        }

        .game-button:active {
            transform: translateY(-2px);
        }
        
        .main-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 50%, #0a0a0a 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }

        .main-menu h1 {
            font-size: 64px;
            color: #8b4513;
            text-shadow: 0 0 30px rgba(139, 69, 19, 0.9);
            margin-bottom: 50px;
            animation: titlePulse 2s ease-in-out infinite;
        }

        @keyframes titlePulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .menu-button {
            background: linear-gradient(135deg, #8b4513, #654321);
            border: 3px solid #ffd700;
            padding: 20px 60px;
            color: #fff;
            font-size: 24px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            min-width: 300px;
        }

        .menu-button:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(255, 215, 0, 0.4);
            background: linear-gradient(135deg, #a0522d, #8b4513);
        }

        .settings-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 201;
        }

        .settings-container {
            background: linear-gradient(135deg, #2a2a2a, #1a1a1a);
            border: 3px solid #8b4513;
            padding: 40px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .settings-container h2 {
            color: #ffd700;
            font-size: 32px;
            margin-bottom: 30px;
            text-align: center;
        }

        .setting-item {
            margin-bottom: 25px;
            color: #fff;
        }

        .setting-item label {
            display: block;
            margin-bottom: 10px;
            font-size: 16px;
            color: #ffd700;
        }

        .setting-item input[type="range"] {
            width: 100%;
            height: 8px;
            background: #444;
            outline: none;
            border-radius: 4px;
        }

        .setting-item input[type="range"]::-webkit-slider-thumb {
            width: 20px;
            height: 20px;
            background: #ffd700;
            cursor: pointer;
            border-radius: 50%;
        }

        .setting-value {
            display: inline-block;
            margin-left: 15px;
            color: #fff;
            font-weight: bold;
        }

        .toggle-button {
            padding: 10px 20px;
            background: #444;
            border: 2px solid #666;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Courier New', monospace;
        }

        .toggle-button.active {
            background: #ffd700;
            border-color: #ffd700;
            color: #000;
        }

        .setting-item select {
            width: 100%;
            padding: 10px;
            background: #444;
            border: 2px solid #666;
            color: #fff;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="1200" height="700"></canvas>
    
    <!-- UI Overlay -->
    <div id="ui">
        <div>Health: <span id="health">150</span></div>
        <div class="health-bar">
            <div id="healthBar" class="health-fill" style="width: 100%"></div>
        </div>
        <div style="margin-top: 10px;">Chamber: <span id="room">1</span></div>
        <div>Enemies: <span id="enemies">0</span></div>
    </div>
    
    <!-- Controls -->
    <div class="controls">
        WASD/Arrows: Move & Aim Knife | SPACE: Jump | J: Dagger | K: Dash | L: Knife<br>
        Q/E: Special Abilities
    </div>
    
    <!-- Main Menu -->
    <div id="mainMenu" class="main-menu">
        <h1>‚öîÔ∏è SHADOW ASSASSIN ‚öîÔ∏è</h1>
        <div class="menu-buttons">
            <button id="playBtn" class="menu-button">NEW GAME</button>
            <button id="continueBtn" class="menu-button" style="display: none;">CONTINUE</button>
            <button id="settingsBtn" class="menu-button">SETTINGS</button>
        </div>
    </div>

    <!-- Settings Menu -->
    <div id="settingsMenu" class="settings-menu">
        <div class="settings-container">
            <h2>‚öôÔ∏è SETTINGS ‚öôÔ∏è</h2>
            
            <div class="setting-item">
                <label>Master Volume: <span id="volumeValue" class="setting-value">100%</span></label>
                <input type="range" id="volumeSlider" min="0" max="100" value="100">
            </div>
            
            <div class="setting-item">
                <label>Music Volume: <span id="musicValue" class="setting-value">70%</span></label>
                <input type="range" id="musicSlider" min="0" max="100" value="70">
            </div>
            
            <div class="setting-item">
                <label>SFX Volume: <span id="sfxValue" class="setting-value">100%</span></label>
                <input type="range" id="sfxSlider" min="0" max="100" value="100">
            </div>
            
            <div class="setting-item">
                <label>Particles: <span id="particlesValue" class="setting-value">ON</span></label>
                <button id="particlesToggle" class="toggle-button active">TOGGLE</button>
            </div>
            
            <div class="setting-item">
                <label>Screen Shake: <span id="screenShakeValue" class="setting-value">ON</span></label>
                <button id="screenShakeToggle" class="toggle-button active">TOGGLE</button>
            </div>
            
            <div class="setting-item">
                <label>Damage Numbers: <span id="damageNumbersValue" class="setting-value">ON</span></label>
                <button id="damageNumbersToggle" class="toggle-button active">TOGGLE</button>
            </div>
            
            <div class="setting-item">
                <label>Show FPS: <span id="fpsValue" class="setting-value">OFF</span></label>
                <button id="fpsToggle" class="toggle-button">TOGGLE</button>
            </div>
            
            <div class="setting-item">
                <label>Difficulty:</label>
                <select id="difficultySelect">
                    <option value="easy">Easy</option>
                    <option value="normal" selected>Normal</option>
                    <option value="hard">Hard</option>
                </select>
            </div>
            
            <button id="backBtn" class="game-button" style="width: 100%; margin-top: 20px;">BACK</button>
        </div>
    </div>
    
    <!-- Upgrade Screen -->
    <div id="upgradeScreen" class="upgrade-screen">
        <div class="upgrade-container">
            <div class="upgrade-title">‚ö° CHOOSE YOUR UPGRADE ‚ö°</div>
            <div id="upgradeOptions" class="upgrade-options"></div>
        </div>
    </div>
    
    <!-- Game Over Screen -->
    <div id="gameOverScreen" class="game-over-screen">
        <div class="game-over-title">üíÄ DEFEATED üíÄ</div>
        <div class="game-over-stats">
            You reached Chamber <span id="finalRoom">1</span>
        </div>
        <div class="button-container">
            <button class="game-button" id="playAgainBtn">‚öîÔ∏è Play Again</button>
            <button class="game-button" id="loadCheckpointBtn">üìç Load Checkpoint</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Particle class
        class Particle {
            constructor(x, y, color, vx, vy, life) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.vx = vx;
                this.vy = vy;
                this.life = life;
                this.maxLife = life;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.2;
                this.life--;
            }
            
            draw() {
                const alpha = this.life / this.maxLife;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - 2, this.y - 2, 4, 4);
                ctx.globalAlpha = 1;
            }
        }

        // Projectile class  
        class Projectile {
            constructor(x, y, angle, speed, owner) {
                this.x = x;
                this.y = y;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.owner = owner;
                this.life = 180;
                this.explosive = false;
                this.homing = false;
                this.angle = angle;
            }
            
            update() {
                // Homing behavior
                if (this.homing && this.owner === 'player') {
                    let nearest = null;
                    let nearestDist = Infinity;
                    for (const enemy of currentRoom.enemies) {
                        const dist = Math.sqrt((enemy.x - this.x)**2 + (enemy.y - this.y)**2);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearest = enemy;
                        }
                    }
                    if (nearest && nearestDist < 400) {
                        const angle = Math.atan2(nearest.y - this.y, nearest.x - this.x);
                        this.vx += Math.cos(angle) * 0.5;
                        this.vy += Math.sin(angle) * 0.5;
                    }
                }
                
                this.x += this.vx;
                this.y += this.vy;
                this.life--;
                
                // Trail particle
                if (Math.random() < 0.2) {
                    particles.push(new Particle(
                        this.x, this.y,
                        this.owner === 'player' ? '#1a1a1a' : '#ff4500',
                        0, 0, 10
                    ));
                }
                
                return this.life > 0 && this.x > 0 && this.x < canvas.width && this.y > 0 && this.y < canvas.height;
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(Math.atan2(this.vy, this.vx));
                
                // Knife shape
                if (this.owner === 'player') {
                    ctx.fillStyle = '#c0c0c0';
                    ctx.fillRect(0, -2, 12, 4);
                    ctx.fillStyle = '#8b4513';
                    ctx.fillRect(-4, -1, 4, 2);
                } else {
                    // Enemy projectile (arrow)
                    ctx.fillStyle = '#8b4513';
                    ctx.fillRect(-4, -1, 8, 2);
                    ctx.fillStyle = '#c0c0c0';
                    ctx.beginPath();
                    ctx.moveTo(8, 0);
                    ctx.lineTo(4, -4);
                    ctx.lineTo(4, 4);
                    ctx.closePath();
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }

        // Shadow Clone class
        class ShadowClone {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 24;
                this.height = 32;
                this.vx = 0;
                this.vy = 0;
                this.life = 300;
                this.facing = 1;
                this.onGround = false;
                this.gravity = 0.6;
                this.attackCooldown = 0;
            }
            
            mimicMeleeAttack() {
                this.attackCooldown = 30;
                for (let i = 0; i < 10; i++) {
                    const angle = (Math.random() - 0.5) * Math.PI;
                    const speed = Math.random() * 3 + 2;
                    particles.push(new Particle(
                        this.x + this.facing * 20,
                        this.y,
                        '#2a2a2a',
                        Math.cos(angle) * speed * this.facing,
                        Math.sin(angle) * speed,
                        15
                    ));
                }
            }
            
            mimicRangedAttack() {
                let nearest = null;
                let nearestDist = Infinity;
                for (const enemy of currentRoom.enemies) {
                    const dist = Math.sqrt((enemy.x - this.x)**2 + (enemy.y - this.y)**2);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearest = enemy;
                    }
                }
                
                if (nearest) {
                    const angle = Math.atan2(nearest.y - this.y, nearest.x - this.x);
                    projectiles.push(new Projectile(this.x, this.y, angle, 10, 'player'));
                }
            }
            
            update() {
                this.life--;
                if (this.attackCooldown > 0) this.attackCooldown--;
                
                // Simple AI - follow nearest enemy
                let nearest = null;
                let nearestDist = Infinity;
                for (const enemy of currentRoom.enemies) {
                    const dist = Math.sqrt((enemy.x - this.x)**2 + (enemy.y - this.y)**2);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearest = enemy;
                    }
                }
                
                if (nearest && nearestDist < 300) {
                    const dx = nearest.x - this.x;
                    this.facing = dx > 0 ? 1 : -1;
                    this.vx = this.facing * 3;
                    
                    if (nearestDist < 100 && this.attackCooldown <= 0) {
                        this.mimicMeleeAttack();
                    }
                } else {
                    this.vx *= 0.9;
                }
                
                // Physics
                this.vy += this.gravity;
                this.x += this.vx;
                this.y += this.vy;
                
                // Platform collision
                this.onGround = false;
                for (const platform of currentRoom.platforms) {
                    if (this.x + this.width / 2 > platform.x &&
                        this.x - this.width / 2 < platform.x + platform.width &&
                        this.y + this.height / 2 > platform.y &&
                        this.y + this.height / 2 < platform.y + 20 &&
                        this.vy >= 0) {
                        this.y = platform.y - this.height / 2;
                        this.vy = 0;
                        this.onGround = true;
                    }
                }
                
                if (this.y > canvas.height - 50 - this.height / 2) {
                    this.y = canvas.height - 50 - this.height / 2;
                    this.vy = 0;
                    this.onGround = true;
                }
                
                return this.life > 0;
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.facing, 1);
                ctx.globalAlpha = 0.6;
                
                // Shadow assassin appearance
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                
                ctx.fillStyle = '#0a0a0a';
                ctx.beginPath();
                ctx.arc(0, -this.height / 2 + 6, 10, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(2, -8, 3, 2);
                
                ctx.globalAlpha = 1;
                ctx.restore();
            }
        }

        // Player class
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 24;
                this.height = 32;
                this.vx = 0;
                this.vy = 0;
                this.speed = 5;
                this.jumpPower = 13;
                this.gravity = 0.6;
                this.onGround = false;
                this.health = 150;
                this.maxHealth = 150;
                this.facing = 1;
                
                // Combat
                this.attacking = false;
                this.attackFrame = 0;
                this.attackCooldown = 0;
                this.attackDamage = 25;
                this.attackRange = 50;
                
                // Dash
                this.dashing = false;
                this.dashFrame = 0;
                this.dashCooldown = 0;
                this.dashSpeed = 15;
                
                // Ranged with directional aiming
                this.rangedCooldown = 0;
                this.aimDirection = { x: 1, y: 0 };
                
                // Upgrades
                this.upgrades = {
                    // Basic stats
                    maxHealth: 0, damage: 0, attackSpeed: 0, speed: 0, critChance: 0, critDamage: 0,
                    // Combat
                    multishot: 0, rapidFire: 0, piercing: 0, explosiveKnives: 0, ricochet: 0, magneticKnives: 0,
                    // Defense
                    lifesteal: 0, thorns: 0, bloodArmor: 0, lastStand: 0, ironSkin: 0, evasion: 0,
                    // Mobility
                    dashAttack: 0, ghostWalk: 0, shadowStep: 0, doubleJump: 0, airDash: 0, swiftness: 0,
                    // Effects
                    poisonDagger: 0, frozenTouch: 0, chainLightning: 0, vampiricAura: 0, bloodRage: 0,
                    // Special abilities
                    shadowClone: 0, timeSlowOnKill: 0, berserker: 0, executeThreshold: 0, backstab: 0,
                    frostNova: 0, knifeStorm: 0, vortex: 0, armorPierce: 0, necromancy: 0, flurry: 0,
                    // NEW UPGRADES
                    lifeLink: 0, deathMark: 0, voidWalk: 0, soulHarvest: 0, reflection: 0,
                    arcaneShield: 0, regeneration: 0, multiStrike: 0, bladeDance: 0, berserkerRage: 0,
                    assassination: 0, execution: 0, rage: 0, berserk: 0, whirlwind: 0,
                    teleportStrike: 0, shadowBurst: 0, deathWave: 0, criticalMass: 0, bloodShield: 0,
                    phantomStrike: 0, timeWarp: 0, meteorStrike: 0, phaseShift: 0, divineIntervention: 0,
                    bloodPact: 0, dimensionalRift: 0, soulReaper: 0
                };
                this.usedLastStand = false;
                this.bloodRageStacks = 0;
                this.shield = 0;
                this.hasDoubleJumped = false;
                
                // Special ability slots
                this.special1 = null;
                this.special2 = null;
                this.special1Cooldown = 0;
                this.special2Cooldown = 0;
                
                // Ability effects
                this.invincible = false;
                this.damageMultiplier = 1;
                
                // Animation
                this.animFrame = 0;
                this.animCounter = 0;
                
                // NEW: Status effect tracking
                this.poisonedEnemies = new Set();
                this.frozenEnemies = new Set();
                this.markedEnemies = new Set();
                this.regenTimer = 0;
            }

            attack() {
                if (this.attackCooldown <= 0 && !this.attacking && !this.dashing) {
                    this.attacking = true;
                    this.attackFrame = 0;
                    
                    const baseAttackSpeed = 30;
                    const attackSpeedMultiplier = 1 + (this.upgrades.attackSpeed * 0.15);
                    this.attackCooldown = Math.floor(baseAttackSpeed / attackSpeedMultiplier);
                    
                    // Calculate attack direction based on WASD keys (same as knife throwing)
                    let dirX = 0;
                    let dirY = 0;
                    
                    if (keys['w'] || keys['arrowup']) dirY = -1;
                    if (keys['s'] || keys['arrowdown']) dirY = 1;
                    if (keys['a'] || keys['arrowleft']) dirX = -1;
                    if (keys['d'] || keys['arrowright']) dirX = 1;
                    
                    // If no direction key pressed, use facing direction
                    if (dirX === 0 && dirY === 0) {
                        dirX = this.facing;
                    }
                    
                    // Normalize direction
                    const magnitude = Math.sqrt(dirX * dirX + dirY * dirY);
                    if (magnitude > 0) {
                        dirX /= magnitude;
                        dirY /= magnitude;
                    }
                    
                    const attackAngle = Math.atan2(dirY, dirX);
                    
                    // Store attack direction for animation
                    this.attackDirection = attackAngle;
                    
                    // Multi-strike
                    const strikes = 1 + (this.upgrades.multiStrike || 0);
                    
                    for (let s = 0; s < strikes; s++) {
                        setTimeout(() => {
                            // Check for hits on enemies
                            const attackRange = 70;
                            const attackWidth = 45;
                            
                            // Calculate attack position in the attack direction
                            const attackX = this.x + dirX * attackRange;
                            const attackY = this.y + dirY * attackRange;
                            
                            // Check collision with enemies
                            for (let i = currentRoom.enemies.length - 1; i >= 0; i--) {
                                const enemy = currentRoom.enemies[i];
                                const dx = enemy.x - attackX;
                                const dy = enemy.y - attackY;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                
                                if (dist < attackWidth) {
                                    const baseDamage = this.attackDamage * (1 + this.upgrades.damage * 0.15);
                                    const damageMultiplier = this.damageMultiplier * (mythicMode ? 5 : 1);
                                    let finalDamage = baseDamage * damageMultiplier;
                                    
                                    // Critical hit
                                    const critChance = 0.1 + (this.upgrades.critChance * 0.05);
                                    if (Math.random() < critChance) {
                                        const critDamage = 2 + (this.upgrades.critDamage * 0.3);
                                        finalDamage *= critDamage;
                                        
                                        // Crit particles
                                        for (let j = 0; j < 20; j++) {
                                            particles.push(new Particle(
                                                enemy.x, enemy.y, '#ffff00',
                                                (Math.random() - 0.5) * 10,
                                                (Math.random() - 0.5) * 10,
                                                30
                                            ));
                                        }
                                    }
                                    
                                    // Apply damage
                                    enemy.health -= finalDamage;
                                    
                                    // Lifesteal
                                    if (this.upgrades.lifesteal > 0) {
                                        this.health = Math.min(this.maxHealth, this.health + this.upgrades.lifesteal * 2);
                                    }
                                    
                                    // Check if enemy died
                                    if (enemy.health <= 0) {
                                        // Soul Harvest
                                        if (this.upgrades.soulHarvest > 0) {
                                            this.health = Math.min(this.maxHealth, this.health + this.upgrades.soulHarvest * 3);
                                        }
                                        
                                        // Death particles
                                        for (let j = 0; j < 30; j++) {
                                            particles.push(new Particle(
                                                enemy.x, enemy.y, '#ff0000',
                                                (Math.random() - 0.5) * 12,
                                                (Math.random() - 0.5) * 12,
                                                40
                                            ));
                                        }
                                        
                                        currentRoom.enemies.splice(i, 1);
                                    } else {
                                        // Damage particles
                                        for (let j = 0; j < 15; j++) {
                                            particles.push(new Particle(
                                                enemy.x, enemy.y, '#ff0000',
                                                (Math.random() - 0.5) * 8,
                                                (Math.random() - 0.5) * 8,
                                                25
                                            ));
                                        }
                                    }
                                }
                            }
                            
                            // Check collision with boss
                            if (currentRoom.boss && currentRoom.boss.health > 0) {
                                const dx = currentRoom.boss.x - attackX;
                                const dy = currentRoom.boss.y - attackY;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                
                                if (dist < attackWidth + 25) {
                                    const baseDamage = this.attackDamage * (1 + this.upgrades.damage * 0.15);
                                    const damageMultiplier = this.damageMultiplier * (mythicMode ? 5 : 1);
                                    let finalDamage = baseDamage * damageMultiplier;
                                    
                                    // Critical hit
                                    const critChance = 0.1 + (this.upgrades.critChance * 0.05);
                                    if (Math.random() < critChance) {
                                        const critDamage = 2 + (this.upgrades.critDamage * 0.3);
                                        finalDamage *= critDamage;
                                        
                                        // Crit particles
                                        for (let j = 0; j < 20; j++) {
                                            particles.push(new Particle(
                                                currentRoom.boss.x, currentRoom.boss.y, '#ffff00',
                                                (Math.random() - 0.5) * 10,
                                                (Math.random() - 0.5) * 10,
                                                30
                                            ));
                                        }
                                    }
                                    
                                    currentRoom.boss.health -= finalDamage;
                                    currentRoom.boss.health = Math.max(0, currentRoom.boss.health);
                                    
                                    // Boss damage particles
                                    for (let j = 0; j < 20; j++) {
                                        particles.push(new Particle(
                                            currentRoom.boss.x, currentRoom.boss.y, currentRoom.boss.color,
                                            (Math.random() - 0.5) * 10,
                                            (Math.random() - 0.5) * 10,
                                            35
                                        ));
                                    }
                                    
                                    // Lifesteal
                                    if (this.upgrades.lifesteal > 0) {
                                        this.health = Math.min(this.maxHealth, this.health + this.upgrades.lifesteal * 2);
                                    }
                                }
                            }
                            
                            // Trigger clone attacks
                            for (const clone of shadowClones) {
                                clone.mimicMeleeAttack();
                            }
                            
                            // Attack particles in the attack direction
                            for (let i = 0; i < 15; i++) {
                                const angle = attackAngle + (Math.random() - 0.5) * Math.PI * 0.5;
                                const speed = Math.random() * 5 + 3;
                                particles.push(new Particle(
                                    attackX,
                                    attackY,
                                    Math.random() > 0.5 ? '#1a1a1a' : '#4a4a4a',
                                    Math.cos(angle) * speed,
                                    Math.sin(angle) * speed,
                                    20 + Math.random() * 10
                                ));
                            }
                            
                            // Whirlwind
                            if (this.upgrades.whirlwind > 0) {
                                const bladeCount = 8 + this.upgrades.whirlwind * 4;
                                for (let i = 0; i < bladeCount; i++) {
                                    const angle = (Math.PI * 2 / bladeCount) * i;
                                    projectiles.push(new Projectile(
                                        this.x,
                                        this.y,
                                        angle,
                                        8,
                                        'player'
                                    ));
                                }
                            }
                            
                            // Shadow Burst
                            if (this.upgrades.shadowBurst > 0 && Math.random() < 0.25) {
                                const burstCount = 12;
                                for (let i = 0; i < burstCount; i++) {
                                    const angle = (Math.PI * 2 / burstCount) * i;
                                    projectiles.push(new Projectile(
                                        this.x,
                                        this.y,
                                        angle,
                                        10,
                                        'player'
                                    ));
                                }
                            }
                        }, s * 100);
                    }
                    
                    setTimeout(() => {
                        this.attacking = false;
                        this.attackDirection = null;
                    }, 150);
                }
            }

            dash() {
                if (this.dashCooldown <= 0 && !this.dashing) {
                    this.dashing = true;
                    this.dashFrame = 0;
                    this.dashCooldown = 60 - (this.upgrades.shadowStep * 10);
                    this.vy = 0;
                    
                    // Shadow clone on dash
                    if (this.upgrades.shadowClone > 0 && Math.random() < 0.4) {
                        shadowClones.push(new ShadowClone(this.x, this.y));
                    }
                    
                    // Void Walk damage
                    if (this.upgrades.voidWalk > 0) {
                        for (const enemy of currentRoom.enemies) {
                            const dist = Math.sqrt((enemy.x - this.x)**2 + (enemy.y - this.y)**2);
                            if (dist < 100) {
                                const damage = this.attackDamage * (1 + this.upgrades.damage * 0.15) * 0.8;
                                enemy.takeDamage(damage);
                            }
                        }
                    }
                }
            }

            shootRanged() {
                if (this.rangedCooldown <= 0) {
                    // Calculate direction based on WASD keys
                    let dirX = 0;
                    let dirY = 0;
                    
                    if (keys['w'] || keys['arrowup']) dirY = -1;
                    if (keys['s'] || keys['arrowdown']) dirY = 1;
                    if (keys['a'] || keys['arrowleft']) dirX = -1;
                    if (keys['d'] || keys['arrowright']) dirX = 1;
                    
                    // If no direction key pressed, use facing direction
                    if (dirX === 0 && dirY === 0) {
                        dirX = this.facing;
                    }
                    
                    // Normalize direction
                    const magnitude = Math.sqrt(dirX * dirX + dirY * dirY);
                    if (magnitude > 0) {
                        dirX /= magnitude;
                        dirY /= magnitude;
                    }
                    
                    const angle = Math.atan2(dirY, dirX);
                    const cooldown = Math.max(5, 20 - this.upgrades.rapidFire * 3);
                    const knifeCount = 1 + this.upgrades.multishot;
                    const spreadAngle = 0.3;
                    
                    // Spawn knives ahead of player in the direction they're shooting
                    const spawnDistance = 25;
                    const spawnX = this.x + Math.cos(angle) * spawnDistance;
                    const spawnY = this.y + Math.sin(angle) * spawnDistance;
                    
                    for (let i = 0; i < knifeCount; i++) {
                        const offset = (i - (knifeCount - 1) / 2) * spreadAngle;
                        const proj = new Projectile(
                            spawnX,
                            spawnY,
                            angle + offset,
                            12,
                            'player'
                        );
                        proj.explosive = this.upgrades.explosiveKnives > 0;
                        projectiles.push(proj);
                    }
                    
                    this.rangedCooldown = cooldown;
                    
                    // Trigger clone ranged attacks
                    for (const clone of shadowClones) {
                        clone.mimicRangedAttack();
                    }
                    
                    // Muzzle flash at spawn position
                    for (let i = 0; i < 10; i++) {
                        particles.push(new Particle(
                            spawnX,
                            spawnY,
                            '#1a1a1a',
                            (Math.random() - 0.5) * 4 + Math.cos(angle) * 3,
                            (Math.random() - 0.5) * 4 + Math.sin(angle) * 3,
                            15
                        ));
                    }
                }
            }

            useSpecial1() {
                if (this.special1 && this.special1Cooldown <= 0) {
                    const cooldown = 300;
                    this.special1Cooldown = cooldown;
                    this.executeSpecialAbility(this.special1);
                }
            }

            useSpecial2() {
                if (this.special2 && this.special2Cooldown <= 0) {
                    const cooldown = 300;
                    this.special2Cooldown = cooldown;
                    this.executeSpecialAbility(this.special2);
                }
            }
            
            executeSpecialAbility(abilityName) {
                switch(abilityName) {
                    case 'shadowClone':
                        shadowClones.push(new ShadowClone(this.x, this.y));
                        for (let i = 0; i < 30; i++) {
                            particles.push(new Particle(
                                this.x, this.y, '#2a2a2a',
                                (Math.random() - 0.5) * 10,
                                (Math.random() - 0.5) * 10,
                                50
                            ));
                        }
                        break;
                        
                    case 'fireStorm':
                        for (let i = 0; i < 12; i++) {
                            setTimeout(() => {
                                const x = this.x + (Math.random() - 0.5) * 200;
                                projectiles.push(new Projectile(x, 50, Math.PI / 2, 8, 'player'));
                            }, i * 100);
                        }
                        break;
                        
                    case 'bladeDance':
                        for (let i = 0; i < 16; i++) {
                            const angle = (Math.PI * 2 / 16) * i;
                            projectiles.push(new Projectile(this.x, this.y, angle, 12, 'player'));
                        }
                        break;
                        
                    case 'bladeDance':
                        for (let i = 0; i < 16; i++) {
                            const angle = (Math.PI * 2 / 16) * i;
                            projectiles.push(new Projectile(this.x, this.y, angle, 12, 'player'));
                        }
                        break;
                        
                    case 'timeStop':
                        for (const enemy of currentRoom.enemies) {
                            enemy.frozen = true;
                            setTimeout(() => enemy.frozen = false, 3000);
                        }
                        if (currentRoom.boss) {
                            currentRoom.boss.frozen = true;
                            setTimeout(() => currentRoom.boss.frozen = false, 3000);
                        }
                        break;
                        
                    case 'phantomStrike':
                        let nearest = null;
                        let nearestDist = Infinity;
                        for (const enemy of currentRoom.enemies) {
                            const dist = Math.sqrt((enemy.x - this.x)**2 + (enemy.y - this.y)**2);
                            if (dist < nearestDist && dist < 500) {
                                nearestDist = dist;
                                nearest = enemy;
                            }
                        }
                        if (nearest) {
                            this.x = nearest.x - nearest.facing * 50;
                            this.y = nearest.y;
                            nearest.takeDamage(100);
                        }
                        break;
                        
                    case 'omniSlash':
                        for (const enemy of currentRoom.enemies) {
                            enemy.takeDamage(80);
                        }
                        if (currentRoom.boss) currentRoom.boss.takeDamage(80);
                        break;
                        
                    case 'godMode':
                        this.invincible = true;
                        this.damageMultiplier = 10;
                        setTimeout(() => {
                            this.invincible = false;
                            this.damageMultiplier = 1;
                        }, 5000);
                        break;
                        
                    case 'armageddon':
                        for (let i = 0; i < 30; i++) {
                            setTimeout(() => {
                                const x = Math.random() * canvas.width;
                                projectiles.push(new Projectile(x, 0, Math.PI / 2, 15, 'player'));
                            }, i * 50);
                        }
                        break;
                        
                    case 'infinityEdge':
                        for (let i = 0; i < 20; i++) {
                            setTimeout(() => {
                                const angle = Math.random() * Math.PI * 2;
                                const proj = new Projectile(this.x, this.y, angle, 10, 'player');
                                proj.homing = true;
                                projectiles.push(proj);
                            }, i * 50);
                        }
                        break;
                        
                    case 'divineShield':
                        this.invincible = true;
                        setTimeout(() => {
                            this.invincible = false;
                        }, 4000);
                        break;
                        
                    case 'stormCaller':
                        for (const enemy of currentRoom.enemies) {
                            enemy.takeDamage(100);
                            for (let i = 0; i < 20; i++) {
                                particles.push(new Particle(
                                    enemy.x, enemy.y, '#ffff00',
                                    (Math.random() - 0.5) * 10,
                                    (Math.random() - 0.5) * 10,
                                    30
                                ));
                            }
                        }
                        if (currentRoom.boss) {
                            currentRoom.boss.takeDamage(100);
                        }
                        break;
                        
                    case 'timestrike':
                        for (const enemy of currentRoom.enemies) {
                            enemy.frozen = true;
                            setTimeout(() => enemy.frozen = false, 5000);
                        }
                        if (currentRoom.boss) {
                            currentRoom.boss.frozen = true;
                            setTimeout(() => currentRoom.boss.frozen = false, 5000);
                        }
                        break;
                        
                    case 'soulReaper':
                        for (const enemy of currentRoom.enemies) {
                            enemy.health = 0;
                            for (let i = 0; i < 30; i++) {
                                particles.push(new Particle(
                                    enemy.x, enemy.y, '#8b008b',
                                    (Math.random() - 0.5) * 15,
                                    (Math.random() - 0.5) * 15,
                                    40
                                ));
                            }
                        }
                        break;
                        
                    case 'ragnarok':
                        for (const enemy of currentRoom.enemies) {
                            enemy.takeDamage(200);
                        }
                        if (currentRoom.boss) {
                            currentRoom.boss.takeDamage(200);
                        }
                        for (let i = 0; i < 200; i++) {
                            particles.push(new Particle(
                                Math.random() * canvas.width,
                                Math.random() * canvas.height,
                                ['#ff0000', '#ff8800', '#ffff00'][Math.floor(Math.random() * 3)],
                                (Math.random() - 0.5) * 20,
                                (Math.random() - 0.5) * 20,
                                50
                            ));
                        }
                        break;
                }
            }

            update() {
                // Cooldowns
                if (this.attackCooldown > 0) this.attackCooldown--;
                if (this.dashCooldown > 0) this.dashCooldown--;
                if (this.rangedCooldown > 0) this.rangedCooldown--;
                if (this.special1Cooldown > 0) this.special1Cooldown--;
                if (this.special2Cooldown > 0) this.special2Cooldown--;
                
                // Regeneration
                if (this.upgrades.regeneration > 0) {
                    this.regenTimer++;
                    if (this.regenTimer >= 60) {
                        this.health = Math.min(this.maxHealth, this.health + this.upgrades.regeneration * 0.5);
                        this.regenTimer = 0;
                    }
                }
                
                // Vampiric Aura
                if (this.upgrades.vampiricAura > 0) {
                    for (const enemy of currentRoom.enemies) {
                        const dist = Math.sqrt((enemy.x - this.x)**2 + (enemy.y - this.y)**2);
                        if (dist < 150) {
                            if (Math.random() < 0.02) {
                                this.health = Math.min(this.maxHealth, this.health + 1);
                            }
                        }
                    }
                }
                
                // Dash movement
                if (this.dashing) {
                    this.dashFrame++;
                    this.vx = this.facing * this.dashSpeed;
                    
                    // Dash trail
                    for (let i = 0; i < 3; i++) {
                        particles.push(new Particle(
                            this.x, this.y,
                            '#1a1a1a',
                            (Math.random() - 0.5) * 2,
                            (Math.random() - 0.5) * 2,
                            20
                        ));
                    }
                    
                    if (this.dashFrame > 10) {
                        this.dashing = false;
                        this.dashFrame = 0;
                    }
                }
                
                // Physics
                this.vy += this.gravity;
                this.x += this.vx;
                this.y += this.vy;
                
                // Platform collision
                this.onGround = false;
                for (const platform of currentRoom.platforms) {
                    if (this.x + this.width / 2 > platform.x &&
                        this.x - this.width / 2 < platform.x + platform.width &&
                        this.y + this.height / 2 > platform.y &&
                        this.y + this.height / 2 < platform.y + 20 &&
                        this.vy >= 0) {
                        this.y = platform.y - this.height / 2;
                        this.vy = 0;
                        this.onGround = true;
                        this.hasDoubleJumped = false;
                    }
                }
                
                // Ground collision
                if (this.y > canvas.height - 50 - this.height / 2) {
                    this.y = canvas.height - 50 - this.height / 2;
                    this.vy = 0;
                    this.onGround = true;
                    this.hasDoubleJumped = false;
                }
                
                // Bounds
                if (this.x < this.width / 2) this.x = this.width / 2;
                if (this.x > canvas.width - this.width / 2) this.x = canvas.width - this.width / 2;
                
                // Animation
                this.animCounter++;
                if (this.animCounter > 8) {
                    this.animFrame = (this.animFrame + 1) % 4;
                    this.animCounter = 0;
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.facing, 1);
                
                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.ellipse(0, this.height / 2 + 5, this.width / 2, 5, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Dash effect
                if (this.dashing) {
                    ctx.globalAlpha = 0.5;
                    for (let i = 0; i < 3; i++) {
                        ctx.fillStyle = '#1a1a1a';
                        ctx.fillRect(-this.width / 2 - i * 10, -this.height / 2, this.width, this.height);
                    }
                    ctx.globalAlpha = 1;
                }
                
                // Mythic mode aura
                if (mythicMode) {
                    const mythicGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.width * 2);
                    mythicGradient.addColorStop(0, 'rgba(255, 0, 255, 0.3)');
                    mythicGradient.addColorStop(1, 'rgba(255, 0, 255, 0)');
                    ctx.fillStyle = mythicGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width * 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Body (assassin in dark cloak)
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                
                // Hood
                ctx.fillStyle = '#0a0a0a';
                ctx.beginPath();
                ctx.arc(0, -this.height / 2 + 6, 10, 0, Math.PI * 2);
                ctx.fill();
                
                // Face shadow
                ctx.fillStyle = '#2a2a2a';
                ctx.fillRect(-this.width / 2 + 6, -this.height / 2 + 8, this.width - 12, 8);
                
                // Eyes (glowing)
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(2, -8, 3, 2);
                
                // Cloak
                ctx.fillStyle = '#0a0a0a';
                ctx.beginPath();
                ctx.moveTo(-this.width / 2, -this.height / 2 + 12);
                ctx.lineTo(-this.width / 2 - 6, -this.height / 2 + 20 + Math.sin(Date.now() / 100) * 3);
                ctx.lineTo(-this.width / 2 - 4, this.height / 2);
                ctx.lineTo(-this.width / 2, this.height / 2);
                ctx.fill();
                
                // Belt
                ctx.fillStyle = '#4a2511';
                ctx.fillRect(-this.width / 2, 0, this.width, 4);
                
                // Weapon (dagger)
                if (this.attacking && this.attackDirection !== null) {
                    ctx.save();
                    ctx.rotate(this.attackDirection);
                    
                    // Dagger blade
                    ctx.fillStyle = '#c0c0c0';
                    ctx.beginPath();
                    ctx.moveTo(40, 0);
                    ctx.lineTo(10, -3);
                    ctx.lineTo(10, 3);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Blade shine
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.moveTo(35, 0);
                    ctx.lineTo(20, -1);
                    ctx.lineTo(20, 1);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Handle
                    ctx.fillStyle = '#8b4513';
                    ctx.fillRect(8, -2, 8, 4);
                    
                    // Pommel
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.arc(8, 0, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                }
                
                ctx.restore();
            }

            takeDamage(amount) {
                if (this.invincible) return;
                
                // Evasion
                if (this.upgrades.evasion > 0 && Math.random() < this.upgrades.evasion * 0.1) {
                    return;
                }
                
                // Blood Shield
                if (this.upgrades.bloodShield > 0 && Math.random() < 0.15 * this.upgrades.bloodShield) {
                    amount *= 0.5;
                }
                
                // Iron Skin
                if (this.upgrades.ironSkin > 0) {
                    amount *= (1 - this.upgrades.ironSkin * 0.1);
                }
                
                // Thorns
                if (this.upgrades.thorns > 0) {
                    for (const enemy of currentRoom.enemies) {
                        const dx = enemy.x - this.x;
                        const dy = enemy.y - this.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 100) {
                            enemy.takeDamage(amount * 0.3 * this.upgrades.thorns);
                        }
                    }
                }
                
                // Reflection
                if (this.upgrades.reflection > 0) {
                    for (const enemy of currentRoom.enemies) {
                        const dist = Math.sqrt((enemy.x - this.x)**2 + (enemy.y - this.y)**2);
                        if (dist < 200) {
                            enemy.health -= amount * this.upgrades.reflection * 0.3;
                        }
                    }
                }
                
                this.health -= amount;
                this.health = Math.max(0, Math.min(this.health, this.maxHealth));
                
                // Damage particles
                for (let i = 0; i < 20; i++) {
                    particles.push(new Particle(
                        this.x,
                        this.y,
                        '#ff0066',
                        (Math.random() - 0.5) * 8,
                        (Math.random() - 0.5) * 8,
                        30
                    ));
                }
            }
        }

        // Enemy class (keeping original visuals)
        class Enemy {
            constructor(x, y, type = 'basic') {
                this.x = x;
                this.y = y;
                this.width = 28;
                this.height = 32;
                this.vx = 0;
                this.vy = 0;
                this.gravity = 0.6;
                
                const enemyStats = {
                    'basic': { health: 35, speed: 2, color: '#808080', damage: 8 },
                    'advanced': { health: 40, speed: 2.5, color: '#8b4513', damage: 10 },
                    'heavy': { health: 70, speed: 1, color: '#4a4a4a', damage: 12 },
                    'assassin': { health: 25, speed: 4, color: '#1a1a1a', damage: 6 },
                    'mage': { health: 25, speed: 1.5, color: '#4b0082', damage: 6 }
                };
                
                const stats = enemyStats[type] || enemyStats['basic'];
                this.health = stats.health;
                this.maxHealth = stats.health;
                this.speed = stats.speed;
                this.color = stats.color;
                this.baseDamage = stats.damage;
                this.type = type;
                this.facing = -1;
                this.onGround = false;
                
                this.attackCooldown = 0;
                this.shootCooldown = 0;
                this.teleportCooldown = 0;
                this.state = 'idle';
                this.stateTimer = 0;
                this.frozen = false;
                
                this.animFrame = 0;
                this.animCounter = 0;
            }

            update() {
                if (this.frozen) {
                    this.vy += this.gravity;
                    this.y += this.vy;
                    if (this.y > canvas.height - 50 - this.height / 2) {
                        this.y = canvas.height - 50 - this.height / 2;
                        this.vy = 0;
                    }
                    return;
                }
                
                this.vy += this.gravity;
                this.x += this.vx;
                this.y += this.vy;
                
                // Platform collision
                this.onGround = false;
                for (const platform of currentRoom.platforms) {
                    if (this.x + this.width / 2 > platform.x &&
                        this.x - this.width / 2 < platform.x + platform.width &&
                        this.y + this.height / 2 > platform.y &&
                        this.y + this.height / 2 < platform.y + 20 &&
                        this.vy >= 0) {
                        this.y = platform.y - this.height / 2;
                        this.vy = 0;
                        this.onGround = true;
                    }
                }
                
                if (this.y > canvas.height - 50 - this.height / 2) {
                    this.y = canvas.height - 50 - this.height / 2;
                    this.vy = 0;
                    this.onGround = true;
                }
                
                // AI
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                this.facing = dx > 0 ? 1 : -1;
                
                if (this.attackCooldown > 0) this.attackCooldown--;
                if (this.shootCooldown > 0) this.shootCooldown--;
                if (this.teleportCooldown > 0) this.teleportCooldown--;
                
                switch(this.type) {
                    case 'basic':
                    case 'heavy':
                        // Melee enemies
                        if (dist > 50) {
                            this.vx = this.facing * this.speed;
                        } else {
                            this.vx = 0;
                            if (this.attackCooldown <= 0) {
                                this.attackCooldown = 60;
                                player.takeDamage(this.baseDamage);
                            }
                        }
                        break;
                        
                    case 'advanced':
                        // Archer - keep distance and shoot
                        if (dist < 100) {
                            this.vx = -this.facing * this.speed;
                        } else if (dist > 300) {
                            this.vx = this.facing * this.speed;
                        } else {
                            this.vx *= 0.9;
                        }
                        
                        if (this.shootCooldown <= 0 && dist < 400) {
                            this.shootCooldown = 90;
                            const angle = Math.atan2(dy, dx);
                            projectiles.push(new Projectile(this.x, this.y, angle, 8, 'enemy'));
                        }
                        break;
                        
                    case 'assassin':
                        // Fast melee
                        if (dist > 40) {
                            this.vx = this.facing * this.speed;
                        } else {
                            this.vx = 0;
                            if (this.attackCooldown <= 0) {
                                this.attackCooldown = 45;
                                player.takeDamage(this.baseDamage);
                            }
                        }
                        break;
                        
                    case 'mage':
                        // Teleporting ranged
                        if (dist > 150 && dist < 350) {
                            this.vx *= 0.95;
                            
                            if (this.shootCooldown <= 0) {
                                this.shootCooldown = 100;
                                const angle = Math.atan2(dy, dx);
                                for (let i = -1; i <= 1; i++) {
                                    projectiles.push(new Projectile(
                                        this.x,
                                        this.y,
                                        angle + i * 0.2,
                                        8,
                                        'enemy'
                                    ));
                                }
                            }
                        } else if (dist < 150 && this.teleportCooldown <= 0) {
                            this.teleportCooldown = 200;
                            const teleAngle = Math.random() * Math.PI * 2;
                            let newX = this.x + Math.cos(teleAngle) * 150;
                            let newY = this.y + Math.sin(teleAngle) * 100;
                            
                            newX = Math.max(50, Math.min(canvas.width - 50, newX));
                            newY = Math.max(100, Math.min(canvas.height - 100, newY));
                            
                            this.x = newX;
                            this.y = newY;
                            
                            for (let i = 0; i < 20; i++) {
                                particles.push(new Particle(
                                    this.x, this.y, '#4b0082',
                                    (Math.random() - 0.5) * 10,
                                    (Math.random() - 0.5) * 10,
                                    30
                                ));
                            }
                        } else if (dist > 400) {
                            this.vx = this.facing * this.speed * 0.7;
                        } else {
                            this.vx *= 0.9;
                        }
                        break;
                }
                
                // Animation
                this.animCounter++;
                if (this.animCounter > 10) {
                    this.animFrame = (this.animFrame + 1) % 3;
                    this.animCounter = 0;
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.facing, 1);
                
                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.ellipse(0, this.height / 2 + 5, this.width / 2, 5, 0, 0, Math.PI * 2);
                ctx.fill();
                
                switch(this.type) {
                    case 'basic':
                        // Sword Knight
                        ctx.fillStyle = '#808080';
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        ctx.fillStyle = '#a0a0a0';
                        ctx.fillRect(-this.width / 2 + 4, -this.height / 2 + 4, this.width - 8, this.height / 2);
                        
                        ctx.fillStyle = '#696969';
                        ctx.beginPath();
                        ctx.arc(0, -this.height / 2 + 6, 10, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = '#000000';
                        ctx.fillRect(-6, -this.height / 2 + 4, 12, 3);
                        
                        // Shield
                        ctx.fillStyle = '#8b0000';
                        ctx.beginPath();
                        ctx.arc(-8, 0, 8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#ffd700';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        // Sword
                        ctx.strokeStyle = '#c0c0c0';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(8, -4);
                        ctx.lineTo(8, -16);
                        ctx.stroke();
                        
                        ctx.fillStyle = '#8b4513';
                        ctx.fillRect(6, -6, 4, 6);
                        break;
                        
                    case 'advanced':
                        // Archer Knight
                        ctx.fillStyle = '#8b4513';
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        ctx.fillStyle = '#654321';
                        ctx.fillRect(-this.width / 2 + 4, -this.height / 2 + 8, this.width - 8, this.height - 12);
                        
                        ctx.fillStyle = '#a0a0a0';
                        ctx.beginPath();
                        ctx.arc(0, -this.height / 2 + 6, 9, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = '#ffe0bd';
                        ctx.fillRect(-4, -this.height / 2 + 4, 8, 6);
                        
                        ctx.fillStyle = '#000000';
                        ctx.fillRect(-3, -this.height / 2 + 5, 2, 2);
                        ctx.fillRect(1, -this.height / 2 + 5, 2, 2);
                        
                        // Bow
                        ctx.strokeStyle = '#8b4513';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(10, 0, 12, -Math.PI/3, Math.PI/3);
                        ctx.stroke();
                        
                        ctx.strokeStyle = '#d3d3d3';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(10 + Math.cos(-Math.PI/3) * 12, Math.sin(-Math.PI/3) * 12);
                        ctx.lineTo(10 + Math.cos(Math.PI/3) * 12, Math.sin(Math.PI/3) * 12);
                        ctx.stroke();
                        
                        ctx.fillStyle = '#654321';
                        ctx.fillRect(-10, this.height / 4, 4, 8);
                        break;
                        
                    case 'heavy':
                        // Tank
                        ctx.fillStyle = '#4a4a4a';
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        ctx.fillStyle = '#5a5a5a';
                        ctx.fillRect(-this.width / 2 + 2, -this.height / 2 + 2, this.width - 4, 8);
                        ctx.fillRect(-this.width / 2 + 2, 0, this.width - 4, 6);
                        
                        ctx.fillStyle = '#3a3a3a';
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, 10);
                        
                        // Spikes
                        ctx.fillStyle = '#8b4513';
                        for (let i = -1; i <= 1; i++) {
                            ctx.beginPath();
                            ctx.moveTo(i * 8, -this.height / 2);
                            ctx.lineTo(i * 8 - 3, -this.height / 2 - 6);
                            ctx.lineTo(i * 8 + 3, -this.height / 2 - 6);
                            ctx.fill();
                        }
                        
                        ctx.fillStyle = '#ff0000';
                        ctx.fillRect(-8, -this.height / 2 + 12, 16, 3);
                        
                        // Hammer
                        ctx.fillStyle = '#696969';
                        ctx.fillRect(8, -8, 4, 16);
                        ctx.fillRect(6, -12, 8, 8);
                        break;
                        
                    case 'assassin':
                        // Fast assassin
                        ctx.fillStyle = '#1a1a1a';
                        ctx.fillRect(-this.width / 2 + 4, -this.height / 2, this.width - 8, this.height);
                        
                        ctx.fillStyle = '#0a0a0a';
                        ctx.beginPath();
                        ctx.arc(0, -this.height / 2 + 4, 8, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = '#ff0000';
                        ctx.fillRect(-3, -this.height / 2 + 6, 2, 2);
                        ctx.fillRect(1, -this.height / 2 + 6, 2, 2);
                        
                        // Daggers
                        ctx.fillStyle = '#c0c0c0';
                        ctx.fillRect(8, -2, 8, 2);
                        ctx.fillRect(8, 2, 8, 2);
                        break;
                        
                    case 'mage':
                        // Mage
                        ctx.fillStyle = '#4b0082';
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        ctx.fillStyle = '#6a0dad';
                        ctx.fillRect(-this.width / 2 + 4, -this.height / 2 + 8, this.width - 8, this.height - 12);
                        
                        ctx.fillStyle = '#3a2a5a';
                        ctx.beginPath();
                        ctx.arc(0, -this.height / 2 + 4, 10, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Hat
                        ctx.fillStyle = '#2a1a4a';
                        ctx.beginPath();
                        ctx.moveTo(0, -this.height / 2 - 8);
                        ctx.lineTo(-8, -this.height / 2 + 4);
                        ctx.lineTo(8, -this.height / 2 + 4);
                        ctx.fill();
                        
                        // Staff
                        ctx.strokeStyle = '#8b4513';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(10, 0);
                        ctx.lineTo(10, -18);
                        ctx.stroke();
                        
                        ctx.fillStyle = '#9400d3';
                        ctx.beginPath();
                        ctx.arc(10, -20, 4, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                }
                
                ctx.restore();
                
                // Health bar
                const barWidth = this.width + 10;
                const barHeight = 4;
                const barY = this.y - this.height / 2 - 10;
                
                ctx.fillStyle = '#222';
                ctx.fillRect(this.x - barWidth / 2, barY, barWidth, barHeight);
                
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(this.x - barWidth / 2, barY, barWidth * (this.health / this.maxHealth), barHeight);
            }

            takeDamage(amount) {
                const baseDamage = player.attackDamage * (1 + player.upgrades.damage * 0.15);
                const damageMultiplier = player.damageMultiplier * (mythicMode ? 5 : 1);
                let finalDamage = amount * damageMultiplier;
                
                // Critical hit
                const critChance = 0.1 + (player.upgrades.critChance * 0.05);
                if (Math.random() < critChance) {
                    const critDamage = 2 + (player.upgrades.critDamage * 0.3);
                    finalDamage *= critDamage;
                    
                    // Critical Mass
                    if (player.upgrades.criticalMass > 0) {
                        for (let i = 0; i < 8; i++) {
                            const angle = (Math.PI * 2 / 8) * i;
                            projectiles.push(new Projectile(
                                this.x,
                                this.y,
                                angle,
                                6,
                                'player'
                            ));
                        }
                    }
                }
                
                // Death Mark bonus
                if (player.markedEnemies.has(this)) {
                    finalDamage *= 1.5;
                }
                
                // Berserker Rage bonus
                if (player.upgrades.berserkerRage > 0 && player.health < player.maxHealth * 0.3) {
                    finalDamage *= (1 + player.upgrades.berserkerRage * 0.15);
                }
                
                this.health -= finalDamage;
                this.health = Math.max(0, this.health);
                
                // Lifesteal
                if (player.upgrades.lifesteal > 0) {
                    player.health = Math.min(player.maxHealth, player.health + player.upgrades.lifesteal);
                }
                
                // Soul Harvest on kill
                if (this.health <= 0 && player.upgrades.soulHarvest > 0) {
                    player.health = Math.min(player.maxHealth, player.health + player.upgrades.soulHarvest * 3);
                }
                
                // Status effects
                if (player.upgrades.poisonDagger > 0) {
                    player.poisonedEnemies.add(this);
                }
                if (player.upgrades.frozenTouch > 0) {
                    player.frozenEnemies.add(this);
                    this.speed *= 0.5;
                }
                if (player.upgrades.deathMark > 0 && Math.random() < 0.3) {
                    player.markedEnemies.add(this);
                }
                
                // Damage particles
                for (let i = 0; i < 15; i++) {
                    particles.push(new Particle(
                        this.x,
                        this.y,
                        '#ff0000',
                        (Math.random() - 0.5) * 6,
                        (Math.random() - 0.5) * 6,
                        25
                    ));
                }
            }
        }

        // Boss class with UNIQUE ATTACK PATTERNS
        class Boss {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.width = 50;
                this.height = 60;
                this.vx = 0;
                this.vy = 0;
                this.gravity = 0.6;
                this.type = type;
                this.facing = -1;
                this.onGround = false;
                
                const bossStats = {
                    'Crimson Knight': { health: 400, speed: 3, color: '#8b0000', damage: 15 },
                    'Shadow Lord': { health: 350, speed: 4.5, color: '#2a2a2a', damage: 12 },
                    'Frost Warden': { health: 380, speed: 2.5, color: '#00bfff', damage: 14 },
                    'Flame Tyrant': { health: 360, speed: 3.5, color: '#ff4500', damage: 16 },
                    'Stone Golem': { health: 550, speed: 1.5, color: '#696969', damage: 20 },
                    'Toxic Assassin': { health: 320, speed: 5.5, color: '#228b22', damage: 12 },
                    'Thunder King': { health: 420, speed: 3.5, color: '#ffd700', damage: 18 },
                    'Necromancer': { health: 300, speed: 2.5, color: '#4b0082', damage: 14 },
                    'Blood Reaper': { health: 400, speed: 4, color: '#dc143c', damage: 16 },
                    'Void Walker': { health: 380, speed: 4.5, color: '#483d8b', damage: 15 }
                };
                
                const stats = bossStats[type];
                this.health = stats.health;
                this.maxHealth = stats.health;
                this.speed = stats.speed;
                this.color = stats.color;
                this.baseDamage = stats.damage;
                
                this.attackCooldown = 0;
                this.specialCooldown = 0;
                this.phase = 1;
                this.animFrame = 0;
                this.isBoss = true;
                this.frozen = false;
                
                // NEW: Attack pattern variables
                this.patternPhase = 0;
                this.patternTimer = 0;
                this.attackPattern = 0;
            }

            update() {
                if (this.frozen) {
                    this.vy += this.gravity;
                    this.y += this.vy;
                    if (this.y > canvas.height - 50 - this.height / 2) {
                        this.y = canvas.height - 50 - this.height / 2;
                        this.vy = 0;
                    }
                    return;
                }
                
                this.vy += this.gravity;
                this.x += this.vx;
                this.y += this.vy;
                
                // Platform collision
                this.onGround = false;
                for (const platform of currentRoom.platforms) {
                    if (this.x + this.width / 2 > platform.x &&
                        this.x - this.width / 2 < platform.x + platform.width &&
                        this.y + this.height / 2 > platform.y &&
                        this.y + this.height / 2 < platform.y + 20 &&
                        this.vy >= 0) {
                        this.y = platform.y - this.height / 2;
                        this.vy = 0;
                        this.onGround = true;
                    }
                }
                
                if (this.y > canvas.height - 50 - this.height / 2) {
                    this.y = canvas.height - 50 - this.height / 2;
                    this.vy = 0;
                    this.onGround = true;
                }
                
                // Phase transition at 50% HP
                if (this.health < this.maxHealth / 2 && this.phase === 1) {
                    this.phase = 2;
                    this.speed *= 1.4;
                    this.baseDamage *= 1.2;
                    
                    for (let i = 0; i < 80; i++) {
                        particles.push(new Particle(
                            this.x, this.y, this.color,
                            (Math.random() - 0.5) * 20,
                            (Math.random() - 0.5) * 20,
                            50
                        ));
                    }
                }
                
                // AI with UNIQUE ATTACK PATTERNS
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                this.facing = dx > 0 ? 1 : -1;
                
                if (this.attackCooldown > 0) this.attackCooldown--;
                if (this.specialCooldown > 0) this.specialCooldown--;
                
                this.patternTimer++;
                if (this.patternTimer > 300) {
                    this.patternTimer = 0;
                    this.attackPattern = (this.attackPattern + 1) % 3;
                }
                
                // Boss-specific attack patterns
                this.executeAttackPattern(dx, dy, dist);
                
                this.animFrame++;
            }
            
            executeAttackPattern(dx, dy, dist) {
                switch(this.type) {
                    case 'Crimson Knight':
                        if (this.attackPattern === 0) {
                            // Pattern 1: Shield bash charge
                            if (this.patternTimer % 120 === 0) {
                                this.vx = this.facing * this.speed * 3;
                                if (dist < 80) player.takeDamage(this.baseDamage * 1.5);
                            } else {
                                this.vx *= 0.95;
                            }
                        } else if (this.attackPattern === 1) {
                            // Pattern 2: Spinning sword projectiles
                            if (this.patternTimer % 60 === 0) {
                                for (let i = 0; i < 8; i++) {
                                    const angle = (Math.PI * 2 / 8) * i;
                                    projectiles.push(new Projectile(this.x, this.y, angle, 6, 'enemy'));
                                }
                            }
                            if (dist > 150) this.vx = this.facing * this.speed * 0.8;
                            else this.vx *= 0.9;
                        } else {
                            // Pattern 3: Ground slam waves
                            if (this.onGround && this.patternTimer % 100 === 0) {
                                for (let i = 1; i <= 3; i++) {
                                    setTimeout(() => {
                                        projectiles.push(new Projectile(this.x, this.y, 0, 6 + i, 'enemy'));
                                        projectiles.push(new Projectile(this.x, this.y, Math.PI, 6 + i, 'enemy'));
                                    }, i * 200);
                                }
                            }
                            if (dist < 200) this.vx = -this.facing * this.speed * 0.5;
                            else this.vx *= 0.9;
                        }
                        break;
                        
                    case 'Shadow Lord':
                        if (this.attackPattern === 0) {
                            // Pattern 1: Teleport behind player
                            if (this.patternTimer % 150 === 0) {
                                this.x = player.x - player.facing * 100;
                                this.y = player.y;
                                player.takeDamage(this.baseDamage);
                                
                                for (let i = 0; i < 30; i++) {
                                    particles.push(new Particle(
                                        this.x, this.y, '#2a2a2a',
                                        (Math.random() - 0.5) * 12,
                                        (Math.random() - 0.5) * 12,
                                        35
                                    ));
                                }
                            }
                        } else if (this.attackPattern === 1) {
                            // Pattern 2: Shadow clones that shoot
                            if (this.patternTimer === 50 || this.patternTimer === 150 || this.patternTimer === 250) {
                                const cloneX = Math.random() * canvas.width;
                                const cloneY = Math.random() * (canvas.height - 200) + 100;
                                
                                setTimeout(() => {
                                    const angle = Math.atan2(player.y - cloneY, player.x - cloneX);
                                    for (let i = -1; i <= 1; i++) {
                                        projectiles.push(new Projectile(cloneX, cloneY, angle + i * 0.3, 8, 'enemy'));
                                    }
                                }, 500);
                            }
                            if (dist > 200) this.vx = this.facing * this.speed;
                            else this.vx *= 0.9;
                        } else {
                            // Pattern 3: Rapid teleport strikes
                            if (this.patternTimer % 40 === 0) {
                                const angle = Math.random() * Math.PI * 2;
                                this.x = player.x + Math.cos(angle) * 150;
                                this.y = player.y + Math.sin(angle) * 100;
                            }
                            if (dist < 70) player.takeDamage(this.baseDamage);
                        }
                        break;
                        
                    case 'Frost Warden':
                        if (this.attackPattern === 0) {
                            // Pattern 1: Ice shard barrage
                            if (this.patternTimer % 40 === 0 && dist < 400) {
                                const angle = Math.atan2(dy, dx);
                                projectiles.push(new Projectile(this.x, this.y, angle, 9, 'enemy'));
                            }
                            this.vx = this.facing * this.speed * 0.7;
                        } else if (this.attackPattern === 1) {
                            // Pattern 2: Ice wave circle
                            if (this.patternTimer % 90 === 0) {
                                for (let i = 0; i < 12; i++) {
                                    const angle = (Math.PI * 2 / 12) * i + this.patternTimer * 0.01;
                                    projectiles.push(new Projectile(this.x, this.y, angle, 5, 'enemy'));
                                }
                            }
                            this.vx *= 0.95;
                        } else {
                            // Pattern 3: Freeze zone
                            if (dist < 150) {
                                player.speed = Math.max(2, player.speed * 0.8);
                            }
                            if (dist > 120) this.vx = this.facing * this.speed * 0.6;
                            else this.vx = -this.facing * this.speed * 0.4;
                        }
                        break;
                        
                    case 'Flame Tyrant':
                        if (this.attackPattern === 0) {
                            // Pattern 1: Fire breath
                            if (this.patternTimer % 30 === 0 && dist < 350) {
                                for (let i = -2; i <= 2; i++) {
                                    const angle = Math.atan2(dy, dx) + i * 0.15;
                                    projectiles.push(new Projectile(this.x, this.y, angle, 10, 'enemy'));
                                }
                            }
                            if (dist > 200) this.vx = this.facing * this.speed;
                            else this.vx *= 0.9;
                        } else if (this.attackPattern === 1) {
                            // Pattern 2: Fire pillars
                            if (this.patternTimer % 80 === 0) {
                                for (let i = 0; i < 5; i++) {
                                    const pillarX = 100 + i * 200;
                                    setTimeout(() => {
                                        projectiles.push(new Projectile(pillarX, 0, Math.PI / 2, 12, 'enemy'));
                                    }, i * 100);
                                }
                            }
                            this.vx *= 0.9;
                        } else {
                            // Pattern 3: Fire charge
                            if (this.patternTimer % 100 === 0) {
                                this.vx = this.facing * this.speed * 4;
                                if (dist < 90) player.takeDamage(this.baseDamage * 1.8);
                            } else {
                                this.vx *= 0.92;
                            }
                        }
                        break;
                        
                    case 'Stone Golem':
                        if (this.attackPattern === 0) {
                            // Pattern 1: Rock throw
                            if (this.patternTimer % 80 === 0) {
                                const angle = Math.atan2(dy, dx);
                                const proj = new Projectile(this.x, this.y, angle, 7, 'enemy');
                                proj.explosive = true;
                                projectiles.push(proj);
                            }
                            if (dist > 100) this.vx = this.facing * this.speed;
                            else this.vx *= 0.9;
                        } else if (this.attackPattern === 1) {
                            // Pattern 2: Earthquake stomp
                            if (this.onGround && this.patternTimer % 120 === 0) {
                                player.vy = -8;
                                if (player.onGround) player.takeDamage(this.baseDamage);
                            }
                            if (dist > 70) this.vx = this.facing * this.speed;
                            else {
                                this.vx = 0;
                                if (this.attackCooldown <= 0 && dist < 80) {
                                    this.attackCooldown = 60;
                                    player.takeDamage(this.baseDamage * 1.5);
                                }
                            }
                        } else {
                            // Pattern 3: Rolling attack
                            if (this.patternTimer % 150 === 0) {
                                this.vx = this.facing * this.speed * 5;
                            }
                            if (Math.abs(this.vx) < 2) {
                                if (dist > 100) this.vx = this.facing * this.speed;
                                else this.vx *= 0.9;
                            } else {
                                if (dist < 60) player.takeDamage(this.baseDamage * 2);
                            }
                        }
                        break;
                        
                    // Add patterns for other bosses similarly
                    default:
                        // Default behavior
                        if (dist > 80) {
                            this.vx = this.facing * this.speed;
                        } else {
                            this.vx = 0;
                            if (this.attackCooldown <= 0) {
                                this.attackCooldown = 50;
                                if (dist < 90) player.takeDamage(this.baseDamage);
                            }
                        }
                        
                        if (this.specialCooldown <= 0 && dist < 300) {
                            this.specialCooldown = 100;
                            const angle = Math.atan2(dy, dx);
                            for (let i = -1; i <= 1; i++) {
                                projectiles.push(new Projectile(
                                    this.x, this.y, angle + i * 0.3, 8, 'enemy'
                                ));
                            }
                        }
                        break;
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.facing, 1);
                
                // Boss visuals based on type (keeping original designs)
                switch(this.type) {
                    case 'Crimson Knight':
                        ctx.fillStyle = '#8b0000';
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        ctx.fillStyle = '#ffd700';
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, 6);
                        ctx.fillRect(-this.width / 2, this.height / 2 - 6, this.width, 6);
                        
                        // Crown
                        ctx.fillStyle = '#ffd700';
                        for (let i = -2; i <= 2; i++) {
                            ctx.fillRect(i * 10 - 3, -this.height / 2 - 8, 6, 12);
                        }
                        
                        // Giant sword
                        ctx.fillStyle = '#c0c0c0';
                        ctx.fillRect(this.width / 2, -this.height / 2, 8, this.height);
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(this.width / 2 + 2, -this.height / 2, 2, this.height);
                        break;
                        
                    case 'Shadow Lord':
                        ctx.fillStyle = '#2a2a2a';
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        ctx.globalAlpha = 0.3 + Math.sin(Date.now() / 150) * 0.2;
                        ctx.fillStyle = '#000000';
                        for (let i = 0; i < 3; i++) {
                            ctx.fillRect(-this.width / 2 - i * 8, -this.height / 2, this.width, this.height);
                        }
                        ctx.globalAlpha = 1;
                        
                        ctx.fillStyle = '#ff0000';
                        ctx.globalAlpha = 0.8 + Math.sin(Date.now() / 200) * 0.2;
                        ctx.beginPath();
                        ctx.arc(-8, -this.height / 2 + 15, 5, 0, Math.PI * 2);
                        ctx.arc(8, -this.height / 2 + 15, 5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                        break;
                        
                    case 'Frost Warden':
                        ctx.fillStyle = '#00bfff';
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        ctx.fillStyle = '#87ceeb';
                        for (let i = 0; i < 5; i++) {
                            const x = (i - 2) * 10;
                            const y = -this.height / 2 + (i % 2) * 20;
                            ctx.beginPath();
                            ctx.moveTo(x, y);
                            ctx.lineTo(x - 5, y + 10);
                            ctx.lineTo(x + 5, y + 10);
                            ctx.fill();
                        }
                        
                        ctx.globalAlpha = 0.4;
                        const iceGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, this.width);
                        iceGrad.addColorStop(0, '#00ffff');
                        iceGrad.addColorStop(1, 'rgba(0, 255, 255, 0)');
                        ctx.fillStyle = iceGrad;
                        ctx.beginPath();
                        ctx.arc(0, 0, this.width, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                        break;
                        
                    case 'Flame Tyrant':
                        ctx.fillStyle = '#ff4500';
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        
                        ctx.fillStyle = '#ff6600';
                        for (let i = 0; i < 6; i++) {
                            const flameX = (i - 2.5) * 10;
                            const flameHeight = 10 + Math.sin(Date.now() / 100 + i) * 5;
                            ctx.beginPath();
                            ctx.moveTo(flameX, this.height / 2);
                            ctx.lineTo(flameX - 5, this.height / 2 - flameHeight);
                            ctx.lineTo(flameX + 5, this.height / 2 - flameHeight);
                            ctx.fill();
                        }
                        
                        ctx.fillStyle = '#8b0000';
                        ctx.beginPath();
                        ctx.moveTo(-15, -this.height / 2 + 5);
                        ctx.lineTo(-10, -this.height / 2 - 8);
                        ctx.lineTo(-5, -this.height / 2 + 5);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.moveTo(5, -this.height / 2 + 5);
                        ctx.lineTo(10, -this.height / 2 - 8);
                        ctx.lineTo(15, -this.height / 2 + 5);
                        ctx.fill();
                        break;
                        
                    default:
                        ctx.fillStyle = this.color;
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        break;
                }
                
                ctx.restore();
                
                // Health bar
                const barWidth = this.width + 20;
                const barHeight = 8;
                const barY = this.y - this.height / 2 - 15;
                
                ctx.fillStyle = '#222';
                ctx.fillRect(this.x - barWidth / 2, barY, barWidth, barHeight);
                
                const healthPercent = this.health / this.maxHealth;
                ctx.fillStyle = healthPercent > 0.3 ? '#ff0000' : '#ff8c00';
                ctx.fillRect(this.x - barWidth / 2, barY, barWidth * healthPercent, barHeight);
                
                // Boss name
                ctx.fillStyle = '#ffd700';
                ctx.font = 'bold 16px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText(this.type, this.x, barY - 10);
            }

            takeDamage(damage) {
                this.health -= damage;
                this.health = Math.max(0, this.health);
                
                for (let i = 0; i < 20; i++) {
                    particles.push(new Particle(
                        this.x,
                        this.y,
                        this.color,
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 10,
                        35
                    ));
                }
            }
        }

        // Room class (keeping original castle look)
        class Room {
            constructor(seed, isBossRoom = false) {
                this.seed = seed;
                this.isBossRoom = isBossRoom;
                this.enemies = [];
                this.boss = null;
                this.platforms = [];
                this.cleared = false;
                
                // Seeded random
                function rand() {
                    seed = (seed * 9301 + 49297) % 233280;
                    return seed / 233280;
                }
                
                // Generate platforms
                const platformCount = 3 + Math.floor(rand() * 4);
                for (let i = 0; i < platformCount; i++) {
                    this.platforms.push({
                        x: 100 + rand() * (canvas.width - 300),
                        y: 200 + rand() * 300,
                        width: 100 + rand() * 150,
                        height: 15
                    });
                }
                
                // Safe spawn/exit platforms
                this.platforms.push({
                    x: 50,
                    y: canvas.height - 150,
                    width: 200,
                    height: 15
                });
                
                this.platforms.push({
                    x: canvas.width - 250,
                    y: canvas.height - 150,
                    width: 200,
                    height: 15
                });
                
                if (this.isBossRoom) {
                    const bossTypes = [
                        'Crimson Knight', 'Shadow Lord', 'Frost Warden', 'Flame Tyrant',
                        'Stone Golem', 'Toxic Assassin', 'Thunder King', 'Necromancer',
                        'Blood Reaper', 'Void Walker'
                    ];
                    const bossType = bossTypes[Math.floor(rand() * bossTypes.length)];
                    this.boss = new Boss(canvas.width / 2, canvas.height - 200, bossType);
                } else {
                    let baseEnemyCount = 2 + Math.floor(rand() * 4);
                    
                    if (this.seed < 3 * 12345) {
                        baseEnemyCount = 1 + Math.floor(rand() * 2);
                    } else if (this.seed < 5 * 12345) {
                        baseEnemyCount = 2 + Math.floor(rand() * 2);
                    }
                    
                    const enemyCount = Math.min(baseEnemyCount, this.platforms.length);
                    const usedPlatforms = [];
                    const enemyTypes = ['basic', 'advanced', 'heavy', 'assassin', 'mage'];
                    
                    for (let i = 0; i < enemyCount; i++) {
                        let platformIndex;
                        let attempts = 0;
                        do {
                            platformIndex = Math.floor(rand() * this.platforms.length);
                            attempts++;
                        } while (usedPlatforms.includes(platformIndex) && attempts < 20);
                        
                        if (!usedPlatforms.includes(platformIndex)) {
                            usedPlatforms.push(platformIndex);
                            const platform = this.platforms[platformIndex];
                            
                            const typeRoll = rand();
                            let type;
                            
                            if (this.seed < 3 * 12345) {
                                if (typeRoll < 0.6) type = 'basic';
                                else if (typeRoll < 0.9) type = 'advanced';
                                else type = 'assassin';
                            } else if (this.seed < 5 * 12345) {
                                if (typeRoll < 0.35) type = 'basic';
                                else if (typeRoll < 0.6) type = 'advanced';
                                else if (typeRoll < 0.75) type = 'heavy';
                                else if (typeRoll < 0.9) type = 'assassin';
                                else type = 'mage';
                            } else {
                                if (typeRoll < 0.3) type = 'basic';
                                else if (typeRoll < 0.55) type = 'advanced';
                                else if (typeRoll < 0.7) type = 'heavy';
                                else if (typeRoll < 0.85) type = 'assassin';
                                else type = 'mage';
                            }
                            
                            this.enemies.push(new Enemy(
                                platform.x + platform.width / 2,
                                platform.y - 40,
                                type
                            ));
                        }
                    }
                }
            }

            draw() {
                // Background gradient (castle stone walls)
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, '#3a3a3a');
                gradient.addColorStop(1, '#1a1a1a');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Stone wall texture
                for (let i = 0; i < 20; i++) {
                    for (let j = 0; j < 15; j++) {
                        const x = i * 60 + (j % 2) * 30;
                        const y = j * 50;
                        ctx.strokeStyle = '#2a2a2a';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x, y, 60, 50);
                    }
                }
                
                // Torches
                for (let i = 0; i < 5; i++) {
                    const x = 150 + i * 220;
                    const y = 80;
                    
                    const torchGradient = ctx.createRadialGradient(x, y, 0, x, y, 60);
                    torchGradient.addColorStop(0, 'rgba(255, 140, 0, 0.15)');
                    torchGradient.addColorStop(1, 'rgba(255, 140, 0, 0)');
                    ctx.fillStyle = torchGradient;
                    ctx.fillRect(x - 60, y - 60, 120, 120);
                    
                    ctx.fillStyle = '#ff8c00';
                    ctx.globalAlpha = 0.8 + Math.sin(Date.now() / 100 + i) * 0.2;
                    ctx.beginPath();
                    ctx.ellipse(x, y, 6, 10 + Math.sin(Date.now() / 150 + i) * 3, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
                
                // Platforms
                for (const platform of this.platforms) {
                    ctx.fillStyle = 'rgba(0,0,0,0.4)';
                    ctx.fillRect(platform.x + 5, platform.y + 5, platform.width, platform.height);
                    
                    const platformGradient = ctx.createLinearGradient(0, platform.y, 0, platform.y + platform.height);
                    platformGradient.addColorStop(0, '#5a5a5a');
                    platformGradient.addColorStop(1, '#3a3a3a');
                    ctx.fillStyle = platformGradient;
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                    
                    ctx.fillStyle = '#6a6a6a';
                    ctx.fillRect(platform.x, platform.y, platform.width, 3);
                    
                    ctx.strokeStyle = '#2a2a2a';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < 3; i++) {
                        const crackX = platform.x + (platform.width / 4) * (i + 0.5);
                        ctx.beginPath();
                        ctx.moveTo(crackX, platform.y);
                        ctx.lineTo(crackX + 5, platform.y + platform.height);
                        ctx.stroke();
                    }
                }
                
                // Ground
                ctx.fillStyle = '#2a2a2a';
                ctx.fillRect(0, canvas.height - 50, canvas.width, 50);
                
                ctx.strokeStyle = '#1a1a1a';
                ctx.lineWidth = 2;
                for (let i = 0; i < canvas.width / 60; i++) {
                    ctx.strokeRect(i * 60, canvas.height - 50, 60, 50);
                }
                
                ctx.fillStyle = '#4a4a4a';
                ctx.fillRect(0, canvas.height - 50, canvas.width, 3);
                
                // Door
                if (this.enemies.length === 0 && !this.cleared) {
                    this.cleared = true;
                }
                
                if (this.cleared || this.enemies.length === 0) {
                    const doorX = canvas.width - 60;
                    const doorY = canvas.height - 180;
                    
                    ctx.fillStyle = '#4a4a4a';
                    ctx.fillRect(doorX, doorY, 50, 130);
                    
                    ctx.beginPath();
                    ctx.arc(doorX + 25, doorY + 130, 25, Math.PI, 0);
                    ctx.fill();
                    
                    ctx.fillStyle = '#0a0a0a';
                    ctx.fillRect(doorX + 5, doorY + 20, 40, 110);
                    
                    const doorGradient = ctx.createRadialGradient(doorX + 25, doorY + 75, 0, doorX + 25, doorY + 75, 50);
                    doorGradient.addColorStop(0, 'rgba(255, 215, 0, 0.4)');
                    doorGradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                    ctx.fillStyle = doorGradient;
                    ctx.fillRect(doorX - 20, doorY, 90, 130);
                    
                    ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 300) * 0.3;
                    ctx.fillStyle = '#ffd700';
                    ctx.fillRect(doorX + 5, doorY + 20, 40, 110);
                    ctx.globalAlpha = 1;
                    
                    ctx.strokeStyle = '#6a6a6a';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(doorX, doorY, 50, 130);
                    
                    ctx.fillStyle = '#ffd700';
                    ctx.font = '20px Courier New';
                    ctx.textAlign = 'center';
                    ctx.globalAlpha = 0.7 + Math.sin(Date.now() / 300) * 0.3;
                    ctx.fillText('‚Üí', doorX + 25, doorY - 10);
                    ctx.globalAlpha = 1;
                }
            }
        }

        // MASSIVE Upgrade system with 45+ upgrades including mythics
        const upgradeDefinitions = {
            // COMMON (Basic improvements)
            maxHealth: { name: 'Vitality', desc: 'Increase max health', rarity: 'common', maxLevel: 10, type: 'passive' },
            damage: { name: 'Power', desc: 'Increase base damage', rarity: 'common', maxLevel: 10, type: 'passive' },
            attackSpeed: { name: 'Swiftness', desc: 'Attack faster', rarity: 'common', maxLevel: 8, type: 'passive' },
            speed: { name: 'Agility', desc: 'Move faster', rarity: 'common', maxLevel: 6, type: 'passive' },
            lifesteal: { name: 'Blood Hunger', desc: 'Steal health on hit', rarity: 'common', maxLevel: 5, type: 'passive' },
            thorns: { name: 'Thorns', desc: 'Reflect damage', rarity: 'common', maxLevel: 5, type: 'passive' },
            
            // UNCOMMON (Enhanced abilities)
            multishot: { name: 'Multishot', desc: 'Fire multiple knives', rarity: 'uncommon', maxLevel: 4, type: 'passive' },
            rapidFire: { name: 'Rapid Fire', desc: 'Throw knives faster', rarity: 'uncommon', maxLevel: 5, type: 'passive' },
            critChance: { name: 'Precision', desc: 'Increase crit chance', rarity: 'uncommon', maxLevel: 8, type: 'passive' },
            critDamage: { name: 'Execution', desc: 'Increase crit damage', rarity: 'uncommon', maxLevel: 6, type: 'passive' },
            dashAttack: { name: 'Dash Attack', desc: 'Damage while dashing', rarity: 'uncommon', maxLevel: 3, type: 'passive' },
            vampiricAura: { name: 'Vampiric Aura', desc: 'Drain nearby enemies', rarity: 'uncommon', maxLevel: 4, type: 'passive' },
            ironSkin: { name: 'Iron Skin', desc: 'Reduce damage taken', rarity: 'uncommon', maxLevel: 5, type: 'passive' },
            swiftness: { name: 'Enhanced Swiftness', desc: 'Greatly increase speed', rarity: 'uncommon', maxLevel: 4, type: 'passive' },
            
            // RARE (Special effects)
            poisonDagger: { name: 'Poison Blade', desc: 'Poison enemies (DoT)', rarity: 'rare', maxLevel: 4, type: 'passive' },
            frozenTouch: { name: 'Frozen Touch', desc: 'Slow enemies on hit', rarity: 'rare', maxLevel: 4, type: 'passive' },
            explosiveKnives: { name: 'Explosive Knives', desc: 'Knives explode', rarity: 'rare', maxLevel: 3, type: 'passive' },
            chainLightning: { name: 'Chain Lightning', desc: 'Lightning chains', rarity: 'rare', maxLevel: 3, type: 'passive' },
            piercing: { name: 'Piercing Shot', desc: 'Shots pierce', rarity: 'rare', maxLevel: 1, type: 'passive' },
            doubleJump: { name: 'Double Jump', desc: 'Jump in mid-air', rarity: 'rare', maxLevel: 1, type: 'passive' },
            ghostWalk: { name: 'Ghost Walk', desc: 'Phase through attacks', rarity: 'rare', maxLevel: 3, type: 'passive' },
            bloodRage: { name: 'Blood Rage', desc: 'Gain speed on kill', rarity: 'rare', maxLevel: 4, type: 'passive' },
            executeThreshold: { name: 'Execute', desc: 'Instant kill low HP enemies', rarity: 'rare', maxLevel: 3, type: 'passive' },
            ricochet: { name: 'Ricochet', desc: 'Knives bounce', rarity: 'rare', maxLevel: 3, type: 'passive' },
            magneticKnives: { name: 'Magnetic Knives', desc: 'Knives seek enemies', rarity: 'rare', maxLevel: 2, type: 'passive' },
            
            // NEW RARE UPGRADES
            deathMark: { name: 'Death Mark', desc: 'Mark enemies for extra damage', rarity: 'rare', maxLevel: 4, type: 'passive' },
            voidWalk: { name: 'Void Walk', desc: 'Dash through enemies dealing damage', rarity: 'rare', maxLevel: 3, type: 'passive' },
            soulHarvest: { name: 'Soul Harvest', desc: 'Restore health on kill', rarity: 'rare', maxLevel: 5, type: 'passive' },
            reflection: { name: 'Reflection', desc: 'Deal damage back when hit', rarity: 'rare', maxLevel: 4, type: 'passive' },
            arcaneShield: { name: 'Arcane Shield', desc: 'Projectiles may miss', rarity: 'rare', maxLevel: 3, type: 'passive' },
            regeneration: { name: 'Regeneration', desc: 'Slowly restore health', rarity: 'rare', maxLevel: 6, type: 'passive' },
            evasion: { name: 'Evasion', desc: 'Chance to dodge attacks', rarity: 'rare', maxLevel: 4, type: 'passive' },
            bloodShield: { name: 'Blood Shield', desc: 'Chance to block 50% damage', rarity: 'rare', maxLevel: 4, type: 'passive' },
            
            // EPIC (Powerful abilities)
            multiStrike: { name: 'Multi-Strike', desc: 'Attack multiple times', rarity: 'epic', maxLevel: 3, type: 'passive' },
            bladeDance: { name: 'Blade Dance', desc: 'Move while attacking', rarity: 'epic', maxLevel: 3, type: 'passive' },
            berserkerRage: { name: 'Berserker Rage', desc: 'More damage at low health', rarity: 'epic', maxLevel: 4, type: 'passive' },
            assassination: { name: 'Assassination', desc: 'Massive first hit damage', rarity: 'epic', maxLevel: 3, type: 'passive' },
            execution: { name: 'Executioner', desc: 'Instantly kill low HP', rarity: 'epic', maxLevel: 3, type: 'passive' },
            rage: { name: 'Rage', desc: 'Gain damage on kills', rarity: 'epic', maxLevel: 5, type: 'passive' },
            berserk: { name: 'Berserk', desc: 'High risk high reward', rarity: 'epic', maxLevel: 3, type: 'passive' },
            whirlwind: { name: 'Whirlwind', desc: 'Spin projectiles around you', rarity: 'epic', maxLevel: 3, type: 'passive' },
            criticalMass: { name: 'Critical Mass', desc: 'Crits create explosions', rarity: 'epic', maxLevel: 3, type: 'passive' },
            shadowBurst: { name: 'Shadow Burst', desc: 'Attacks may burst outward', rarity: 'epic', maxLevel: 3, type: 'passive' },
            timeWarp: { name: 'Time Warp', desc: 'Special: Slow all enemies', rarity: 'epic', maxLevel: 3, type: 'special' },
            
            // LEGENDARY (Active abilities)
            shadowClone: { name: 'Shadow Clone', desc: 'Summon fighting clone', rarity: 'legendary', type: 'special', cooldown: 300 },
            fireStorm: { name: 'Fire Storm', desc: 'Rain fire from above', rarity: 'legendary', type: 'special', cooldown: 300 },
            timeStop: { name: 'Time Stop', desc: 'Freeze all enemies', rarity: 'legendary', type: 'special', cooldown: 300 },
            phantomStrike: { name: 'Phantom Strike', desc: 'Teleport to enemy', rarity: 'legendary', type: 'special', cooldown: 300 },
            teleportStrike: { name: 'Teleport Strike', desc: 'Teleport and strike', rarity: 'legendary', type: 'special', cooldown: 300 },
            deathWave: { name: 'Death Wave', desc: 'Send waves of death', rarity: 'legendary', type: 'special', cooldown: 300 },
            meteorStrike: { name: 'Meteor Strike', desc: 'Rain meteors', rarity: 'legendary', type: 'special', cooldown: 300 },
            
            // MYTHIC (Game-changing abilities) - OVERPOWERED!
            godMode: { name: '‚ö° GOD MODE ‚ö°', desc: 'Invincible + 10x damage for 5s', rarity: 'mythic', type: 'special', cooldown: 300 },
            omniSlash: { name: '‚ö° OMNI SLASH ‚ö°', desc: 'Dash through all enemies', rarity: 'mythic', type: 'special', cooldown: 300 },
            armageddon: { name: '‚ö° ARMAGEDDON ‚ö°', desc: 'Meteor apocalypse', rarity: 'mythic', type: 'special', cooldown: 300 },
            infinityEdge: { name: '‚ö° INFINITY EDGE ‚ö°', desc: 'Summon 20 homing blades', rarity: 'mythic', type: 'special', cooldown: 300 },
            divineShield: { name: '‚ö° DIVINE SHIELD ‚ö°', desc: 'Invulnerable for 4s', rarity: 'mythic', type: 'special', cooldown: 300 },
            stormCaller: { name: '‚ö° STORM CALLER ‚ö°', desc: 'Lightning strikes all', rarity: 'mythic', type: 'special', cooldown: 300 },
            timestrike: { name: '‚ö° TIME STRIKE ‚ö°', desc: 'Stop time for 5s', rarity: 'mythic', type: 'special', cooldown: 300 },
            soulReaper: { name: '‚ö° SOUL REAPER ‚ö°', desc: 'Instantly kill all normal enemies', rarity: 'mythic', type: 'special', cooldown: 300 },
            ragnarok: { name: '‚ö° RAGNAROK ‚ö°', desc: 'Screen-wide explosion', rarity: 'mythic', type: 'special', cooldown: 300 }
        };

        function getRandomUpgrades(count = 3) {
            const available = [];
            
            // If mythic mode, ONLY show mythic upgrades!
            if (mythicMode) {
                for (const [key, upgrade] of Object.entries(upgradeDefinitions)) {
                    if (upgrade.rarity === 'mythic') {
                        const currentLevel = player.upgrades[key] || 0;
                        if (!upgrade.maxLevel || currentLevel < upgrade.maxLevel) {
                            available.push(key);
                        }
                    }
                }
            } else {
                // Normal mode - no mythics shown
                const rarityWeights = {
                    common: 40,
                    uncommon: 30,
                    rare: 15,
                    epic: 10,
                    legendary: 4
                };
                
                for (const [key, upgrade] of Object.entries(upgradeDefinitions)) {
                    if (upgrade.rarity === 'mythic') continue; // Skip mythics in normal mode
                    
                    const currentLevel = player.upgrades[key] || 0;
                    if (!upgrade.maxLevel || currentLevel < upgrade.maxLevel) {
                        const weight = rarityWeights[upgrade.rarity] || 1;
                        for (let i = 0; i < weight; i++) {
                            available.push(key);
                        }
                    }
                }
            }
            
            if (available.length === 0) return [];
            
            // Shuffle
            for (let i = available.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [available[i], available[j]] = [available[j], available[i]];
            }
            
            // Get unique upgrades
            const selected = [];
            const seen = new Set();
            for (const key of available) {
                if (!seen.has(key)) {
                    selected.push(key);
                    seen.add(key);
                }
                if (selected.length >= count) break;
            }
            
            return selected;
        }

        function showUpgradeScreen() {
            const upgradeScreen = document.getElementById('upgradeScreen');
            const upgradeOptions = document.getElementById('upgradeOptions');
            
            upgradeOptions.innerHTML = '';
            const selectedUpgrades = getRandomUpgrades(3);
            
            selectedUpgrades.forEach(upgradeKey => {
                const upgrade = upgradeDefinitions[upgradeKey];
                const currentLevel = player.upgrades[upgradeKey] || 0;
                
                const card = document.createElement('div');
                card.className = 'upgrade-card';
                if (upgrade.rarity === 'mythic') {
                    card.classList.add('mythic');
                }
                
                let levelText = '';
                if (upgrade.maxLevel) {
                    levelText = `<div class="level">Level ${currentLevel} ‚Üí ${currentLevel + 1}</div>`;
                }
                
                card.innerHTML = `
                    <h3>${upgrade.name}</h3>
                    ${levelText}
                    <p>${upgrade.desc}</p>
                    <p style="color: ${
                        upgrade.rarity === 'mythic' ? '#ff00ff' :
                        upgrade.rarity === 'legendary' ? '#ff8c00' :
                        upgrade.rarity === 'epic' ? '#9400d3' :
                        upgrade.rarity === 'rare' ? '#4169e1' :
                        upgrade.rarity === 'uncommon' ? '#228b22' : '#808080'
                    }; font-size: 12px; margin-top: 8px;">${upgrade.rarity.toUpperCase()}</p>
                `;
                
                card.addEventListener('click', () => {
                    applyUpgrade(upgradeKey);
                    upgradeScreen.style.display = 'none';
                    
                    // Upgrade particles
                    for (let i = 0; i < 50; i++) {
                        particles.push(new Particle(
                            player.x,
                            player.y,
                            upgrade.rarity === 'mythic' ? '#ff00ff' : '#ffd700',
                            (Math.random() - 0.5) * 12,
                            (Math.random() - 0.5) * 12,
                            40
                        ));
                    }
                });
                
                upgradeOptions.appendChild(card);
            });
            
            upgradeScreen.style.display = 'flex';
        }

        function applyUpgrade(upgradeKey) {
            const upgrade = upgradeDefinitions[upgradeKey];
            
            if (upgrade.maxLevel) {
                player.upgrades[upgradeKey] = (player.upgrades[upgradeKey] || 0) + 1;
            } else {
                player.upgrades[upgradeKey] = 1;
            }
            
            // Apply upgrade effects
            switch(upgradeKey) {
                case 'maxHealth':
                    player.maxHealth = 150 + player.upgrades.maxHealth * 25;
                    player.health = Math.min(player.health + 25, player.maxHealth);
                    break;
                case 'damage':
                    // Handled in takeDamage calculation
                    break;
                case 'speed':
                case 'swiftness':
                    player.speed = 5 + (player.upgrades.speed + player.upgrades.swiftness) * 0.8;
                    break;
                case 'doubleJump':
                    player.hasDoubleJump = true;
                    break;
            }
            
            // Special ability assignment
            if (upgrade.type === 'special') {
                if (!player.special1) {
                    player.special1 = upgradeKey;
                } else if (!player.special2) {
                    player.special2 = upgradeKey;
                }
            }
        }

        // Game state
        let player = new Player(100, 300);
        let currentRoom = new Room(1);
        let roomNumber = 1;
        let particles = [];
        let projectiles = [];
        let shadowClones = [];
        let gameStarted = false;
        let showingUpgrade = false;
        let gameOver = false;
        
        // SECRET CHEAT CODE SYSTEM
        let cheatCode = '';
        let mythicMode = false;
        
        // Input
        const keys = {};
        const mouse = { x: 0, y: 0 };
        
        // Event listeners
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            
            // CHEAT CODE DETECTION
            cheatCode += e.key.toLowerCase();
            if (cheatCode.length > 20) cheatCode = cheatCode.slice(-20);
            
            if (cheatCode.includes('goldengod')) {
                if (!mythicMode) {
                    mythicMode = true;
                    cheatCode = '';
                    
                    // MYTHIC MODE ACTIVATION!
                    for (let i = 0; i < 200; i++) {
                        particles.push(new Particle(
                            Math.random() * canvas.width,
                            Math.random() * canvas.height,
                            '#ff00ff',
                            (Math.random() - 0.5) * 20,
                            (Math.random() - 0.5) * 20,
                            60
                        ));
                    }
                    
                    console.log('üîÆ MYTHIC MODE ACTIVATED! üîÆ');
                }
            }
            
            if (!gameStarted) {
                return;
            }
            
            // Jump
            if (e.key === ' ' || e.key === 'w' || e.key.toLowerCase() === 'arrowup') {
                if (player.onGround) {
                    player.vy = -player.jumpPower;
                } else if (player.upgrades.doubleJump && !player.hasDoubleJumped) {
                    player.vy = -player.jumpPower;
                    player.hasDoubleJumped = true;
                }
            }
            
            // Dash
            if (e.key === 'k') {
                player.dash();
            }
            
            // Specials
            if (e.key === 'q') {
                player.useSpecial1();
            }
            if (e.key === 'e') {
                player.useSpecial2();
            }
        });
        
        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });
        
        canvas.addEventListener('mousedown', () => {
            if (gameStarted && !gameOver) {
                player.attack();
            }
        });
        
        // Game loop
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (!gameStarted || gameOver || showingUpgrade) {
                requestAnimationFrame(gameLoop);
                return;
            }
            
            // Draw room
            currentRoom.draw();
            
            // Player input
            if (!player.dashing) {
                if (keys['a'] || keys['arrowleft']) {
                    player.vx = -player.speed;
                    player.facing = -1;
                } else if (keys['d'] || keys['arrowright']) {
                    player.vx = player.speed;
                    player.facing = 1;
                } else {
                    player.vx *= 0.8;
                }
            }
            
            // Ranged attack
            if (keys['l']) {
                player.shootRanged();
            }
            
            // Dagger attack (j)
            if (keys['j']) {
                player.attack();
            }
            
            // Update
            player.update();
            
            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                particles[i].draw();
                if (particles[i].life <= 0) {
                    particles.splice(i, 1);
                }
            }
            
            // Update projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                if (!projectiles[i].update()) {
                    projectiles.splice(i, 1);
                } else {
                    projectiles[i].draw();
                    
                    // Collision detection
                    const proj = projectiles[i];
                    
                    if (proj.owner === 'player') {
                        // vs enemies
                        for (let j = currentRoom.enemies.length - 1; j >= 0; j--) {
                            const enemy = currentRoom.enemies[j];
                            const dist = Math.sqrt((proj.x - enemy.x)**2 + (proj.y - enemy.y)**2);
                            if (dist < enemy.width / 2 + 8) {
                                const damage = player.attackDamage * (1 + player.upgrades.damage * 0.15);
                                enemy.takeDamage(damage);
                                
                                if (enemy.health <= 0) {
                                    currentRoom.enemies.splice(j, 1);
                                }
                                
                                projectiles.splice(i, 1);
                                break;
                            }
                        }
                        
                        // vs boss
                        if (currentRoom.boss && currentRoom.boss.health > 0) {
                            const dist = Math.sqrt((proj.x - currentRoom.boss.x)**2 + (proj.y - currentRoom.boss.y)**2);
                            if (dist < currentRoom.boss.width / 2 + 8) {
                                const damage = player.attackDamage * (1 + player.upgrades.damage * 0.15);
                                currentRoom.boss.takeDamage(damage);
                                projectiles.splice(i, 1);
                            }
                        }
                    } else {
                        // Enemy projectile vs player
                        const dist = Math.sqrt((proj.x - player.x)**2 + (proj.y - player.y)**2);
                        if (dist < player.width / 2 + 8) {
                            if (!player.dashing && !player.invincible) {
                                player.takeDamage(10);
                            }
                            projectiles.splice(i, 1);
                        }
                    }
                }
            }
            
            // Update shadow clones
            for (let i = shadowClones.length - 1; i >= 0; i--) {
                if (!shadowClones[i].update()) {
                    shadowClones.splice(i, 1);
                } else {
                    shadowClones[i].draw();
                }
            }
            
            // Update enemies
            for (const enemy of currentRoom.enemies) {
                enemy.update();
                enemy.draw();
            }
            
            // Update boss
            if (currentRoom.boss && currentRoom.boss.health > 0) {
                currentRoom.boss.update();
                currentRoom.boss.draw();
            }
            
            // Draw player
            player.draw();
            
            // Check for room transition
            const roomCleared = currentRoom.boss ? 
                (currentRoom.boss.health <= 0) : 
                (currentRoom.enemies.length === 0);
                
            if (roomCleared && player.x > canvas.width - 60) {
                roomNumber++;
                
                const isBossRoom = (roomNumber % 5 === 0);
                currentRoom = new Room(roomNumber * 12345, isBossRoom);
                
                player.x = 100;
                player.y = canvas.height - 200;
                player.vy = 0;
                player.vx = 0;
                player.health = Math.min(player.health + 20, player.maxHealth);
                projectiles = [];
                particles = [];
                shadowClones = [];
                
                // Show upgrade screen
                if (!isBossRoom) {
                    showingUpgrade = true;
                    showUpgradeScreen();
                    setTimeout(() => {
                        showingUpgrade = false;
                    }, 100);
                }
            }
            
            // Update UI
            document.getElementById('health').textContent = Math.floor(player.health);
            document.getElementById('healthBar').style.width = (player.health / player.maxHealth * 100) + '%';
            document.getElementById('room').textContent = roomNumber;
            const enemyCount = currentRoom.enemies.length + (currentRoom.boss && currentRoom.boss.health > 0 ? 1 : 0);
            document.getElementById('enemies').textContent = enemyCount;
            
            // Mythic mode indicator
            if (mythicMode) {
                ctx.fillStyle = '#ff00ff';
                ctx.font = 'bold 24px Courier New';
                ctx.textAlign = 'center';
                ctx.shadowColor = 'rgba(255, 0, 255, 0.8)';
                ctx.shadowBlur = 10;
                const pulse = 0.8 + Math.sin(Date.now() / 200) * 0.2;
                ctx.globalAlpha = pulse;
                ctx.fillText('‚ú® MYTHIC MODE ‚ú®', canvas.width / 2, 30);
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
            }
            
            // Game over
            if (player.health <= 0 && !gameOver) {
                gameOver = true;
                document.getElementById('finalRoom').textContent = roomNumber;
                document.getElementById('gameOverScreen').style.display = 'flex';
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        // Menu button event listeners
        document.getElementById('playBtn').addEventListener('click', () => {
            document.getElementById('mainMenu').style.display = 'none';
            gameStarted = true;
            mythicMode = false; // Reset mythic mode
            player = new Player(100, 300);
            currentRoom = new Room(1);
            roomNumber = 1;
            particles = [];
            projectiles = [];
            shadowClones = [];
            gameOver = false;
        });

        document.getElementById('settingsBtn').addEventListener('click', () => {
            document.getElementById('settingsMenu').style.display = 'flex';
        });

        document.getElementById('backBtn').addEventListener('click', () => {
            document.getElementById('settingsMenu').style.display = 'none';
        });

        // Settings toggles
        function setupToggle(toggleId, valueId, settingKey) {
            document.getElementById(toggleId).addEventListener('click', function() {
                this.classList.toggle('active');
                const isActive = this.classList.contains('active');
                document.getElementById(valueId).textContent = isActive ? 'ON' : 'OFF';
            });
        }

        setupToggle('particlesToggle', 'particlesValue', 'particlesEnabled');
        setupToggle('screenShakeToggle', 'screenShakeValue', 'screenShakeEnabled');
        setupToggle('damageNumbersToggle', 'damageNumbersValue', 'damageNumbersEnabled');
        setupToggle('fpsToggle', 'fpsValue', 'showFPS');

        document.getElementById('volumeSlider').addEventListener('input', (e) => {
            document.getElementById('volumeValue').textContent = e.target.value + '%';
        });

        document.getElementById('musicSlider').addEventListener('input', (e) => {
            document.getElementById('musicValue').textContent = e.target.value + '%';
        });

        document.getElementById('sfxSlider').addEventListener('input', (e) => {
            document.getElementById('sfxValue').textContent = e.target.value + '%';
        });
        
        // Game over buttons
        document.getElementById('playAgainBtn').addEventListener('click', () => {
            mythicMode = false; // Reset mythic mode
            player = new Player(100, 300);
            currentRoom = new Room(1);
            roomNumber = 1;
            particles = [];
            projectiles = [];
            shadowClones = [];
            gameStarted = true;
            gameOver = false;
            document.getElementById('gameOverScreen').style.display = 'none';
        });
        
        document.getElementById('loadCheckpointBtn').addEventListener('click', () => {
            mythicMode = false; // Reset mythic mode
            player = new Player(100, 300);
            currentRoom = new Room(1);
            roomNumber = 1;
            particles = [];
            projectiles = [];
            shadowClones = [];
            gameStarted = true;
            gameOver = false;
            document.getElementById('gameOverScreen').style.display = 'none';
        });
        
        // Start game loop
        gameLoop();
    </script>
</body>
</html>
