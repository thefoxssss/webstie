<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Valorant Proto: Full Game</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background-color: #0f1923; color: white; user-select: none; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: none; }
        
        /* --- TOP HUD --- */
        #top-hud { position: absolute; top: 0; left: 50%; transform: translateX(-50%); display: flex; flex-direction: column; align-items: center; }
        .score-board { display: flex; align-items: center; background: rgba(15, 25, 35, 0.9); padding: 5px 20px; border-bottom-left-radius: 10px; border-bottom-right-radius: 10px; border: 1px solid #444; border-top: none; }
        #timer { font-size: 36px; font-weight: 800; margin: 0 20px; color: white; }
        .team-score { font-size: 32px; font-weight: bold; width: 40px; text-align: center; }
        .score-ally { color: #00ffaa; }
        .score-enemy { color: #ff4655; }
        #round-state { margin-top: 5px; font-size: 12px; color: #ff4655; font-weight: bold; text-transform: uppercase; letter-spacing: 2px; background: rgba(0,0,0,0.5); padding: 2px 10px; border-radius: 4px; }

        /* --- SPIKE STATUS --- */
        #spike-hud { position: absolute; top: 100px; left: 50%; transform: translateX(-50%); text-align: center; display: none; }
        .spike-icon { font-size: 40px; margin-bottom: 5px; text-shadow: 0 0 10px #ff4655; animation: pulse 1s infinite; }
        #plant-bar-container { width: 300px; height: 8px; background: #222; border: 2px solid white; border-radius: 4px; overflow: hidden; display: none; margin: 0 auto; box-shadow: 0 0 10px black; }
        #plant-bar { height: 100%; width: 0%; background: #00ffaa; transition: width 0.1s linear; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }

        /* --- CROSSHAIR --- */
        #crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        .ch-h { position: absolute; width: 14px; height: 2px; background: #00ffaa; top: 50%; left: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 2px black; }
        .ch-v { position: absolute; width: 2px; height: 14px; background: #00ffaa; top: 50%; left: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 2px black; }

        /* --- BOTTOM HUD --- */
        #bottom-hud { position: absolute; bottom: 10px; left: 0; width: 100%; height: 100px; display: flex; justify-content: space-between; align-items: flex-end; padding: 0 40px; box-sizing: border-box; }
        
        .hud-left { display: flex; align-items: center; color: white; transform: skewX(-15deg); background: rgba(15, 25, 35, 0.8); padding: 5px 30px; border-left: 4px solid #00ffaa; border-radius: 5px; box-shadow: 5px 5px 0px rgba(0,0,0,0.3); }
        .health-content { transform: skewX(15deg); display: flex; flex-direction: column; align-items: flex-start; }
        .hp-text-row { display: flex; align-items: baseline; }
        #health-val { font-size: 48px; font-weight: 800; line-height: 1; margin-right: 5px; }
        .hp-label { font-size: 14px; font-weight: 600; color: #ccc; }
        .health-bar-bg { width: 150px; height: 8px; background: #333; margin-top: 5px; position: relative; }
        .health-bar-fill { width: 100%; height: 100%; background: #00ffaa; box-shadow: 0 0 5px #00ffaa; }

        .hud-center { display: flex; gap: 8px; margin-bottom: 10px; }
        .ability-box { width: 50px; height: 50px; background: rgba(0,0,0,0.6); border: 1px solid #555; display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative; border-radius: 2px; }
        .ability-key { position: absolute; top: 2px; left: 4px; font-size: 10px; font-weight: bold; color: #fff; text-shadow: 1px 1px 0 #000; }
        .ability-icon { font-size: 20px; filter: drop-shadow(0 0 2px black); }
        .ult-box { width: 70px; height: 70px; border-color: #ffeb3b; background: rgba(255, 235, 59, 0.1); margin-top: -20px; }
        
        .hud-right { display: flex; align-items: center; color: white; transform: skewX(15deg); background: rgba(15, 25, 35, 0.8); padding: 5px 30px; border-right: 4px solid #ff4655; border-radius: 5px; box-shadow: -5px 5px 0px rgba(0,0,0,0.3); }
        .ammo-content { transform: skewX(-15deg); display: flex; flex-direction: column; align-items: flex-end; }
        .ammo-text-row { display: flex; align-items: baseline; }
        #ammo-val { font-size: 48px; font-weight: 800; line-height: 1; }
        .ammo-reserve { font-size: 24px; color: #aaa; margin-left: 5px; }
        .ammo-icon { height: 15px; width: 100px; background: repeating-linear-gradient(90deg, #fff, #fff 2px, transparent 2px, transparent 4px); margin-top: 5px; opacity: 0.5; }

        /* ALERTS */
        #alert-msg { position: absolute; top: 20%; left: 50%; transform: translateX(-50%); font-size: 60px; font-weight: 900; text-shadow: 0 0 20px black; opacity: 0; transition: opacity 0.5s; text-align: center; white-space: nowrap; font-style: italic; color: #ff4655; }

        /* MENUS COMMON */
        .menu-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #0f1923; z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; }
        .val-btn { padding: 15px 40px; font-size: 18px; background: #ff4655; color: white; border: none; cursor: pointer; font-weight: bold; text-transform: uppercase; transition: 0.2s; margin: 10px; }
        .val-btn:hover { background: #d13644; }
        .val-input { padding: 12px; font-size: 16px; background: #333; border: 1px solid #555; color: white; margin: 5px; text-align: center; width: 250px; }

        /* LOBBY & AGENT SELECT */
        #room-list { width: 500px; height: 300px; background: rgba(0,0,0,0.3); border: 1px solid #444; overflow-y: auto; margin: 20px; padding: 10px; }
        .room-item { background: #1f2b35; padding: 15px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; border-left: 3px solid #ff4655; }
        .room-item:hover { background: #2a3b47; }
        .team-container { display: flex; gap: 50px; margin: 20px; }
        .team-column { width: 300px; background: rgba(255,255,255,0.05); padding: 10px; border-radius: 5px; min-height: 200px; }
        .team-header { text-align: center; font-weight: bold; margin-bottom: 10px; padding: 5px; text-transform: uppercase; letter-spacing: 2px; }
        .defenders-header { color: #00ffaa; border-bottom: 2px solid #00ffaa; }
        .attackers-header { color: #ff4655; border-bottom: 2px solid #ff4655; }
        .player-row { display: flex; align-items: center; background: #2a3b47; margin-bottom: 5px; padding: 5px 10px; border-radius: 3px; border-left: 3px solid transparent; }
        .player-row.me { border: 1px solid #ffeb3b; }
        .player-row.locked { border-left-color: #00ffaa; background: #2e4a3d; }
        .p-icon { font-size: 20px; margin-right: 10px; }
        .p-name { flex-grow: 1; font-size: 14px; }
        
        /* AGENT SELECT SCREEN */
        #agent-select-screen { background: #0f1923; }
        #select-timer { font-size: 48px; font-weight: bold; margin-bottom: 20px; color: white; }
        .agent-grid { display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; max-width: 800px; margin-bottom: 30px; }
        .agent-card { width: 80px; height: 120px; background: #1f2b35; border: 2px solid #333; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: 0.2s; position: relative; }
        .agent-card:hover { border-color: #999; transform: translateY(-5px); }
        .agent-card.selected { border-color: #00ffaa; background: #2a3b47; box-shadow: 0 0 15px rgba(0,255,170,0.3); }
        .agent-card.locked { opacity: 0.5; cursor: not-allowed; filter: grayscale(100%); }
        .agent-card-icon { font-size: 40px; margin-bottom: 10px; }
        .agent-card-name { font-size: 12px; font-weight: bold; text-transform: uppercase; letter-spacing: 1px; }
        #lock-btn { width: 300px; background: #00ffaa; color: #0f1923; margin-top: 20px; font-size: 24px; padding: 20px; box-shadow: 0 0 20px rgba(0,255,170,0.5); }
        #lock-btn:disabled { background: #333; color: #888; box-shadow: none; cursor: default; }

        #status-msg { margin-top: 20px; color: #888; font-size: 14px; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; text-align: center; max-width: 80%; }
        h1 { color:#ff4655; margin:0; font-size:60px; font-style:italic; margin-bottom: 10px; }
        h2 { color: white; text-transform: uppercase; letter-spacing: 2px; font-size: 24px; margin-bottom: 20px; }
    </style>

    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "firebase/app": "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js",
                "firebase/firestore": "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js",
                "firebase/auth": "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js"
            }
        }
    </script>
</head>
<body>
    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div id="top-hud">
            <div class="score-board">
                <div class="team-score score-ally">0</div>
                <div id="timer">0:30</div>
                <div class="team-score score-enemy">0</div>
            </div>
            <div id="round-state">BUY PHASE</div>
        </div>
        
        <div id="spike-hud">
            <div class="spike-icon">‚ò¢Ô∏è</div>
            <div style="font-weight:bold; color:white; font-size:18px; margin-bottom:5px;" id="spike-msg">CARRYING SPIKE</div>
            <div id="plant-bar-container"><div id="plant-bar"></div></div>
        </div>

        <div id="alert-msg">MATCH START</div>
        <div id="crosshair"><div class="ch-h"></div><div class="ch-v"></div></div>
        
        <div id="bottom-hud">
            <div class="hud-left">
                <div class="health-content">
                    <div class="hp-text-row"><div id="health-val">100</div><div class="hp-label">HP</div></div>
                    <div class="health-bar-bg"><div class="health-bar-fill"></div></div>
                </div>
            </div>
            <div class="hud-center">
                <div class="ability-box"><div class="ability-key">C</div><div class="ability-icon" id="icon-c">üåÄ</div></div>
                <div class="ability-box"><div class="ability-key">Q</div><div class="ability-icon" id="icon-q">üå´Ô∏è</div></div>
                <div class="ability-box"><div class="ability-key">E</div><div class="ability-icon" id="icon-e">üî•</div></div>
                <div class="ability-box ult-box"><div class="ability-key">X</div><div class="ability-icon" id="icon-x">‚ò†Ô∏è</div></div>
            </div>
            <div class="hud-right">
                <div class="ammo-content">
                    <div class="ammo-text-row"><div id="ammo-val">25</div><div class="ammo-reserve">75</div></div>
                    <div class="ammo-icon"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- 1. BROWSER SCREEN -->
    <div id="browser-screen" class="menu-overlay">
        <h1>VALORANT<span style="color:white; font-size:30px;">PROTO</span></h1>
        <div style="display:flex; flex-direction:row; gap: 40px; align-items: flex-start;">
            <div style="display:flex; flex-direction:column; align-items:center; background: rgba(255,255,255,0.05); padding: 20px; border-radius: 10px;">
                <h2>Create Match</h2>
                <input type="text" id="create-room-name" class="val-input" placeholder="Room Name" value="Ascent Standard">
                <input type="text" id="player-name-input" class="val-input" placeholder="Your Username" value="Player 1">
                <button class="val-btn" onclick="createRoom()">Create Room</button>
            </div>
            <div style="display:flex; flex-direction:column; align-items:center;">
                <h2>Lobby List</h2>
                <div id="room-list"><div style="text-align:center; padding:20px; color:#888;">Loading rooms...</div></div>
                <button class="val-btn" style="background:#444;" onclick="fetchRooms()">Refresh List</button>
            </div>
        </div>
        <div id="status-msg">Connecting to Firebase...</div>
    </div>

    <!-- 2. WAITING ROOM SCREEN -->
    <div id="waiting-screen" class="menu-overlay" style="display:none;">
        <h1 id="lobby-title">LOBBY</h1>
        <h2 style="color:#00ffaa;" id="lobby-status">WAITING FOR PLAYERS...</h2>
        <div class="team-container">
            <div class="team-column">
                <div class="team-header attackers-header">ATTACKERS</div>
                <div id="team-attack-list"></div>
                <button class="val-btn" style="font-size:12px; padding:5px 10px; width:100%;" onclick="switchTeam('attack')">Join Attackers</button>
            </div>
            <div class="team-column">
                <div class="team-header defenders-header">DEFENDERS</div>
                <div id="team-defend-list"></div>
                <button class="val-btn" style="font-size:12px; padding:5px 10px; width:100%;" onclick="switchTeam('defend')">Join Defenders</button>
            </div>
        </div>
        <button id="host-start-btn" class="val-btn" style="display:none;" onclick="enterAgentSelect()">ENTER AGENT SELECT</button>
        <div id="client-wait-msg" style="color:#888; margin-top:20px;">Waiting for Host...</div>
    </div>

    <!-- 3. AGENT SELECT SCREEN -->
    <div id="agent-select-screen" class="menu-overlay" style="display:none;">
        <div id="select-timer">60</div>
        <h2 style="margin-bottom:40px;">SELECT AGENT</h2>
        
        <div class="agent-grid">
            <div class="agent-card" onclick="pickAgent('jett', this)"><div class="agent-card-icon">üí®</div><div class="agent-card-name">Jett</div></div>
            <div class="agent-card" onclick="pickAgent('phoenix', this)"><div class="agent-card-icon">üî•</div><div class="agent-card-name">Phoenix</div></div>
            <div class="agent-card" onclick="pickAgent('sage', this)"><div class="agent-card-icon">üßä</div><div class="agent-card-name">Sage</div></div>
            <div class="agent-card" onclick="pickAgent('reyna', this)"><div class="agent-card-icon">üëÅÔ∏è</div><div class="agent-card-name">Reyna</div></div>
            <div class="agent-card" onclick="pickAgent('sova', this)"><div class="agent-card-icon">üèπ</div><div class="agent-card-name">Sova</div></div>
            <div class="agent-card" onclick="pickAgent('brim', this)"><div class="agent-card-icon">‚òÅÔ∏è</div><div class="agent-card-name">Brim</div></div>
            <div class="agent-card" onclick="pickAgent('omen', this)"><div class="agent-card-icon">üëª</div><div class="agent-card-name">Omen</div></div>
            <div class="agent-card" onclick="pickAgent('cypher', this)"><div class="agent-card-icon">üïµÔ∏è</div><div class="agent-card-name">Cypher</div></div>
        </div>

        <button id="lock-btn" class="val-btn" onclick="lockInAgent()" disabled>LOCK IN</button>
        
        <div style="margin-top:20px; display:flex; gap:20px;">
            <div style="text-align:center;">
                <div style="color:#ff4655; font-weight:bold; margin-bottom:10px;">ATTACKERS</div>
                <div id="select-attack-list" style="display:flex; gap:5px;"></div>
            </div>
            <div style="text-align:center;">
                <div style="color:#00ffaa; font-weight:bold; margin-bottom:10px;">DEFENDERS</div>
                <div id="select-defend-list" style="display:flex; gap:5px;"></div>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { initializeApp } from 'firebase/app';
        import { getFirestore, collection, doc, setDoc, getDoc, updateDoc, onSnapshot, query, where, getDocs, arrayUnion } from 'firebase/firestore';
        import { getAuth, signInAnonymously, onAuthStateChanged } from 'firebase/auth';

        const firebaseConfig = {
            apiKey: "AIzaSyCx72zwsJ-IaVH1N7AnX9lDHgL10eDuNKY",
            authDomain: "valorant-48fd8.firebaseapp.com",
            projectId: "valorant-48fd8",
            storageBucket: "valorant-48fd8.firebasestorage.app",
            messagingSenderId: "462060216514",
            appId: "1:462060216514:web:ca192f3fc7d542b9391b5b",
            measurementId: "G-HD9MC806HG"
        };

        // --- GAME STATE ---
        let db, auth, userId;
        const mySessionId = 'sess_' + Math.random().toString(36).substr(2, 9);
        
        let currentLobbyId = null;
        let isHost = false;
        let selectedAgent = null;
        let isLockedIn = false;
        let myTeam = 'attack';
        let myUsername = 'Player';
        let remotePlayers = {}; 
        let isPlaying = false;
        
        // Match State
        let lobbyStatus = 'waiting'; // waiting, agent_select, playing
        let gamePhase = 'waiting';
        let phaseEndTime = 0;
        let spikeState = { state: 'spawned', carrier: null, pos: null, plantTime: 0 }; 
        let barriers = []; 
        let spikeMesh = null;
        
        let bullets = [];
        let isHoldingKey = false;
        let interactionProgress = 0;
        let currentAction = null; 

        const statusEl = document.getElementById('status-msg');

        // Agent Data
        const agentAbilities = {
            'jett': { c:'‚òÅÔ∏è', q:'üéà', e:'üí®', x:'üî™' },
            'phoenix': { c:'üî•', q:'üí´', e:'üëê', x:'üîÅ' },
            'sage': { c:'üöß', q:'‚ùÑÔ∏è', e:'ü©π', x:'üëº' },
            'reyna': { c:'üëÅÔ∏è', q:'üëª', e:'üõ°Ô∏è', x:'üòà' },
            'sova': { c:'ü¶â', q:'‚ö°', e:'üèπ', x:'üå©Ô∏è' },
            'brim': { c:'üíä', q:'üî•', e:'‚òÅÔ∏è', x:'üõ∞Ô∏è' },
            'omen': { c:'üë£', q:'üåë', e:'üí®', x:'üó∫Ô∏è' },
            'cypher': { c:'üï∏Ô∏è', q:'üóëÔ∏è', e:'üì∑', x:'üëí' }
        };
        const agentsConfig = { 'jett': { color: 0xaaccff }, 'phoenix': { color: 0xffaa00 }, 'sage': { color: 0x00ffaa }, 'reyna': { color: 0xaa00aa }, 'sova': { color: 0x00aaff }, 'brim': { color: 0xff8800 }, 'omen': { color: 0x4444aa }, 'cypher': { color: 0xeeeeee } };

        // --- INIT ---
        async function initFirebase() {
            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                onAuthStateChanged(auth, (user) => { if(user) { userId = user.uid; statusEl.innerText="Online"; statusEl.style.color="#00ffaa"; fetchRooms(); }});
                await signInAnonymously(auth);
            } catch(e) { console.error(e); statusEl.innerText="Offline: "+e.message; statusEl.style.color="#ff4655"; }
        }
        initFirebase();

        // --- LOBBY UI ---
        window.fetchRooms = async () => {
            if(!db) return;
            const q = query(collection(db, "lobbies"), where("status", "==", "waiting"));
            const snap = await getDocs(q);
            const list = document.getElementById('room-list');
            list.innerHTML = "";
            if(snap.empty) list.innerHTML = "<div style='text-align:center; color:#888; padding:20px;'>No rooms found.</div>";
            snap.forEach(d => {
                list.innerHTML += `<div class='room-item'><div><div class='room-name'>${d.data().name}</div></div><button class='join-btn' onclick="joinRoom('${d.id}')">JOIN</button></div>`;
            });
        };

        window.createRoom = async () => {
            if(!userId) return;
            const name = document.getElementById('create-room-name').value;
            myUsername = document.getElementById('player-name-input').value || "Host";
            myTeam = 'defend';
            const ref = doc(collection(db, "lobbies"));
            await setDoc(ref, {
                name, hostId: userId, status: 'waiting',
                players: [{ uid: mySessionId, name: myUsername, agent: null, team: myTeam, isHost: true, locked: false }],
                spike: { state: 'spawned', carrier: null, pos: null }
            });
            enterLobby(ref.id, true);
        };

        window.joinRoom = async (rid) => {
            if(!userId) return;
            myUsername = document.getElementById('player-name-input').value || "Guest";
            myTeam = 'attack';
            const ref = doc(db, "lobbies", rid);
            await updateDoc(ref, { players: arrayUnion({ uid: mySessionId, name: myUsername, agent: null, team: myTeam, isHost: false, locked: false }) });
            enterLobby(rid, false);
        };

        window.switchTeam = (t) => { myTeam = t; updateMyPlayerData(); };

        // --- AGENT SELECT LOGIC ---
        window.enterAgentSelect = async () => {
            if(!currentLobbyId || !isHost) return;
            const ref = doc(db, "lobbies", currentLobbyId);
            await updateDoc(ref, { 
                status: 'agent_select',
                selectEndTime: Date.now() + 60000 
            });
        };

        window.pickAgent = (agent, el) => {
            if(isLockedIn) return;
            selectedAgent = agent;
            document.querySelectorAll('.agent-card').forEach(e => e.classList.remove('selected'));
            el.classList.add('selected');
            document.getElementById('lock-btn').disabled = false;
            // Optionally update draft pick in DB so team sees hover
        };

        window.lockInAgent = async () => {
            if(!selectedAgent || !currentLobbyId) return;
            isLockedIn = true;
            document.getElementById('lock-btn').innerText = "LOCKED";
            document.getElementById('lock-btn').disabled = true;
            
            // Update DB
            const ref = doc(db, "lobbies", currentLobbyId);
            const snap = await getDoc(ref);
            if(!snap.exists()) return;
            let p = snap.data().players;
            const idx = p.findIndex(x => x.uid === mySessionId);
            if(idx >= 0) { 
                p[idx].agent = selectedAgent; 
                p[idx].team = myTeam; 
                p[idx].locked = true;
                await updateDoc(ref, { players: p }); 
            }
        };

        async function updateMyPlayerData() {
            if(!currentLobbyId) return;
            const ref = doc(db, "lobbies", currentLobbyId);
            const snap = await getDoc(ref);
            if(!snap.exists()) return;
            let p = snap.data().players;
            const idx = p.findIndex(x => x.uid === mySessionId);
            if(idx >= 0) { 
                p[idx].team = myTeam; 
                await updateDoc(ref, { players: p }); 
            }
        }

        window.hostStartGame = async () => {
            if(!currentLobbyId || !isHost) return;
            const ref = doc(db, "lobbies", currentLobbyId);
            const snap = await getDoc(ref);
            // Spike assign
            const players = snap.data().players;
            const attackers = players.filter(p => p.team === 'attack');
            let spikeCarrier = null;
            if(attackers.length > 0) {
                spikeCarrier = attackers[Math.floor(Math.random() * attackers.length)].uid;
            }

            await updateDoc(ref, { 
                status: 'playing', gamePhase: 'buy', phaseEndTime: Date.now() + 30000,
                spike: { state: 'carried', carrier: spikeCarrier, pos: null }
            });
        };

        function enterLobby(rid, h) {
            currentLobbyId = rid; isHost = h;
            document.getElementById('browser-screen').style.display = 'none';
            document.getElementById('waiting-screen').style.display = 'block';
            document.getElementById('host-start-btn').style.display = isHost ? 'block' : 'none';
            document.getElementById('client-wait-msg').style.display = isHost ? 'none' : 'block';

            onSnapshot(doc(db, "lobbies", rid), (snap) => {
                if(!snap.exists()) return;
                const d = snap.data();
                
                // --- HANDLE SCREENS ---
                if (d.status === 'agent_select' && lobbyStatus !== 'agent_select') {
                    lobbyStatus = 'agent_select';
                    document.getElementById('waiting-screen').style.display = 'none';
                    document.getElementById('agent-select-screen').style.display = 'block';
                }

                if (d.status === 'playing') {
                    if (!isPlaying) launchGame();
                    // Phase & Spike sync
                    if(d.gamePhase !== gamePhase) {
                        gamePhase = d.gamePhase;
                        phaseEndTime = d.phaseEndTime;
                        handlePhaseChange();
                    }
                    if(d.spike) handleSpikeUpdate(d.spike);
                }

                // --- UI UPDATES ---
                if (lobbyStatus === 'waiting') {
                    renderLobbyPlayers(d.players || []);
                } else if (lobbyStatus === 'agent_select') {
                    renderAgentSelectStatus(d.players || [], d.selectEndTime);
                    // Host Auto-Start Check
                    if (isHost && !isPlaying) {
                        const allLocked = d.players.every(p => p.locked);
                        const timeOut = Date.now() > d.selectEndTime;
                        if (allLocked || timeOut) {
                            window.hostStartGame();
                        }
                    }
                }
            });
        }

        function renderLobbyPlayers(players) {
            const atk = document.getElementById('team-attack-list');
            const def = document.getElementById('team-defend-list');
            atk.innerHTML = ""; def.innerHTML = "";
            players.forEach(p => {
                const html = `<div class='player-row ${p.uid===mySessionId?"me":""}'><span class='p-name'>${p.name}</span></div>`;
                if(p.team === 'attack') atk.innerHTML += html; else def.innerHTML += html;
            });
        }

        function renderAgentSelectStatus(players, endTime) {
            const atk = document.getElementById('select-attack-list');
            const def = document.getElementById('select-defend-list');
            atk.innerHTML = ""; def.innerHTML = "";
            
            // Timer
            const timeLeft = Math.max(0, Math.ceil((endTime - Date.now())/1000));
            document.getElementById('select-timer').innerText = timeLeft;

            const icons = { 'jett': 'üí®', 'phoenix': 'üî•', 'sage': 'üßä', 'reyna': 'üëÅÔ∏è', 'sova': 'üèπ', 'brim': '‚òÅÔ∏è', 'omen': 'üëª', 'cypher': 'üïµÔ∏è' };

            players.forEach(p => {
                const icon = p.agent && p.locked ? icons[p.agent] : '‚ùì';
                const style = p.locked ? "border:2px solid #00ffaa; opacity:1;" : "border:1px solid #555; opacity:0.5;";
                const html = `<div style="width:40px; height:40px; background:#222; display:flex; align-items:center; justify-content:center; font-size:20px; ${style}">${icon}</div>`;
                if(p.team === 'attack') atk.innerHTML += html; else def.innerHTML += html;
            });
        }

        function launchGame() {
            document.getElementById('agent-select-screen').style.display = 'none';
            document.getElementById('waiting-screen').style.display = 'none';
            document.getElementById('ui-layer').style.display = 'block';
            
            // Set Ability Icons
            if (agentAbilities[selectedAgent]) {
                document.getElementById('icon-c').innerText = agentAbilities[selectedAgent].c;
                document.getElementById('icon-q').innerText = agentAbilities[selectedAgent].q;
                document.getElementById('icon-e').innerText = agentAbilities[selectedAgent].e;
                document.getElementById('icon-x').innerText = agentAbilities[selectedAgent].x;
            }

            isPlaying = true;
            create3DScene();
            initGameMultiplayer();
            handlePhaseChange();
        }

        function handlePhaseChange() {
            const st = document.getElementById('round-state');
            const msg = document.getElementById('alert-msg');
            
            if(gamePhase === 'buy') {
                st.innerText = "BUY PHASE"; st.style.color = "#fff";
                msg.innerText = "BUY PHASE"; msg.style.opacity = 1; setTimeout(()=>msg.style.opacity=0, 2000);
            } else if(gamePhase === 'action') {
                st.innerText = "ACTION"; st.style.color = "#ff4655";
                msg.innerText = "BARRIERS DOWN"; msg.style.opacity = 1; setTimeout(()=>msg.style.opacity=0, 2000);
                barriers.forEach(b => { scene.remove(b); walls = walls.filter(w=>w!==b); });
                barriers = [];
            } else if(gamePhase === 'planted') {
                st.innerText = "SPIKE PLANTED"; st.style.color = "#ff0000";
                msg.innerText = "SPIKE PLANTED"; msg.style.color = "#ff0000"; msg.style.opacity = 1; setTimeout(()=>msg.style.opacity=0, 3000);
            } else if(gamePhase === 'defused') {
                msg.innerText = "DEFENDERS WIN"; msg.style.color = "#00ffaa"; msg.style.opacity = 1;
                isPlaying = false; setTimeout(()=>location.reload(), 5000);
            } else if(gamePhase === 'detonated') {
                msg.innerText = "ATTACKERS WIN"; msg.style.color = "#ff4655"; msg.style.opacity = 1;
                isPlaying = false; setTimeout(()=>location.reload(), 5000);
            }
        }

        function handleSpikeUpdate(newSpike) {
            spikeState = newSpike;
            const hud = document.getElementById('spike-hud');
            const txt = document.getElementById('spike-msg');
            
            if (spikeState.carrier === mySessionId) {
                hud.style.display = 'block';
                txt.innerText = "YOU HAVE THE SPIKE";
                txt.style.color = "#ffffff";
            } else if (spikeState.state === 'planted') {
                hud.style.display = 'block';
                txt.innerText = "‚ö†Ô∏è SPIKE PLANTED ‚ö†Ô∏è";
                txt.style.color = "#ff4655";
                if(!spikeMesh && scene) {
                    const geo = new THREE.CylinderGeometry(0.2, 0.4, 0.8, 16);
                    const mat = new THREE.MeshStandardMaterial({color:0xff0000, emissive:0xff0000, emissiveIntensity:0.5});
                    spikeMesh = new THREE.Mesh(geo, mat);
                    spikeMesh.position.set(spikeState.pos.x, spikeState.pos.y, spikeState.pos.z);
                    scene.add(spikeMesh);
                    const light = new THREE.PointLight(0xff0000, 1, 10);
                    light.position.set(spikeState.pos.x, spikeState.pos.y+1, spikeState.pos.z);
                    scene.add(light);
                }
            } else {
                hud.style.display = 'none';
            }
        }

        function checkActions() {
            if (!isPlaying || !camera) return;
            const hud = document.getElementById('spike-hud');
            const txt = document.getElementById('spike-msg');
            const barCont = document.getElementById('plant-bar-container');
            const bar = document.getElementById('plant-bar');
            
            const pos = camera.position;
            
            if (myTeam === 'attack' && spikeState.carrier === mySessionId && gamePhase === 'action') {
                const inSiteA = (pos.x < -20 && pos.x > -40 && pos.z > -10 && pos.z < 10);
                const inSiteB = (pos.x > 20 && pos.x < 40 && pos.z > -10 && pos.z < 10);
                if (inSiteA || inSiteB) {
                    hud.style.display = 'block';
                    txt.innerText = "HOLD [4] TO PLANT";
                    if (isHoldingKey) {
                        currentAction = 'plant';
                        barCont.style.display = 'block';
                        interactionProgress += 0.016; 
                        bar.style.width = (interactionProgress / 4) * 100 + "%"; 
                        if (interactionProgress >= 4) { completePlant(pos); interactionProgress = 0; isHoldingKey = false; }
                    } else { barCont.style.display = 'none'; interactionProgress = 0; }
                    return;
                }
            }

            if (myTeam === 'defend' && spikeState.state === 'planted') {
                const dist = pos.distanceTo(new THREE.Vector3(spikeState.pos.x, spikeState.pos.y, spikeState.pos.z));
                if (dist < 3) {
                    hud.style.display = 'block';
                    txt.innerText = "HOLD [4] TO DEFUSE";
                    if (isHoldingKey) {
                        currentAction = 'defuse';
                        barCont.style.display = 'block';
                        bar.style.backgroundColor = "#00aaff";
                        interactionProgress += 0.016;
                        bar.style.width = (interactionProgress / 7) * 100 + "%"; 
                        if (interactionProgress >= 7) { completeDefuse(); interactionProgress = 0; isHoldingKey = false; }
                    } else { barCont.style.display = 'none'; interactionProgress = 0; }
                    return;
                }
            }
            
            if (spikeState.carrier !== mySessionId && spikeState.state !== 'planted') {
                hud.style.display = 'none';
            }
        }

        async function completePlant(pos) {
            const ref = doc(db, "lobbies", currentLobbyId);
            await updateDoc(ref, {
                gamePhase: 'planted',
                phaseEndTime: Date.now() + 45000, 
                spike: { state: 'planted', carrier: null, pos: {x:pos.x, y:0.4, z:pos.z}, plantTime: Date.now() }
            });
        }

        async function completeDefuse() {
            const ref = doc(db, "lobbies", currentLobbyId);
            await updateDoc(ref, { gamePhase: 'defused' });
        }

        function shoot() {
            if (!isPlaying || !controls.isLocked) return;
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(walls);
            let targetPoint;
            if (intersects.length > 0) targetPoint = intersects[0].point;
            else targetPoint = raycaster.ray.direction.clone().multiplyScalar(100).add(raycaster.ray.origin);
            const gunPos = camera.position.clone().add(new THREE.Vector3(0.2, -0.2, -0.4).applyQuaternion(camera.quaternion));
            const material = new THREE.LineBasicMaterial({ color: 0xffff00, transparent: true, opacity: 1 });
            const points = [gunPos, targetPoint];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, material);
            scene.add(line);
            bullets.push({ mesh: line, time: Date.now() });
        }

        // --- 3D ENGINE ---
        const MOVEMENT_SPEED = 10.0;
        const JUMP_FORCE = 12.0;
        const GRAVITY = 30.0;
        const PLAYER_HEIGHT = 1.6;
        const PLAYER_RADIUS = 0.5;

        let camera, scene, renderer, controls;
        let walls = [];

        function create3DScene() {
            scene = new THREE.Scene(); 
            scene.background = new THREE.Color(0x808080); 
            scene.fog = new THREE.Fog(0x808080, 10, 80);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8); dirLight.position.set(50, 100, -50); dirLight.castShadow = true; scene.add(dirLight);
            controls = new PointerLockControls(camera, document.body);
            
            const grid = new THREE.GridHelper(200, 50, 0x000000, 0x333333);
            scene.add(grid);

            createMap();
            const gun = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.15, 0.5), new THREE.MeshStandardMaterial({color:0x333333})); gun.position.set(0.2, -0.2, -0.4); camera.add(gun); scene.add(camera);
            
            if (myTeam === 'attack') { 
                camera.position.set(0, 2, 40); 
                camera.rotation.y = Math.PI; 
            } else { 
                camera.position.set(0, 2, -40); 
                camera.rotation.y = 0; 
            }
            
            document.addEventListener('mousedown', (e) => { 
                if(isPlaying) {
                    if (!controls.isLocked) controls.lock();
                    else if (e.button === 0) shoot(); 
                }
            });
            animate();
        }

        function createBox(x, y, z, w, h, d, color, isBarrier=false) {
            const geo = new THREE.BoxGeometry(w, h, d); const mat = new THREE.MeshStandardMaterial({ color: color, transparent: isBarrier, opacity: isBarrier ? 0.5 : 1.0 });
            const mesh = new THREE.Mesh(geo, mat); mesh.position.set(x, y + h/2, z); mesh.castShadow = !isBarrier; mesh.receiveShadow = !isBarrier; mesh.geometry.computeBoundingBox();
            scene.add(mesh); walls.push(mesh); if (isBarrier) barriers.push(mesh);
        }

        function createMap() {
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), new THREE.MeshStandardMaterial({ color: 0x444444 })); floor.rotation.x = -Math.PI / 2; floor.receiveShadow = true; scene.add(floor);
            const C_WALL = 0xd6cba8, C_BOX = 0x2e4a3d, C_SITE = 0x888888, C_BARRIER = 0x00aaff;
            createBox(-30, 0, 0, 20, 1, 20, C_SITE); createBox(-30, 0, 0, 4, 3, 4, C_BOX); createBox(-40, 0, 0, 1, 6, 30, C_WALL); createBox(-20, 0, -15, 10, 6, 1, C_WALL);
            createBox(30, 0, 0, 20, 1, 20, C_SITE); createBox(30, 0, 0, 4, 3, 4, C_BOX); createBox(40, 0, 0, 1, 6, 30, C_WALL); createBox(30, 0, 15, 8, 4, 8, C_WALL);
            createBox(0, 0, 0, 10, 6, 10, C_WALL);
            createBox(0, 0, 50, 60, 6, 1, C_WALL); createBox(0, 0, -50, 60, 6, 1, C_WALL); createBox(30, 0, 40, 1, 6, 20, C_WALL); createBox(-30, 0, 40, 1, 6, 20, C_WALL); createBox(30, 0, -40, 1, 6, 20, C_WALL); createBox(-30, 0, -40, 1, 6, 20, C_WALL);
            createBox(-30, 0, 12, 10, 6, 1, C_BARRIER, true); createBox(30, 0, 12, 10, 6, 1, C_BARRIER, true); createBox(0, 0, 10, 15, 6, 1, C_BARRIER, true);
        }

        function initGameMultiplayer() {
            const q = query(collection(db, 'valorant_game_data'), where("lobbyId", "==", currentLobbyId));
            onSnapshot(q, (snap) => {
                snap.docChanges().forEach((ch) => {
                    const d = ch.doc.data(); const id = ch.doc.id;
                    if (id === mySessionId) return;
                    if (ch.type === "added" || ch.type === "modified") updateRemotePlayer(id, d);
                    if (ch.type === "removed") removeRemotePlayer(id);
                });
            });
            setInterval(broadcastPosition, 50);
            window.addEventListener('beforeunload', () => { deleteDoc(doc(db, 'valorant_game_data', mySessionId)); });
        }

        function broadcastPosition() {
            if (!isPlaying || !userId) return;
            const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
            setDoc(doc(db, 'valorant_game_data', mySessionId), {
                lobbyId: currentLobbyId, x: camera.position.x, y: camera.position.y, z: camera.position.z, yaw: Math.atan2(dir.x, dir.z),
                agent: selectedAgent, team: myTeam, lastUpdate: Date.now()
            }, { merge: true });
        }

        function updateRemotePlayer(id, data) {
            if (!remotePlayers[id]) {
                const group = new THREE.Group();
                const color = agentsConfig[data.agent] ? agentsConfig[data.agent].color : 0xffffff;
                const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.4, 1.6, 4, 8), new THREE.MeshStandardMaterial({ color: color })); body.position.y = 0.8; group.add(body);
                const ring = new THREE.Mesh(new THREE.RingGeometry(0.5, 0.6, 16), new THREE.MeshBasicMaterial({ color: data.team === myTeam ? 0x00ffaa : 0xff4655, side: THREE.DoubleSide })); ring.rotation.x = -Math.PI/2; ring.position.y = 0.1; group.add(ring);
                scene.add(group); remotePlayers[id] = group;
            }
            const p = remotePlayers[id]; p.position.set(data.x, data.y - 1.6, data.z); p.rotation.y = data.yaw;
        }

        function removeRemotePlayer(id) { if (remotePlayers[id]) { scene.remove(remotePlayers[id]); delete remotePlayers[id]; } }

        const keys = { w:0, a:0, s:0, d:0, space:0 };
        document.addEventListener('keydown', (e) => { if(e.code==='KeyW')keys.w=1; if(e.code==='KeyA')keys.a=1; if(e.code==='KeyS')keys.s=1; if(e.code==='KeyD')keys.d=1; if(e.code==='Space')keys.space=1; if(e.code==='Digit4') isHoldingKey=true; });
        document.addEventListener('keyup', (e) => { if(e.code==='KeyW')keys.w=0; if(e.code==='KeyA')keys.a=0; if(e.code==='KeyS')keys.s=0; if(e.code==='KeyD')keys.d=0; if(e.code==='Space')keys.space=0; if(e.code==='Digit4') isHoldingKey=false; });

        let prevTime = performance.now(); let velocityY = 0;
        function animate() {
            requestAnimationFrame(animate);
            if (!isPlaying) return;

            const timeEl = document.getElementById('timer');
            if (gamePhase === 'buy' || gamePhase === 'action' || gamePhase === 'planted') {
                let timeLeft = 0;
                if(gamePhase === 'planted') timeLeft = Math.max(0, Math.ceil((phaseEndTime - Date.now()) / 1000));
                else if(gamePhase === 'buy') timeLeft = Math.max(0, Math.ceil((phaseEndTime - Date.now()) / 1000));
                else if(gamePhase === 'action') timeLeft = 100;
                timeEl.innerText = `0:${timeLeft < 10 ? '0' : ''}${timeLeft}`;
                if (isHost && gamePhase === 'buy' && timeLeft <= 0) updateDoc(doc(db,"lobbies",currentLobbyId), { gamePhase: 'action' });
                if (isHost && gamePhase === 'planted' && timeLeft <= 0) updateDoc(doc(db,"lobbies",currentLobbyId), { gamePhase: 'detonated' });
            }

            checkActions();
            
            bullets.forEach((b, i) => { if (Date.now() - b.time > 100) { scene.remove(b.mesh); bullets.splice(i, 1); } });

            if (!controls.isLocked) return;
            const time = performance.now(); const delta = (time - prevTime) / 1000; prevTime = time;
            const moveSpeed = MOVEMENT_SPEED * delta;
            const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir); camDir.y = 0; camDir.normalize();
            const camRight = new THREE.Vector3(); camRight.crossVectors(camDir, new THREE.Vector3(0, 1, 0)); camRight.normalize();
            const moveVec = new THREE.Vector3(0, 0, 0);
            if (keys.w) moveVec.add(camDir); if (keys.s) moveVec.sub(camDir);
            if (keys.d) moveVec.add(camRight); if (keys.a) moveVec.sub(camRight);
            if (moveVec.length() > 0) moveVec.normalize().multiplyScalar(moveSpeed);
            const candidatePos = camera.position.clone(); candidatePos.x += moveVec.x; if (!checkCollision(candidatePos)) camera.position.x += moveVec.x;
            candidatePos.copy(camera.position); candidatePos.z += moveVec.z; if (!checkCollision(candidatePos)) camera.position.z += moveVec.z;
            if (keys.space && camera.position.y <= PLAYER_HEIGHT + 0.1) velocityY = JUMP_FORCE;
            velocityY -= GRAVITY * delta; camera.position.y += velocityY * delta;
            if (camera.position.y < PLAYER_HEIGHT) { camera.position.y = PLAYER_HEIGHT; velocityY = 0; }
            renderer.render(scene, camera);
        }
        window.addEventListener('resize', () => { if(camera) { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }});
    </script>
</body>
</html>
