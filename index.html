<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Silksong-like 2D Game</title>
<style>
  body { margin: 0; overflow: hidden; background: #111; }
  canvas { display: block; background: linear-gradient(#222,#111); cursor: crosshair; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = innerWidth;
canvas.height = innerHeight;

// ===== Player setup =====
const player = {
  x: 100,
  y: 300,
  w: 40,
  h: 60,
  vx: 0,
  vy: 0,
  onGround: false,
  attacking: false,
  facing: 1,
  health: 5
};

// ===== World =====
const gravity = 0.6;
const friction = 0.8;
const ground = { y: canvas.height - 100, h: 100 };
const platforms = [
  { x: 200, y: canvas.height - 200, w: 200, h: 20 },
  { x: 500, y: canvas.height - 300, w: 150, h: 20 }
];

// ===== Enemies =====
let enemies = [
  { x: 600, y: ground.y - 50, w: 40, h: 50, health: 3 },
  { x: 300, y: ground.y - 50, w: 40, h: 50, health: 3 }
];

// ===== Input =====
const keys = {};
onkeydown = e => keys[e.key.toLowerCase()] = true;
onkeyup   = e => keys[e.key.toLowerCase()] = false;

// ===== Mouse input (Left click to attack) =====
canvas.addEventListener("mousedown", e => {
  if (e.button === 0) player.attacking = true;
});
canvas.addEventListener("mouseup", e => {
  if (e.button === 0) player.attacking = false;
});

// ===== Game Loop =====
function loop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = "#222";
  ctx.fillRect(0, ground.y, canvas.width, ground.h);

  // Platforms
  ctx.fillStyle = "#333";
  for (let p of platforms) ctx.fillRect(p.x, p.y, p.w, p.h);

  // Movement
  if (keys["a"]) { player.vx = -4; player.facing = -1; }
  else if (keys["d"]) { player.vx = 4; player.facing = 1; }
  else player.vx *= friction;

  if (keys["w"] && player.onGround) {
    player.vy = -12; player.onGround = false;
  }

  // Also allow spacebar attack
  if (keys[" "]) player.attacking = true;

  // Apply physics
  player.vy += gravity;
  player.x += player.vx;
  player.y += player.vy;

  // Ground + platform collisions
  if (player.y + player.h >= ground.y) {
    player.y = ground.y - player.h; player.vy = 0; player.onGround = true;
  } else {
    player.onGround = false;
    for (let p of platforms) {
      if (player.x + player.w > p.x && player.x < p.x + p.w &&
          player.y + player.h > p.y && player.y + player.h < p.y + p.h + 10 &&
          player.vy >= 0) {
        player.y = p.y - player.h; player.vy = 0; player.onGround = true;
      }
    }
  }

  // Draw player
  ctx.fillStyle = player.attacking ? "#ff3" : "#0f0";
  ctx.fillRect(player.x, player.y, player.w, player.h);

  // Draw attack slash
  if (player.attacking) {
    ctx.strokeStyle = "#fff";
    ctx.beginPath();
    const slashX = player.x + (player.facing === 1 ? player.w : -20);
    ctx.moveTo(slashX, player.y + player.h/2);
    ctx.lineTo(slashX + 20 * player.facing, player.y + player.h/2 - 10);
    ctx.stroke();
  }

  // Enemies
  for (let e of enemies) {
    if (e.health <= 0) continue;
    ctx.fillStyle = "#f00";
    ctx.fillRect(e.x, e.y, e.w, e.h);

    // Simple patrol AI
    e.x += Math.sin(Date.now()/500) * 0.5;

    // Attack detection
    if (player.attacking &&
        player.x + player.w >= e.x &&
        player.x <= e.x + e.w &&
        player.y + player.h >= e.y &&
        player.y <= e.y + e.h) {
      e.health -= 1;
    }
  }

  enemies = enemies.filter(e => e.health > 0);

  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
