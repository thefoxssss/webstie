<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tetris Game</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Arial', sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      overflow: hidden;
    }

    .game-container {
      display: flex;
      gap: 20px;
      padding: 20px;
      position: relative;
    }

    .side-panel {
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      border: 2px solid rgba(168, 85, 247, 0.3);
      border-radius: 15px;
      padding: 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .side-panel.glow {
      box-shadow: 0 0 30px rgba(168, 85, 247, 0.6);
      transform: scale(1.05);
    }

    .main-panel {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
    }

    .title {
      font-size: 3rem;
      font-weight: bold;
      text-align: center;
      background: linear-gradient(45deg, #a855f7, #06b6d4);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: 0 0 30px rgba(168, 85, 247, 0.5);
      animation: pulse 2s infinite;
      letter-spacing: 4px;
    }

    .stats {
      display: flex;
      gap: 15px;
      justify-content: center;
    }

    .stat-box {
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      padding: 10px 20px;
      border-radius: 10px;
      text-align: center;
      min-width: 100px;
      transition: all 0.2s;
    }

    .stat-box:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(168, 85, 247, 0.3);
    }

    .stat-label {
      font-size: 0.75rem;
      opacity: 0.7;
      margin-bottom: 5px;
    }

    .stat-value {
      font-size: 1.5rem;
      font-weight: bold;
    }

    #gameBoard {
      position: relative;
      background: #0a0a0a;
      border: 3px solid;
      border-image: linear-gradient(45deg, #a855f7, #06b6d4) 1;
      box-shadow: 0 0 40px rgba(168, 85, 247, 0.3), inset 0 0 60px rgba(0, 0, 0, 0.5);
      transition: transform 0.05s;
      display: grid;
      gap: 1px;
      padding: 2px;
    }

    #gameBoard.shake {
      animation: shake 0.1s;
    }

    .cell {
      border: 1px solid rgba(255, 255, 255, 0.1);
      transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
      border-radius: 2px;
    }

    .panel-title {
      font-size: 0.875rem;
      font-weight: bold;
      text-align: center;
      margin-bottom: 10px;
      opacity: 0.8;
    }

    .preview-box {
      background: rgba(255, 255, 255, 0.03);
      padding: 10px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 80px;
      transition: all 0.3s;
    }

    .next-preview {
      opacity: 0.6;
      margin-bottom: 10px;
      min-height: 60px;
    }

    .controls {
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      padding: 15px;
      border-radius: 10px;
      margin-top: 15px;
      text-align: center;
      font-size: 0.75rem;
      border: 1px solid rgba(168, 85, 247, 0.2);
    }

    .controls-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-top: 10px;
    }

    .btn {
      background: linear-gradient(45deg, #a855f7, #06b6d4);
      border: none;
      color: white;
      padding: 12px 32px;
      border-radius: 8px;
      font-size: 1.1rem;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 4px 15px rgba(168, 85, 247, 0.4);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .btn:hover {
      transform: translateY(-2px) scale(1.05);
      box-shadow: 0 6px 25px rgba(168, 85, 247, 0.6);
    }

    .btn:active {
      transform: translateY(0) scale(1);
    }

    .game-over {
      text-align: center;
      animation: fadeIn 0.5s;
    }

    .game-over-title {
      font-size: 2.5rem;
      color: #ff0000;
      text-shadow: 0 0 20px #ff0000;
      animation: pulse 1s infinite;
      margin-bottom: 20px;
    }

    .overlay-message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-weight: bold;
      pointer-events: none;
      z-index: 100;
      text-align: center;
      white-space: nowrap;
    }

    .combo-text {
      font-size: 3.5rem;
      color: #ffff00;
      text-shadow: 0 0 20px #ffff00, 0 0 40px #ffff00;
      animation: comboPopIn 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }

    .action-text {
      font-size: 2.5rem;
      color: #ff00ff;
      text-shadow: 0 0 30px #ff00ff;
      animation: actionPopIn 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }

    .perfect-clear {
      font-size: 2rem;
      color: #ff00ff;
      text-shadow: 0 0 30px #ff00ff;
      animation: perfectClearAnim 2s ease-out;
    }

    .paused {
      font-size: 2rem;
      color: #ffff00;
      text-shadow: 0 0 15px #ffff00;
      animation: pulse 1.5s infinite;
    }

    canvas {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    @keyframes shake {
      0%, 100% { transform: translate(0, 0); }
      25% { transform: translate(-2px, 2px); }
      50% { transform: translate(2px, -2px); }
      75% { transform: translate(-2px, -2px); }
    }

    @keyframes comboPopIn {
      0% { transform: translate(-50%, -50%) scale(0) rotate(-180deg); opacity: 0; }
      50% { transform: translate(-50%, -50%) scale(1.3) rotate(10deg); }
      100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); opacity: 1; }
    }

    @keyframes actionPopIn {
      0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
      60% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(1); }
    }

    @keyframes perfectClearAnim {
      0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
      30% { transform: translate(-50%, -50%) scale(1.5); opacity: 1; }
      70% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes clearLine {
      0% { 
        opacity: 1; 
        transform: scaleY(1) scaleX(1); 
        filter: brightness(1);
        background-color: var(--cell-color);
      }
      25% {
        opacity: 1;
        transform: scaleY(1.2) scaleX(1.05);
        filter: brightness(3) saturate(2);
      }
      50% {
        opacity: 1;
        transform: scaleY(1) scaleX(1.1);
        filter: brightness(5) saturate(3);
      }
      75% {
        opacity: 0.7;
        transform: scaleY(0.3) scaleX(1.2);
        filter: brightness(2);
      }
      100% { 
        opacity: 0; 
        transform: scaleY(0) scaleX(1.5); 
        filter: brightness(0);
      }
    }

    @keyframes flashLine {
      0%, 100% { 
        box-shadow: 0 0 20px rgba(255, 255, 255, 0);
      }
      50% { 
        box-shadow: 0 0 40px rgba(255, 255, 255, 1), inset 0 0 20px rgba(255, 255, 255, 0.8);
      }
    }

    .update-log-btn {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(168, 85, 247, 0.8);
      backdrop-filter: blur(10px);
      border: 2px solid rgba(168, 85, 247, 0.5);
      color: white;
      padding: 10px 20px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: bold;
      font-size: 0.9rem;
      transition: all 0.3s;
      z-index: 1000;
      box-shadow: 0 4px 15px rgba(168, 85, 247, 0.3);
    }

    .update-log-btn:hover {
      background: rgba(168, 85, 247, 1);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(168, 85, 247, 0.5);
    }

    .update-log-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(5px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      animation: fadeIn 0.3s;
    }

    .update-log-modal.show {
      display: flex;
    }

    .update-log-content {
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      border: 3px solid rgba(168, 85, 247, 0.5);
      border-radius: 20px;
      padding: 30px;
      max-width: 500px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 10px 50px rgba(168, 85, 247, 0.5);
      animation: slideIn 0.3s;
    }

    .update-log-content h2 {
      color: #a855f7;
      margin-bottom: 10px;
      font-size: 2rem;
      text-shadow: 0 0 10px rgba(168, 85, 247, 0.5);
    }

    .version {
      color: #06b6d4;
      font-size: 1.2rem;
      margin-bottom: 20px;
      font-weight: bold;
    }

    .update-section {
      margin-bottom: 20px;
      padding: 15px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      border-left: 4px solid #a855f7;
    }

    .update-section h3 {
      color: #06b6d4;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }

    .update-section ul {
      list-style: none;
      padding: 0;
    }

    .update-section li {
      padding: 5px 0;
      color: rgba(255, 255, 255, 0.9);
      font-size: 0.9rem;
    }

    .update-section li:before {
      content: "‚ú® ";
      color: #a855f7;
    }

    .close-modal {
      background: linear-gradient(45deg, #a855f7, #06b6d4);
      border: none;
      color: white;
      padding: 10px 30px;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      margin-top: 20px;
      width: 100%;
      font-size: 1rem;
      transition: all 0.3s;
    }

    .close-modal:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(168, 85, 247, 0.5);
    }

    @keyframes slideIn {
      from {
        transform: translateY(-50px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    .play-again-btn {
      display: inline-block;
      margin-top: 15px;
      background: linear-gradient(45deg, #a855f7, #06b6d4);
      border: none;
      color: white;
      padding: 12px 32px;
      border-radius: 8px;
      font-size: 1.1rem;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 4px 15px rgba(168, 85, 247, 0.4);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .play-again-btn:hover {
      transform: translateY(-2px) scale(1.05);
      box-shadow: 0 6px 25px rgba(168, 85, 247, 0.6);
    }
  </style>
</head>
<body>
  <button class="update-log-btn" onclick="toggleUpdateLog()">üìã Update Log</button>

  <div class="update-log-modal" id="updateLogModal">
    <div class="update-log-content">
      <h2>Update Log</h2>
      <div class="version">Version 2.0.0</div>
      
      <div class="update-section">
        <h3>üéÆ New Features</h3>
        <ul>
          <li>Added update log modal to track changes</li>
          <li>Play Again button now available during gameplay</li>
          <li>Enhanced line clear animations - smoother and brighter</li>
          <li>Improved particle effects with better physics</li>
          <li>Ghost piece now more visible and cleaner</li>
        </ul>
      </div>

      <div class="update-section">
        <h3>‚ú® Improvements</h3>
        <ul>
          <li>Removed jittery line clear animations</li>
          <li>Smoother piece movement with DAS system</li>
          <li>Better rotation with enhanced wall kicks</li>
          <li>Optimized rendering for 60fps gameplay</li>
          <li>Cleaner UI with glassmorphism effects</li>
        </ul>
      </div>

      <div class="update-section">
        <h3>üé® Visual Enhancements</h3>
        <ul>
          <li>Gradient backgrounds with dynamic lighting</li>
          <li>Glowing effects on active pieces</li>
          <li>Smooth combo and action text animations</li>
          <li>Enhanced particle system with blur effects</li>
          <li>Beautiful color palette across all elements</li>
        </ul>
      </div>

      <div class="update-section">
        <h3>üîß Technical</h3>
        <ul>
          <li>Single HTML file for easy deployment</li>
          <li>No external dependencies</li>
          <li>Optimized for GitHub Pages & Cloudflare</li>
          <li>Mobile responsive design</li>
          <li>Pure vanilla JavaScript</li>
        </ul>
      </div>

      <button class="close-modal" onclick="toggleUpdateLog()">Close</button>
    </div>
  </div>

  <div class="game-container">
    <div class="side-panel" id="holdPanel">
      <div class="panel-title">HOLD (C)</div>
      <div class="preview-box" id="holdBox"></div>
    </div>

    <div class="main-panel">
      <div class="title">TETRIS</div>
      
      <div class="stats">
        <div class="stat-box" style="border: 2px solid rgba(0, 240, 240, 0.3);">
          <div class="stat-label">SCORE</div>
          <div class="stat-value" id="score" style="color: #00f0f0; text-shadow: 0 0 10px #00f0f0;">0</div>
        </div>
        <div class="stat-box" style="border: 2px solid rgba(0, 240, 0, 0.3);">
          <div class="stat-label">LEVEL</div>
          <div class="stat-value" id="level" style="color: #00f000;">1</div>
        </div>
        <div class="stat-box" style="border: 2px solid rgba(240, 240, 0, 0.3);">
          <div class="stat-label">LINES</div>
          <div class="stat-value" id="lines" style="color: #f0f000;">0</div>
        </div>
      </div>

      <div style="position: relative;">
        <div id="gameBoard"></div>
        <canvas id="particleCanvas"></canvas>
        <div id="overlayMessages"></div>
      </div>

      <div id="gameOverScreen" style="display: none;"></div>

      <button class="play-again-btn" onclick="location.reload()" style="display: block;">üîÑ Play Again</button>

      <div class="controls">
        <div style="font-weight: bold; margin-bottom: 10px; color: #a855f7;">CONTROLS</div>
        <div class="controls-grid">
          <div>‚Üê ‚Üí Move</div>
          <div>‚Üë Rotate</div>
          <div>‚Üì Soft Drop</div>
          <div>SPACE Hard Drop</div>
          <div>C Hold</div>
          <div>P Pause</div>
        </div>
      </div>
    </div>

    <div class="side-panel">
      <div class="panel-title">NEXT</div>
      <div id="nextPieces"></div>
    </div>
  </div>

  <script>
    function toggleUpdateLog() {
      const modal = document.getElementById('updateLogModal');
      modal.classList.toggle('show');
    }

    // Close modal when clicking outside
    document.getElementById('updateLogModal').addEventListener('click', function(e) {
      if (e.target === this) {
        toggleUpdateLog();
      }
    });

    const BOARD_WIDTH = 10;
    const BOARD_HEIGHT = 20;
    const CELL_SIZE = 30;
    const DAS_DELAY = 170;
    const DAS_INTERVAL = 50;

    const SHAPES = {
      I: [[1,1,1,1]],
      O: [[1,1],[1,1]],
      T: [[0,1,0],[1,1,1]],
      S: [[0,1,1],[1,1,0]],
      Z: [[1,1,0],[0,1,1]],
      J: [[1,0,0],[1,1,1]],
      L: [[0,0,1],[1,1,1]]
    };

    const COLORS = {
      I: '#00f0f0',
      O: '#f0f000',
      T: '#a000f0',
      S: '#00f000',
      Z: '#f00000',
      J: '#0000f0',
      L: '#f0a000'
    };

    class TetrisGame {
      constructor() {
        this.board = Array(BOARD_HEIGHT).fill().map(() => Array(BOARD_WIDTH).fill(0));
        this.currentPiece = null;
        this.currentPos = { x: 0, y: 0 };
        this.heldPiece = null;
        this.canHold = true;
        this.score = 0;
        this.level = 1;
        this.lines = 0;
        this.gameOver = false;
        this.isPaused = false;
        this.nextPieces = [];
        this.clearingLines = [];
        this.ghostPos = null;
        this.particles = [];
        this.comboCount = 0;
        this.fallSpeed = 500;
        this.lastFallTime = Date.now();
        this.dropLock = false;
        
        this.keysPressed = {};
        this.dasTimers = {};
        this.dasIntervals = {};
        
        this.initGame();
        this.setupControls();
        this.gameLoop();
      }

      initGame() {
        this.nextPieces = [this.getRandomPiece(), this.getRandomPiece(), this.getRandomPiece()];
        this.spawnPiece();
        this.setupParticleCanvas();
        this.updateDisplay();
      }

      setupParticleCanvas() {
        const canvas = document.getElementById('particleCanvas');
        canvas.width = BOARD_WIDTH * CELL_SIZE + 6;
        canvas.height = BOARD_HEIGHT * CELL_SIZE + 6;
        this.particleCtx = canvas.getContext('2d');
      }

      getRandomPiece() {
        const types = Object.keys(SHAPES);
        const type = types[Math.floor(Math.random() * types.length)];
        return { type, shape: JSON.parse(JSON.stringify(SHAPES[type])) };
      }

      spawnPiece(piece = null) {
        const newPiece = piece || this.nextPieces.shift();
        if (!piece) this.nextPieces.push(this.getRandomPiece());
        
        const x = Math.floor(BOARD_WIDTH / 2) - Math.floor(newPiece.shape[0].length / 2);
        this.currentPiece = newPiece;
        this.currentPos = { x, y: 0 };
        this.canHold = true;
        this.calculateGhost();
        
        if (this.checkCollision(this.currentPiece, this.currentPos)) {
          this.gameOver = true;
          this.showGameOver();
        }
        
        this.render();
      }

      checkCollision(piece, pos) {
        for (let y = 0; y < piece.shape.length; y++) {
          for (let x = 0; x < piece.shape[y].length; x++) {
            if (piece.shape[y][x]) {
              const newX = pos.x + x;
              const newY = pos.y + y;
              if (newX < 0 || newX >= BOARD_WIDTH || newY >= BOARD_HEIGHT) return true;
              if (newY >= 0 && this.board[newY][newX]) return true;
            }
          }
        }
        return false;
      }

      movePiece(dx, dy) {
        if (!this.currentPiece || this.gameOver || this.isPaused || this.clearingLines.length > 0 || this.dropLock) return false;
        
        const newPos = { x: this.currentPos.x + dx, y: this.currentPos.y + dy };
        if (!this.checkCollision(this.currentPiece, newPos)) {
          this.currentPos = newPos;
          this.calculateGhost();
          this.render();
          return true;
        }
        return false;
      }

      rotatePiece() {
        if (!this.currentPiece || this.gameOver || this.isPaused || this.clearingLines.length > 0 || this.dropLock) return;
        
        const rotated = this.currentPiece.shape[0].map((_, i) =>
          this.currentPiece.shape.map(row => row[i]).reverse()
        );
        const rotatedPiece = { ...this.currentPiece, shape: rotated };
        
        const kicks = [
          { x: 0, y: 0 },
          { x: -1, y: 0 },
          { x: 1, y: 0 },
          { x: 0, y: -1 },
          { x: -1, y: -1 },
          { x: 1, y: -1 },
          { x: -2, y: 0 },
          { x: 2, y: 0 }
        ];
        
        for (let kick of kicks) {
          const testPos = { x: this.currentPos.x + kick.x, y: this.currentPos.y + kick.y };
          if (!this.checkCollision(rotatedPiece, testPos)) {
            this.currentPiece = rotatedPiece;
            this.currentPos = testPos;
            this.calculateGhost();
            this.render();
            return;
          }
        }
      }

      calculateGhost() {
        if (!this.currentPiece) {
          this.ghostPos = null;
          return;
        }
        
        let ghostY = this.currentPos.y;
        while (!this.checkCollision(this.currentPiece, { x: this.currentPos.x, y: ghostY + 1 })) {
          ghostY++;
        }
        this.ghostPos = ghostY;
      }

      hardDrop() {
        if (!this.currentPiece || this.gameOver || this.isPaused || this.clearingLines.length > 0 || this.dropLock) return;
        
        this.dropLock = true;
        let newY = this.currentPos.y;
        while (!this.checkCollision(this.currentPiece, { x: this.currentPos.x, y: newY + 1 })) {
          newY++;
        }
        
        const dropDistance = newY - this.currentPos.y;
        this.currentPos.y = newY;
        
        for (let y = 0; y < this.currentPiece.shape.length; y++) {
          for (let x = 0; x < this.currentPiece.shape[y].length; x++) {
            if (this.currentPiece.shape[y][x]) {
              this.createParticles(this.currentPos.x + x, this.currentPos.y + y, COLORS[this.currentPiece.type], 15);
            }
          }
        }
        
        this.shakeBoard();
        this.lockPiece();
        
        const points = dropDistance * 2;
        this.score += points;
        this.updateDisplay();
      }

      lockPiece() {
        for (let y = 0; y < this.currentPiece.shape.length; y++) {
          for (let x = 0; x < this.currentPiece.shape[y].length; x++) {
            if (this.currentPiece.shape[y][x]) {
              const boardY = this.currentPos.y + y;
              if (boardY >= 0) {
                this.board[boardY][this.currentPos.x + x] = this.currentPiece.type;
              }
            }
          }
        }
        
        this.clearLines();
      }

      clearLines() {
        const linesToClear = [];
        this.board.forEach((row, y) => {
          if (row.every(cell => cell !== 0)) {
            linesToClear.push(y);
          }
        });

        if (linesToClear.length > 0) {
          this.clearingLines = linesToClear;
          
          linesToClear.forEach(lineY => {
            for (let x = 0; x < BOARD_WIDTH; x++) {
              const color = COLORS[this.board[lineY][x]];
              this.createParticles(x, lineY, color, 12);
            }
          });
          
          this.shakeBoard();
          
          setTimeout(() => {
            this.board = this.board.filter((_, y) => !linesToClear.includes(y));
            while (this.board.length < BOARD_HEIGHT) {
              this.board.unshift(Array(BOARD_WIDTH).fill(0));
            }
            
            if (this.board.every(row => row.every(cell => cell === 0))) {
              this.showMessage('‚òÖ PERFECT CLEAR ‚òÖ', 'perfect-clear', 2000);
              this.score += 1000;
            }
            
            const points = linesToClear.length === 1 ? 100 : 
                          linesToClear.length === 2 ? 300 :
                          linesToClear.length === 3 ? 500 : 800;
            
            this.score += points * this.level;
            this.lines += linesToClear.length;
            this.level = Math.floor(this.lines / 10) + 1;
            this.fallSpeed = Math.max(100, 500 - (this.level - 1) * 40);
            
            let actionText = '';
            if (linesToClear.length === 4) actionText = 'TETRIS!';
            else if (linesToClear.length === 3) actionText = 'TRIPLE!';
            else if (linesToClear.length === 2) actionText = 'DOUBLE!';
            
            if (actionText) {
              this.showMessage(actionText, 'action-text', 1500);
            }
            
            this.comboCount++;
            if (this.comboCount > 1) {
              this.showMessage(`${this.comboCount}x COMBO!`, 'combo-text', 1000);
            }
            
            this.clearingLines = [];
            this.updateDisplay();
            this.dropLock = false;
            this.spawnPiece();
            this.render();
          }, 400);
        } else {
          this.comboCount = 0;
          this.dropLock = false;
          this.spawnPiece();
        }
      }

      holdPiece() {
        if (!this.canHold || !this.currentPiece || this.gameOver || this.isPaused || this.clearingLines.length > 0 || this.dropLock) return;
        
        this.canHold = false;
        const holdPanel = document.getElementById('holdPanel');
        holdPanel.classList.add('glow');
        setTimeout(() => holdPanel.classList.remove('glow'), 300);
        
        if (this.heldPiece) {
          const temp = this.currentPiece;
          this.spawnPiece(this.heldPiece);
          this.heldPiece = temp;
        } else {
          this.heldPiece = this.currentPiece;
          this.spawnPiece();
        }
        
        this.renderHold();
      }

      createParticles(x, y, color, count) {
        for (let i = 0; i < count; i++) {
          this.particles.push({
            x: x * CELL_SIZE + CELL_SIZE / 2 + 2,
            y: y * CELL_SIZE + CELL_SIZE / 2 + 2,
            vx: (Math.random() - 0.5) * 10,
            vy: (Math.random() - 0.5) * 10 - 3,
            color,
            life: 1,
            size: Math.random() * 3 + 2
          });
        }
      }

      updateParticles() {
        const ctx = this.particleCtx;
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        
        this.particles = this.particles.filter(p => {
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.4;
          p.vx *= 0.98;
          p.life -= 0.015;
          
          if (p.life > 0) {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.shadowBlur = 10;
            ctx.shadowColor = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
            ctx.fill();
            return true;
          }
          return false;
        });
        
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
      }

      shakeBoard() {
        const board = document.getElementById('gameBoard');
        board.classList.add('shake');
        setTimeout(() => board.classList.remove('shake'), 100);
      }

      showMessage(text, className, duration) {
        const container = document.getElementById('overlayMessages');
        const msg = document.createElement('div');
        msg.className = `overlay-message ${className}`;
        msg.textContent = text;
        container.appendChild(msg);
        
        setTimeout(() => {
          msg.remove();
        }, duration);
      }

      showGameOver() {
        const screen = document.getElementById('gameOverScreen');
        screen.style.display = 'block';
        screen.innerHTML = `
          <div class="game-over">
            <div class="game-over-title">GAME OVER</div>
            <div style="font-size: 1.5rem; margin-bottom: 20px;">
              Final Score: <span style="color: #00f0f0; font-weight: bold;">${this.score}</span>
            </div>
            <button class="btn" onclick="location.reload()">Play Again</button>
          </div>
        `;
      }

      setupControls() {
        document.addEventListener('keydown', (e) => {
          if (this.gameOver) return;
          
          if (['ArrowLeft', 'ArrowRight', 'ArrowDown', 'ArrowUp', ' ', 'c', 'C', 'p', 'P'].includes(e.key)) {
            e.preventDefault();
          }
          
          if (!this.keysPressed[e.key]) {
            this.keysPressed[e.key] = true;
            
            switch(e.key) {
              case 'ArrowUp':
                this.rotatePiece();
                break;
              case ' ':
                this.hardDrop();
                break;
              case 'c':
              case 'C':
                this.holdPiece();
                break;
              case 'p':
              case 'P':
                this.isPaused = !this.isPaused;
                if (this.isPaused) {
                  this.showMessage('‚è∏ PAUSED', 'paused', 999999);
                } else {
                  document.getElementById('overlayMessages').innerHTML = '';
                  this.lastFallTime = Date.now();
                }
                break;
            }
            
            if (['ArrowLeft', 'ArrowRight', 'ArrowDown'].includes(e.key)) {
              this.handleMovement(e.key);
              
              this.dasTimers[e.key] = setTimeout(() => {
                this.dasIntervals[e.key] = setInterval(() => {
                  this.handleMovement(e.key);
                }, DAS_INTERVAL);
              }, DAS_DELAY);
            }
          }
        });
        
        document.addEventListener('keyup', (e) => {
          this.keysPressed[e.key] = false;
          
          if (this.dasTimers[e.key]) {
            clearTimeout(this.dasTimers[e.key]);
            delete this.dasTimers[e.key];
          }
          
          if (this.dasIntervals[e.key]) {
            clearInterval(this.dasIntervals[e.key]);
            delete this.dasIntervals[e.key];
          }
        });
      }

      handleMovement(key) {
        switch(key) {
          case 'ArrowLeft':
            this.movePiece(-1, 0);
            break;
          case 'ArrowRight':
            this.movePiece(1, 0);
            break;
          case 'ArrowDown':
            if (this.movePiece(0, 1)) {
              this.lastFallTime = Date.now();
            }
            break;
        }
      }

      gameLoop() {
        const now = Date.now();
        
        if (!this.gameOver && !this.isPaused && !this.dropLock && now - this.lastFallTime > this.fallSpeed) {
          if (!this.movePiece(0, 1)) {
            this.lockPiece();
          }
          this.lastFallTime = now;
        }
        
        this.updateParticles();
        requestAnimationFrame(() => this.gameLoop());
      }

      render() {
        const board = document.getElementById('gameBoard');
        board.innerHTML = '';
        board.style.gridTemplateColumns = `repeat(${BOARD_WIDTH}, ${CELL_SIZE}px)`;
        
        for (let y = 0; y < BOARD_HEIGHT; y++) {
          for (let x = 0; x < BOARD_WIDTH; x++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.dataset.y = y;
            cell.dataset.x = x;
            cell.style.width = CELL_SIZE + 'px';
            cell.style.height = CELL_SIZE + 'px';
            
            let isCurrentPiece = false;
            let isGhost = false;
            let pieceColor = null;
            
            if (this.currentPiece) {
              for (let py = 0; py < this.currentPiece.shape.length; py++) {
                for (let px = 0; px < this.currentPiece.shape[py].length; px++) {
                  if (this.currentPiece.shape[py][px]) {
                    if (this.currentPos.x + px === x && this.currentPos.y + py === y) {
                      isCurrentPiece = true;
                      pieceColor = COLORS[this.currentPiece.type];
                    }
                    if (this.ghostPos !== null && this.currentPos.x + px === x && this.ghostPos + py === y) {
                      isGhost = true;
                    }
                  }
                }
              }
            }
            
            if (isCurrentPiece) {
              cell.style.backgroundColor = pieceColor;
              cell.style.boxShadow = `0 0 15px ${pieceColor}, inset 0 0 10px ${pieceColor}40`;
            } else if (isGhost && !this.board[y][x]) {
              cell.style.backgroundColor = 'rgba(255, 255, 255, 0.12)';
              cell.style.border = '2px dashed rgba(255, 255, 255, 0.3)';
            } else if (this.board[y][x]) {
              const color = COLORS[this.board[y][x]];
              cell.style.backgroundColor = color;
              cell.style.boxShadow = `0 0 8px ${color}40`;
            } else {
              cell.style.backgroundColor = '#0a0a0a';
            }
            
            board.appendChild(cell);
          }
        }
        
        this.renderHold();
        this.renderNext();
      }

      renderHold() {
        const holdBox = document.getElementById('holdBox');
        holdBox.innerHTML = '';
        
        if (this.heldPiece) {
          const preview = this.createPiecePreview(this.heldPiece, 20);
          holdBox.appendChild(preview);
        }
      }

      renderNext() {
        const container = document.getElementById('nextPieces');
        container.innerHTML = '';
        
        this.nextPieces.slice(0, 3).forEach((piece, i) => {
          const box = document.createElement('div');
          box.className = 'preview-box next-preview';
          box.style.opacity = (1 - (i * 0.25)).toString();
          box.style.transform = 'scale(' + (1 - (i * 0.1)) + ')';
          
          const preview = this.createPiecePreview(piece, 20);
          box.appendChild(preview);
          container.appendChild(box);
        });
      }

      createPiecePreview(piece, size) {
        const container = document.createElement('div');
        container.style.display = 'inline-block';
        
        piece.shape.forEach(function(row) {
          const rowDiv = document.createElement('div');
          rowDiv.style.display = 'flex';
          
          row.forEach(function(cell) {
            const cellDiv = document.createElement('div');
            cellDiv.style.width = size + 'px';
            cellDiv.style.height = size + 'px';
            cellDiv.style.border = cell ? '1px solid rgba(255,255,255,0.3)' : 'none';
            cellDiv.style.backgroundColor = cell ? COLORS[piece.type] : 'transparent';
            cellDiv.style.borderRadius = '2px';
            cellDiv.style.transition = 'all 0.1s';
            if (cell) {
              cellDiv.style.boxShadow = '0 0 ' + (size/4) + 'px ' + COLORS[piece.type] + '40';
            }
            rowDiv.appendChild(cellDiv);
          });
          
          container.appendChild(rowDiv);
        });
        
        return container;
      }

      updateDisplay() {
        document.getElementById('score').textContent = this.score;
        document.getElementById('level').textContent = this.level;
        document.getElementById('lines').textContent = this.lines;
      }
    }

    window.addEventListener('DOMContentLoaded', () => {
      new TetrisGame();
    });
  </script>
</body>
</html>
