import React, { useState, useEffect, useCallback, useRef } from 'react';

const BOARD_WIDTH  = 10;
const BOARD_HEIGHT = 20;
const CELL_SIZE    = 30;

const SHAPES = {
  I: [[1,1,1,1]],
  O: [[1,1],[1,1]],
  T: [[0,1,0],[1,1,1]],
  S: [[0,1,1],[1,1,0]],
  Z: [[1,1,0],[0,1,1]],
  J: [[1,0,0],[1,1,1]],
  L: [[0,0,1],[1,1,1]]
};
const COLORS = {
  I:'#00f0f0', O:'#f0f000', T:'#a000f0',
  S:'#00f000', Z:'#f00000', J:'#0000f0', L:'#f0a000'
};

const LINE_SCORE = [0, 100, 300, 500, 800];        // Guideline
const LOCK_DELAY = 500;                            // ms
const DAS        = 150;   // delayed-auto-shift
const ARR        = 30;    // auto-repeat-rate

const TetrisGame = () => {
  /* ---------- board & pieces ---------- */
  const [board, setBoard]       = useState(() => Array(BOARD_HEIGHT).fill().map(_=>Array(BOARD_WIDTH).fill(0)));
  const [currentPiece, setCurrentPiece] = useState(null);
  const [currentPos, setCurrentPos]     = useState({x:0,y:0});
  const [ghostY, setGhostY]     = useState(null);
  const [nextPiece, setNextPiece]       = useState(null);
  const [heldPiece, setHeldPiece]       = useState(null);
  const [canHold, setCanHold]   = useState(true);

  /* ---------- game loop ---------- */
  const [score, setScore]       = useState(0);
  const [level, setLevel]       = useState(1);
  const [lines, setLines]       = useState(0);
  const [gameOver, setGameOver] = useState(false);
  const [isPaused, setIsPaused] = useState(false);
  const [clearingLines, setClearingLines] = useState([]);
  const [dropAnim, setDropAnim] = useState(null);
  const [shake, setShake]       = useState(0);

  /* ---------- particles / combo ---------- */
  const [particles, setParticles] = useState([]);
  const [combo, setCombo]         = useState(0);
  const [showCombo, setShowCombo] = useState(false);
  const particleIdRef = useRef(0);

  /* ---------- inputs ---------- */
  const keysRef = useRef({});

  /* ---------- 7-bag ---------- */
  const bagRef = useRef([]);
  const refillBag = () => {
    const t = Object.keys(SHAPES);
    bagRef.current = [...t].sort(() => Math.random() - 0.5);
  };
  const getRandomPiece = () => {
    if (!bagRef.current.length) refillBag();
    const type = bagRef.current.pop();
    return { type, shape: SHAPES[type] };
  };

  /* ---------- spawn ---------- */
  const spawnPiece = useCallback((forced=null) => {
    const p = forced || nextPiece || getRandomPiece();
    if (!forced) setNextPiece(getRandomPiece());
    const x = Math.floor(BOARD_WIDTH/2) - Math.floor(p.shape[0].length/2);
    setCurrentPiece(p);
    setCurrentPos({x,y:0});
    setCanHold(true);
    return {piece:p, pos:{x,y:0}};
  }, [nextPiece]);

  /* ---------- collision ---------- */
  const checkCollision = useCallback((piece, pos, tstBoard=board) => {
    for (let y=0;y<piece.shape.length;y++){
      for (let x=0;x<piece.shape[y].length;x++){
        if (!piece.shape[y][x]) continue;
        const nx = pos.x+x, ny = pos.y+y;
        if (nx<0||nx>=BOARD_WIDTH||ny>=BOARD_HEIGHT) return true;
        if (ny>=0&&tstBoard[ny][nx]) return true;
      }
    }
    return false;
  }, [board]);

  /* ---------- ghost ---------- */
  useEffect(() => {
    if (!currentPiece) return;
    let gy = currentPos.y;
    while(!checkCollision(currentPiece,{x:currentPos.x,y:gy+1})) gy++;
    setGhostY(gy);
  }, [currentPiece, currentPos, checkCollision]);

  /* ---------- particles ---------- */
  const createParticles = (x,y,color) => {
    const arr = [];
    for (let i=0;i<8;i++){
      arr.push({
        id: particleIdRef.current++,
        x: x*CELL_SIZE+CELL_SIZE/2,
        y: y*CELL_SIZE+CELL_SIZE/2,
        vx: (Math.random()-0.5)*8,
        vy: (Math.random()-0.5)*8-2,
        color, life:1
      });
    }
    setParticles(p=>[...p,...arr]);
  };

  /* ---------- line clear ---------- */
  const clearLines = useCallback((tstBoard) => {
    const toClear = [];
    tstBoard.forEach((r,y)=>{if (r.every(c=>c!==0)) toClear.push(y);});
    if (!toClear.length) return {cleared:0,delay:false};

    setClearingLines(toClear);
    toClear.forEach(lineY=>{
      for (let x=0;x<BOARD_WIDTH;x++) createParticles(x,lineY,COLORS[tstBoard[lineY][x]]);
    });
    setShake(10);

    setTimeout(()=>{
      let nb = tstBoard.filter((_,y)=>!toClear.includes(y));
      while (nb.length<BOARD_HEIGHT) nb.unshift(Array(BOARD_WIDTH).fill(0));
      setBoard(nb);
      setClearingLines([]);
    },400);

    return {cleared:toClear.length,delay:true};
  }, []);

  /* ---------- movement ---------- */
  const movePiece = (dx,dy) => {
    if (!currentPiece||gameOver||isPaused||clearingLines.length||dropAnim) return false;
    const np = {x:currentPos.x+dx, y:currentPos.y+dy};
    if (!checkCollision(currentPiece,np)){
      setCurrentPos(np);
      return true;
    }
    return false;
  };

  const rotatePiece = () => {
    if (!currentPiece||gameOver||isPaused||clearingLines.length||dropAnim) return;
    const rot = currentPiece.shape[0].map((_,i)=>
      currentPiece.shape.map(r=>r[i]).reverse());
    const rp = {...currentPiece, shape:rot};

    const kicks = [{x:0,y:0},{x:-1,y:0},{x:1,y:0},{x:-2,y:0},{x:2,y:0}];
    for (const k of kicks){
      const tst = {x:currentPos.x+k.x, y:currentPos.y+k.y};
      if (!checkCollision(rp,tst)){
        setCurrentPiece(rp);
        setCurrentPos(tst);
        return;
      }
    }
  };

  const hardDrop = () => {
    if (!currentPiece||gameOver||isPaused||clearingLines.length||dropAnim) return;
    let ny = currentPos.y;
    while(!checkCollision(currentPiece,{x:currentPos.x,y:ny+1})) ny++;
    setDropAnim({from:currentPos.y,to:ny,progress:0});

    setTimeout(()=>{
      setCurrentPos({...currentPos,y:ny});
      // impact particles
      for (let y=0;y<currentPiece.shape.length;y++){
        for (let x=0;x<currentPiece.shape[y].length;x++){
          if (currentPiece.shape[y][x]) createParticles(currentPos.x+x,ny+y,COLORS[currentPiece.type]);
        }
      }
      // place
      const nb = board.map(r=>[...r]);
      for (let y=0;y<currentPiece.shape.length;y++){
        for (let x=0;x<currentPiece.shape[y].length;x++){
          if (currentPiece.shape[y][x]){
            const by = ny+y;
            if (by>=0) nb[by][currentPos.x+x] = currentPiece.type;
          }
        }
      }
      const {cleared,delay} = clearLines(nb);
      if (!delay) setBoard(nb);

      setScore(s=>s + LINE_SCORE[cleared]*level + (ny-currentPos.y)*2);
      setLines(l=>l+cleared);
      if (cleared){
        setCombo(c=>c+1); setShowCombo(true); setTimeout(()=>setShowCombo(false),1000);
      } else setCombo(0);

      setTimeout(()=>{
        const sp = spawnPiece();
        if (checkCollision(sp.piece,sp.pos,nb)) setGameOver(true);
        setDropAnim(null);
      }, delay?450:50);
    },150);
  };

  const holdPiece = () => {
    if (!canHold||!currentPiece||gameOver||isPaused||clearingLines.length||dropAnim) return;
    setCanHold(false);
    if (heldPiece){
      const tmp = currentPiece;
      spawnPiece(heldPiece);
      setHeldPiece(tmp);
    } else {
      setHeldPiece(currentPiece);
      spawnPiece();
    }
  };

  /* ---------- input handlers ---------- */
  useEffect(() => {
    const down = e => keysRef.current[e.key] = true;
    const up   = e => keysRef.current[e.key] = false;
    window.addEventListener('keydown', down);
    window.addEventListener('keyup', up);
    return () => { window.removeEventListener('keydown',down); window.removeEventListener('keyup',up); };
  }, []);

  useEffect(() => {
    const handler = e => {
      if (gameOver) return;
      if (e.repeat) return;
      if (e.key==='ArrowLeft'||e.key==='ArrowRight'||e.key==='ArrowDown') e.preventDefault();
      switch(e.key){
        case 'ArrowLeft':
          movePiece(-1,0);
          break;
        case 'ArrowRight':
          movePiece(1,0);
          break;
        case 'ArrowUp':
          rotatePiece();
          break;
        case ' ':
          hardDrop();
          break;
        case 'c':
        case 'C':
          holdPiece();
          break;
        case 'p':
        case 'P':
          setIsPaused(p=>!p);
          break;
      }
    };
    window.addEventListener('keydown',handler);
    return () => window.removeEventListener('keydown',handler);
  }, [movePiece,rotatePiece,hardDrop,holdPiece,gameOver]);

  /* ---------- DAS / ARR ---------- */
  useEffect(() => {
    if (gameOver||isPaused) return;
    const id = setInterval(()=>{
      if (keysRef.current['ArrowLeft']){ movePiece(-1,0); }
      if (keysRef.current['ArrowRight']){ movePiece(1,0); }
      if (keysRef.current['ArrowDown']){ movePiece(0,1); }
    },ARR);
    return () => clearInterval(id);
  }, [movePiece,gameOver,isPaused]);

  /* ---------- soft-drop DAS starter ---------- */
  useEffect(() => {
    if (gameOver||isPaused) return;
    let t;
    const start = () => {
      if (keysRef.current['ArrowDown']) movePiece(0,1);
      t = setTimeout(start,ARR);
    };
    const first = () => {
      if (keysRef.current['ArrowDown']) {
        movePiece(0,1);
        t = setTimeout(start,ARR);
      }
    };
    const down = e => { if (e.key==='ArrowDown'){ t=setTimeout(first,DAS); } };
    const up   = e => { if (e.key==='ArrowDown'){ clearTimeout(t); } };
    window.addEventListener('keydown',down);
    window.addEventListener('keyup',up);
    return () => { clearTimeout(t); window.removeEventListener('keydown',down); window.removeEventListener('keyup',up); };
  }, [movePiece,gameOver,isPaused]);

  /* ---------- gravity + lock ---------- */
  const [lockTimer,setLockTimer] = useState(0);
  const gravity = Math.max(50, 500 - (level-1)*40); // ms

  useEffect(() => {
    if (!currentPiece||gameOver||isPaused||clearingLines.length||dropAnim) return;
    const id = setInterval(()=>{
      if (!movePiece(0,1)){
        setLockTimer(t=>t+gravity);
        if (lockTimer>=LOCK_DELAY){
          // place
          const nb = board.map(r=>[...r]);
          for (let y=0;y<currentPiece.shape.length;y++){
            for (let x=0;x<currentPiece.shape[y].length;x++){
              if (currentPiece.shape[y][x]){
                const by = currentPos.y+y;
                if (by>=0) nb[by][currentPos.x+x] = currentPiece.type;
              }
            }
          }
          const {cleared,delay} = clearLines(nb);
          if (!delay) setBoard(nb);
          setScore(s=>s + LINE_SCORE[cleared]*level);
          setLines(l=>l+cleared);
          if (cleared){ setCombo(c=>c+1); setShowCombo(true); setTimeout(()=>setShowCombo(false),1000); }
          else setCombo(0);
          if (Math.floor((lines+cleared)/10) > Math.floor(lines/10)) setLevel(lv=>lv+1);

          setTimeout(()=>{
            const sp = spawnPiece();
            if (checkCollision(sp.piece,sp.pos,nb)) setGameOver(true);
            setLockTimer(0);
          },delay?450:0);
        }
      } else setLockTimer(0);
    },gravity);
    return () => clearInterval(id);
  }, [currentPiece,movePiece,board,currentPos,lockTimer,lines,level,clearingLines,dropAnim,spawnPiece,checkCollision,gameOver,isPaused]);

  /* ---------- init ---------- */
  useEffect(() => { if (!nextPiece) setNextPiece(getRandomPiece()); },[nextPiece]);
  useEffect(() => { if (!currentPiece) spawnPiece(); },[currentPiece,spawnPiece]);

  /* ---------- particle anim ---------- */
  useEffect(() => {
    const id = setInterval(()=>{
      setParticles(p=>p.map(q=>({...q,x:q.x+q.vx,y:q.y+q.vy,vy:q.vy+0.3,life:q.life-0.02})).filter(q=>q.life>0));
    },16);
    return () => clearInterval(id);
  }, []);

  /* ---------- render helpers ---------- */
  const renderPiece = (p,small=false) => {
    if (!p) return null;
    const sz = small?20:CELL_SIZE;
    return (
      <div style={{display:'inline-block'}}>
        {p.shape.map((r,y)=>(
          <div key={y} style={{display:'flex'}}>
            {r.map((c,x)=>(
              <div key={x} style={{
                width:sz,height:sz,
                backgroundColor:c?COLORS[p.type]:'transparent',
                border:c?'1px solid rgba(255,255,255,0.3)':'none'
              }} />
            ))}
          </div>
        ))}
      </div>
    );
  };

  /* ---------- jsx ---------- */
  return (
    <div className="flex items-center justify-center min-h-screen bg-gray-900 p-4">
      <div className="flex gap-4">
        {/* hold */ }
        <div className="bg-gray-800 p-4 rounded-lg" style={{transition:'transform .2s',transform:heldPiece?'scale(1.05)':'scale(1)'}}>
          <div className="text-white text-center mb-2"><div className="text-sm mb-2">HOLD (C)</div>
            <div className="bg-gray-700 p-2 rounded flex items-center justify-center" style={{width:100,height:80}}>
              {heldPiece&&renderPiece(heldPiece,true)}
            </div>
          </div>
        </div>

        {/* centre */ }
        <div>
          <div className="text-white text-2xl font-bold text-center mb-2" style={{textShadow:'0 0 10px rgba(255,255,255,.5)'}}>TETRIS</div>
          <div className="text-white text-center mb-2">Score:<span className="text-cyan-400 font-bold text-lg ml-1">{score}</span></div>
          <div className="text-white text-center mb-2">Level:<span className="text-yellow-300 ml-1">{level}</span></div>
          <div className="text-white text-center mb-2">Lines:<span className="text-green-300 ml-1">{lines}</span></div>

          {/* board */ }
          <div className="relative" style={{transform:`translate(${shake*(Math.random()-.5)}px,${shake*(Math.random()-.5)}px)`}}>
            <div className="grid gap-px bg-gray-700 p-1 rounded" style={{gridTemplateColumns:`repeat(${BOARD_WIDTH},${CELL_SIZE}px)`}}>
              {board.map((row,y)=>row.map((cell,x)=>{
                let isCur=false,isGhost=false,isDrop=false,color=null,isClear=clearingLines.includes(y);
                if (currentPiece&&!dropAnim){
                  for (let py=0;py<currentPiece.shape.length;py++){
                    for (let px=0;px<currentPiece.shape[py].length;px++){
                      if (!currentPiece.shape[py][px]) continue;
                      if (currentPos.x+px===x&&currentPos.y+py===y){ isCur=true; color=COLORS[currentPiece.type]; }
                      if (ghostY!==null&&currentPos.x+px===x&&ghostY+py===y) isGhost=true;
                    }
                  }
                }
                if (dropAnim&&currentPiece){
                  const ay = dropAnim.from+(dropAnim.to-dropAnim.from)*Math.min(dropAnim.progress/150,1);
                  for (let py=0;py<currentPiece.shape.length;py++){
                    for (let px=0;px<currentPiece.shape[py].length;px++){
                      if (currentPiece.shape[py][px]&&currentPos.x+px===x&&Math.floor(ay+py)===y){ isDrop=true; color=COLORS[currentPiece.type]; }
                    }
                  }
                }
                return (
                  <div key={`${y}-${x}`} style={{
                    width:CELL_SIZE,height:CELL_SIZE,
                    backgroundColor: isDrop||isCur?color : isGhost?'rgba(255,255,255,.25)':cell?COLORS[cell]:'#0a0a0a',
                    border:(isDrop||isCur||isGhost||cell)?'1px solid rgba(255,255,255,.3)':'1px solid #1a1a1a',
                    transition:isClear?'all .4s ease-out':'background-color .1s',
                    opacity:isClear?0:1,transform:isClear?'scale(0) rotate(180deg)':'scale(1) rotate(0deg)',
                    boxShadow:(isCur||isDrop)?`0 0 10px ${color}`:'none'
                  }} />
                );
              }))}
            </div>

            {/* particles */ }
            <svg className="absolute inset-0 pointer-events-none">
              {particles.map(p=>(
                <circle key={p.id} cx={p.x} cy={p.y} r={3} fill={p.color} opacity={p.life} style={{filter:'blur(1px)'}} />
              ))}
            </svg>

            {/* combo */ }
            {showCombo&&combo>1&&(
              <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                <div className="text-yellow-300 font-black text-4xl animate-bounce" style={{textShadow:'0 0 20px #ffff00,0 0 40px #ffff00'}}>{combo}x COMBO!</div>
              </div>
            )}
          </div>

          {gameOver&&(
            <div className="text-center mt-4 animate-fadeIn">
              <div className="text-red-500 text-xl font-bold mb-2" style={{textShadow:'0 0 10px #ff0000'}}>GAME OVER</div>
              <button onClick={()=>window.location.reload()} className="bg-blue-600 hover:bg-blue-700 text-white px-6 py-2 rounded transition transform hover:scale-110">Play Again</button>
            </div>
          )}
          {isPaused&&!gameOver&&<div className="text-yellow-400 text-xl font-bold text-center mt-4" style={{textShadow:'0 0 10px #ffff00'}}>PAUSED</div>}

          <div className="text-white text-sm mt-4 text-center space-y-1">
            <div>← → : Move  ↑ : Rotate</div>
            <div>↓ : Soft Drop  SPACE : Hard Drop</div>
            <div>C : Hold  P : Pause</div>
          </div>
        </div>

        {/* next */ }
        <div className="bg-gray-800 p-4 rounded-lg">
          <div className="text-white text-center mb-2"><div className="text-sm mb-2">NEXT</div>
            <div className="bg-gray-700 p-2 rounded flex items-center justify-center" style={{width:100,height:80}}>
              {nextPiece&&renderPiece(nextPiece,true)}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default TetrisGame;
