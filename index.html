<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>What up Gooner</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
:root { --bg: #000; --accent: #ff0606; }
html,body { height:100%; margin:0; background:var(--bg); font-family:"Press Start 2P",monospace; overflow:hidden; color:var(--accent); -webkit-tap-highlight-color: transparent;}
.wrap { height:100%; display:flex; align-items:center; justify-content:center; position:relative; user-select:none; text-align:center; padding:10px;}
.gooner { font-size: clamp(24px,8vw,72px); color:var(--accent); cursor:pointer; padding:20px 30px; border:5px solid var(--accent); border-radius:8px; letter-spacing:4px; background:rgba(255,6,6,0.02); transition: transform 200ms ease, box-shadow 200ms ease; box-shadow: 0 6px 0 rgba(0,0,0,0.6); touch-action:manipulation;}
.gooner:hover { transform: translateY(-8px) scale(1.04); box-shadow: 0 14px 0 rgba(0,0,0,0.6); text-shadow:2px 2px 0 rgba(0,0,0,0.9);}
.gooner:active { transform: translateY(-3px) scale(0.97); box-shadow: 0 4px 0 rgba(0,0,0,0.6);}
.hint { position:absolute; bottom:80px; left:50%; transform:translateX(-50%); font-size:clamp(10px,3vw,14px); color:rgba(255,6,6,0.6); letter-spacing:2px;}
.home-input-container { position:absolute; bottom:20px; left:50%; transform:translateX(-50%); width:80%; max-width:400px; }
.home-input { width:100%; background:rgba(255,6,6,0.1); border:2px solid var(--accent); color:var(--accent); padding:12px 15px; font-family:"Press Start 2P",monospace; font-size:clamp(10px,2.5vw,14px); border-radius:6px; outline:none; text-align:center; letter-spacing:2px; box-sizing: border-box; -webkit-appearance: none; }
.home-input::placeholder { color:rgba(255,6,6,0.5); }
.home-input:focus { background:rgba(255,6,6,0.15); box-shadow:0 0 10px rgba(255,6,6,0.3); }

@media (max-width: 768px) {
  .wrap { padding: 20px 10px; }
  .gooner { font-size: clamp(20px, 6vw, 48px); padding: 15px 20px; }
  .hint { bottom: 90px; font-size: clamp(9px, 2.5vw, 12px); }
  .home-input-container { width: 90%; bottom: 15px; }
  .home-input { padding: 10px 12px; font-size: clamp(9px, 2.5vw, 12px); }
  .chat-container { width: 95%; height: 65vh; padding: 15px; }
  .chat-message { padding: 12px; font-size: clamp(9px, 2.5vw, 12px); }
  .chat-input { padding: 10px; font-size: clamp(9px, 2.5vw, 11px); }
  .chat-send-btn { padding: 10px 15px; font-size: clamp(9px, 2.5vw, 11px); min-width: 60px; }
  #overlayPong h1, #overlaySnake h1, #overlayRunner h1 { font-size: clamp(20px, 6vw, 48px); margin-bottom: 10px; }
  .difficulty-btn { padding: 8px 15px; margin: 5px; font-size: clamp(9px, 2.5vw, 11px); }
  .touch-controls.active { grid-template-columns: repeat(3, 50px); grid-template-rows: repeat(3, 50px); gap: 8px; }
  .touch-btn { font-size: 20px; }
}
.hidden-text{ position:fixed; top:10px; left:10px; font-size:clamp(8px,2.5vw,12px); color:rgba(255,6,6,0.6); pointer-events:auto; cursor:pointer; z-index:10001; animation: glitch 1.5s 3s;}
.version{ position:fixed; top:10px; right:10px; font-size:clamp(8px,2.5vw,12px); color:rgba(255,6,6,0.6); z-index:10001; letter-spacing:1px;}
@keyframes glitch {0% {text-shadow:2px 0 var(--accent);}20% {text-shadow:-2px 0 var(--accent);}40% {text-shadow:2px 2 var(--accent);}60% {text-shadow:-2px -2 var(--accent);}80% {text-shadow:2px -2 var(--accent);}100% {text-shadow:none;}}
.overlay { position:fixed; inset:0; background:var(--bg); display:none; align-items:center; justify-content:center; z-index:9999; overflow:hidden; flex-direction:column;}
.overlay.active { display:flex;}
.surface { position:relative; width:100%; height:100%; }
.stamp { position:absolute; color:var(--accent); font-size:clamp(28px,10vw,160px); opacity:0; pointer-events:none; animation: flash 1s linear infinite; text-align:center;}
@keyframes flash {0%,100%{opacity:0;transform:scale(0.9);} 20%,80%{opacity:1;transform:scale(1);}}
.center-giant { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); font-size:clamp(48px,14vw,240px); opacity:0; pointer-events:none; animation:pulse 1.2s ease-in-out infinite;}
@keyframes pulse {0%{opacity:0;transform:translate(-50%,-50%) scale(0.9);}50%{opacity:1;transform:translate(-50%,-50%) scale(1.05);}100%{opacity:0;transform:translate(-50%,-50%) scale(0.95);}}
.glitch-static { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); font-size:clamp(40px,12vw,200px); color:white; animation: tvGlitch 0.8s infinite; letter-spacing:2px;}
@keyframes tvGlitch {0% { transform: translate(-50%,-50%) skew(0deg); opacity:1; }20% { transform: translate(-51%,-49%) skew(-1deg); opacity:1; }50% { transform: translate(-50%,-50%) skew(2deg); opacity:.9; }100% { transform: translate(-50%,-50%) skew(0deg); opacity:1; } }
.close-btn{ position:fixed; top:10px; right:10px; font-size:clamp(10px,4vw,14px); border:2px solid var(--accent); color:var(--accent); background:transparent; padding:6px 10px; border-radius:6px; cursor:pointer; z-index:10000;}
.close-btn:active{ transform:scale(0.9);}
#overlayPong canvas, #overlaySnake canvas, #overlayRunner canvas { border:4px solid var(--accent); background:black; max-width: 100%; height: auto; display: block; margin: 0 auto; touch-action: none; }
#overlayPong h1, #overlaySnake h1, #overlayRunner h1 { color:var(--accent); font-size: clamp(24px, 8vw, 72px); margin-bottom:20px; text-align:center; }
#overlayPong .difficulty-btn { color: var(--accent); background:transparent; border:2px solid var(--accent); padding:10px 20px; margin:10px; cursor:pointer; font-family:"Press Start 2P", monospace; font-size:clamp(10px,2.5vw,12px); border-radius:8px;}
#scoreboard, #snakeScore, #runnerScore { margin-top:10px; font-size: clamp(12px, 3vw, 18px); padding: 10px; }
#winLoseScreen { display:none; flex-direction:column; align-items:center; justify-content:center; position:fixed; inset:0; background:var(--bg); color:var(--accent); font-family:"Press Start 2P",monospace; z-index:10000;}
#winLoseScreen h1 { font-size:clamp(24px,8vw,72px); margin-bottom:20px; text-align:center; }
#winLoseScreen button { color:var(--accent); background:transparent; border:2px solid var(--accent); padding:10px 20px; margin-top:20px; cursor:pointer; border-radius:8px; font-family:"Press Start 2P",monospace; font-size:14px;}
#snakeGameOver, #runnerGameOver { display:none; flex-direction:column; align-items:center; justify-content:center; position:fixed; inset:0; background:var(--bg); color:var(--accent); font-family:"Press Start 2P",monospace; z-index:10000;}
#snakeGameOver h1, #runnerGameOver h1 { font-size:clamp(24px,8vw,72px); margin-bottom:20px; text-align:center; }
#snakeGameOver .score-text, #runnerGameOver .score-text { font-size:clamp(16px,4vw,24px); margin-bottom:20px; }
#snakeGameOver button, #runnerGameOver button { color:var(--accent); background:transparent; border:2px solid var(--accent); padding:10px 20px; margin-top:20px; cursor:pointer; border-radius:8px; font-family:"Press Start 2P",monospace; font-size:14px;}
.touch-controls { display:none; position:fixed; bottom:20px; left:50%; transform:translateX(-50%); z-index:10000; }
.touch-controls.active { display:grid; grid-template-columns: repeat(3, 60px); grid-template-rows: repeat(3, 60px); gap:10px; }
.touch-btn { background:rgba(255,6,6,0.3); border:2px solid var(--accent); color:var(--accent); font-size:24px; border-radius:8px; cursor:pointer; display:flex; align-items:center; justify-content:center; user-select:none; touch-action:manipulation;}
.touch-btn:active { background:rgba(255,6,6,0.6); transform:scale(0.95); }
.touch-btn.empty { opacity:0; pointer-events:none; }
.mobile-hint { display:none; position:fixed; bottom:200px; left:50%; transform:translateX(-50%); font-size:clamp(10px,3vw,14px); color:rgba(255,6,6,0.6); text-align:center; z-index:9998; }
.mobile-hint.active { display:block; }

#overlayAI { background: var(--bg); overflow: hidden; }
#overlayAI h1 { color:var(--accent); font-size: clamp(20px, 6vw, 48px); margin-bottom:20px; text-align:center; }
.chat-container { width: 90%; max-width: 800px; height: 70vh; display: flex; flex-direction: column; border: 4px solid var(--accent); background: rgba(255,6,6,0.05); border-radius: 8px; padding: 20px; }
.chat-messages { flex: 1; overflow-y: scroll; overflow-x: hidden; margin-bottom: 20px; display: flex; flex-direction: column; gap: 15px; padding-right: 10px; -webkit-overflow-scrolling: touch; }
.chat-message { padding: 15px; border-radius: 8px; font-size: clamp(10px, 2.5vw, 14px); line-height: 1.6; word-wrap: break-word; word-break: break-word; animation: messageSlide 0.3s ease; }
.chat-message img { max-width: 100%; height: auto; border-radius: 6px; margin: 8px 0; display: block; border: 2px solid var(--accent); }
@keyframes messageSlide { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
.chat-message.user { background: rgba(255,6,6,0.2); border: 2px solid var(--accent); align-self: flex-end; max-width: 80%; text-align: right; }
.chat-message.ai { background: rgba(255,6,6,0.1); border: 2px solid rgba(255,6,6,0.5); align-self: flex-start; max-width: 80%; }
.chat-input-container { display: flex; gap: 10px; flex-wrap: nowrap; }
.chat-input { flex: 1; background: rgba(255,6,6,0.1); border: 2px solid var(--accent); color: var(--accent); padding: 12px; font-family: "Press Start 2P", monospace; font-size: clamp(10px, 2.5vw, 12px); border-radius: 6px; outline: none; min-width: 0; }
.chat-input::placeholder { color: rgba(255,6,6,0.5); }
.chat-send-btn { background: transparent; border: 2px solid var(--accent); color: var(--accent); padding: 12px 20px; cursor: pointer; font-family: "Press Start 2P", monospace; font-size: clamp(10px, 2.5vw, 12px); border-radius: 6px; transition: all 0.2s; white-space: nowrap; flex-shrink: 0; }
.chat-send-btn:hover { background: rgba(255,6,6,0.2); transform: scale(1.05); }
.chat-send-btn:active { transform: scale(0.95); }
.typing-indicator { padding: 15px; font-size: clamp(10px, 2.5vw, 14px); color: rgba(255,6,6,0.6); align-self: flex-start; background: rgba(255,6,6,0.05); border: 2px solid rgba(255,6,6,0.3); border-radius: 8px; max-width: 80%; animation: pulse 1s ease-in-out infinite; }
.chat-messages::-webkit-scrollbar { width: 8px; }
.chat-messages::-webkit-scrollbar-track { background: rgba(255,6,6,0.1); border-radius: 4px; }
.chat-messages::-webkit-scrollbar-thumb { background: var(--accent); border-radius: 4px; }
.chat-messages::-webkit-scrollbar-thumb:hover { background: #ff3333; }

/* NATE DATING SIM - FULL SCREEN */
#overlayNate { background: linear-gradient(180deg, #0a0000 0%, #000 50%, #0a0000 100%); }
#overlayNate h1 { color:var(--accent); font-size: clamp(32px, 10vw, 96px); margin-bottom:10px; text-align:center; text-shadow: 0 0 20px rgba(255,6,6,0.8); letter-spacing:8px; }
.nate-container { width:90%; max-width:1200px; height:80vh; display:flex; flex-direction:row; gap:20px; }
.nate-left { flex:1; display:flex; flex-direction:column; align-items:center; justify-content:center; position:relative; }
.nate-character-canvas { width:100%; max-width:400px; height:auto; border:4px solid var(--accent); background:#000; box-shadow:0 0 30px rgba(255,6,6,0.5); border-radius:8px; }
.nate-stats { margin-top:20px; display:flex; gap:30px; font-size:clamp(10px,2vw,14px); }
.stat-item { text-align:center; }
.stat-label { color:rgba(255,6,6,0.7); margin-bottom:5px; }
.stat-value { color:var(--accent); font-size:clamp(14px,3vw,24px); text-shadow:0 0 10px rgba(255,6,6,0.6); }
.nate-right { flex:1; display:flex; flex-direction:column; justify-content:space-between; }
.nate-dialogue-box { background:rgba(255,6,6,0.05); border:3px solid var(--accent); border-radius:12px; padding:30px; min-height:200px; box-shadow:inset 0 0 30px rgba(255,6,6,0.1); position:relative; overflow:hidden; }
.nate-dialogue-box::before { content:''; position:absolute; top:0; left:0; right:0; height:3px; background:linear-gradient(90deg, transparent, var(--accent), transparent); animation:scan 3s linear infinite; }
@keyframes scan { 0% { transform:translateX(-100%); } 100% { transform:translateX(100%); } }
.nate-name { color:var(--accent); font-size:clamp(14px,3vw,20px); margin-bottom:15px; text-shadow:0 0 10px rgba(255,6,6,0.8); }
.nate-text { color:#fff; font-size:clamp(11px,2.5vw,16px); line-height:1.8; margin-bottom:20px; }
.nate-emotion { position:absolute; top:15px; right:15px; font-size:clamp(10px,2vw,12px); color:rgba(255,6,6,0.6); }
.nate-choices { display:flex; flex-direction:column; gap:12px; }
.nate-choice-btn { background:transparent; border:3px solid var(--accent); color:var(--accent); padding:15px 25px; cursor:pointer; border-radius:8px; font-family:"Press Start 2P",monospace; font-size:clamp(10px,2vw,14px); transition:all 0.3s; position:relative; overflow:hidden; }
.nate-choice-btn::before { content:''; position:absolute; inset:0; background:var(--accent); transform:translateX(-100%); transition:transform 0.3s; z-index:-1; }
.nate-choice-btn:hover::before { transform:translateX(0); }
.nate-choice-btn:hover { color:#000; box-shadow:0 0 20px rgba(255,6,6,0.8); }
.nate-scene-transition { position:fixed; inset:0; background:var(--accent); z-index:10001; pointer-events:none; opacity:0; transition:opacity 0.5s; }
.nate-scene-transition.active { opacity:1; }
.nate-ending-screen { display:none; position:fixed; inset:0; background:linear-gradient(135deg, #000, #1a0000); align-items:center; justify-content:center; flex-direction:column; z-index:10002; }
.nate-ending-screen.active { display:flex; }
.nate-ending-title { font-size:clamp(32px,8vw,72px); color:var(--accent); margin-bottom:30px; text-shadow:0 0 30px rgba(255,6,6,1); animation:glow 2s ease-in-out infinite; }
@keyframes glow { 0%,100% { text-shadow:0 0 30px rgba(255,6,6,1); } 50% { text-shadow:0 0 50px rgba(255,6,6,1), 0 0 70px rgba(255,6,6,0.8); } }
.nate-ending-text { font-size:clamp(12px,3vw,18px); color:#fff; max-width:600px; text-align:center; line-height:1.8; margin-bottom:40px; }
.nate-ending-btn { background:transparent; border:3px solid var(--accent); color:var(--accent); padding:15px 40px; cursor:pointer; border-radius:8px; font-family:"Press Start 2P",monospace; font-size:clamp(12px,2.5vw,16px); transition:all 0.3s; }
.nate-ending-btn:hover { background:var(--accent); color:#000; box-shadow:0 0 30px rgba(255,6,6,1); }

@media (max-width: 768px) {
  .nate-container { flex-direction:column; height:auto; }
  .nate-character-canvas { max-width:300px; }
  .nate-stats { gap:15px; }
}
</style>
</head>
<body>
<div class="hidden-text" id="hiddenText">you're cool</div>
<div class="version">v12.0 GPT-5 Nano + DALL·E 3</div>
<div class="wrap">
  <div class="gooner" id="mainGooner">what up gooner</div>
  <div class="hint">type a secret code below</div>
  <div class="home-input-container">
    <input type="text" class="home-input" id="homeInput" placeholder="enter code..." autocomplete="off" />
  </div>
</div>

<div class="overlay" id="overlayGonner">
  <button class="close-btn" data-close="overlayGonner">CLOSE</button>
  <div class="surface" id="surfaceGonner"></div>
  <div class="center-giant">GONNER</div>
</div>

<div class="overlay" id="overlayWhy">
  <button class="close-btn" data-close="overlayWhy">CLOSE</button>
  <div class="glitch-static">WHY ARE YOU HERE</div>
</div>

<div class="overlay" id="overlayPong">
  <button class="close-btn" data-close="overlayPong">CLOSE</button>
  <h1>PONG</h1>
  <div>
    <button class="difficulty-btn" data-speed="8" data-ai="0.04" data-ball="8">EASY</button>
    <button class="difficulty-btn" data-speed="8" data-ai="0.07" data-ball="10">MEDIUM</button>
    <button class="difficulty-btn" data-speed="12" data-ai="0.12" data-ball="16">HARD</button>
  </div>
  <div id="scoreboard">0 : 0</div>
  <canvas id="pongCanvas" width="800" height="600"></canvas>
  <div class="mobile-hint" id="pongMobileHint">Use buttons below to move</div>
  <div class="touch-controls" id="pongControls">
    <div class="touch-btn empty"></div>
    <div class="touch-btn" data-pong-dir="up">▲</div>
    <div class="touch-btn empty"></div>
    <div class="touch-btn empty"></div>
    <div class="touch-btn empty"></div>
    <div class="touch-btn empty"></div>
    <div class="touch-btn empty"></div>
    <div class="touch-btn" data-pong-dir="down">▼</div>
    <div class="touch-btn empty"></div>
  </div>
</div>

<div class="overlay" id="overlaySnake">
  <button class="close-btn" data-close="overlaySnake">CLOSE</button>
  <h1>SNAKE</h1>
  <div id="snakeScore">0</div>
  <canvas id="snakeCanvas" width="600" height="400"></canvas>
  <div class="mobile-hint" id="snakeMobileHint">Swipe or use buttons to move</div>
  <div class="touch-controls" id="snakeControls">
    <div class="touch-btn empty"></div>
    <div class="touch-btn" data-snake-dir="UP">▲</div>
    <div class="touch-btn empty"></div>
    <div class="touch-btn" data-snake-dir="LEFT">◄</div>
    <div class="touch-btn empty"></div>
    <div class="touch-btn" data-snake-dir="RIGHT">►</div>
    <div class="touch-btn empty"></div>
    <div class="touch-btn" data-snake-dir="DOWN">▼</div>
    <div class="touch-btn empty"></div>
  </div>
</div>

<div class="overlay" id="overlayRunner">
  <button class="close-btn" data-close="overlayRunner">CLOSE</button>
  <h1>RUNNER</h1>
  <div id="runnerScore">SCORE: 0</div>
  <canvas id="runnerCanvas" width="800" height="400"></canvas>
  <div class="mobile-hint" id="runnerMobileHint">Tap to jump, swipe left/right to change lanes</div>
</div>

<div class="overlay" id="overlayAI">
  <button class="close-btn" data-close="overlayAI">CLOSE</button>
  <h1>AI ASSISTANT</h1>
  <div class="chat-container">
    <div class="chat-messages" id="chatMessages">
      <div class="chat-message ai">hi i made this its powered ny gpt 4?</div>
    </div>
    <div class="chat-input-container">
      <input type="text" class="chat-input" id="chatInput" placeholder="Type your message..." />
      <button class="chat-send-btn" id="chatSendBtn">SEND</button>
    </div>
  </div>
</div>

<!-- NATE DATING SIM - FULL SCREEN -->
<div class="overlay" id="overlayNate">
  <button class="close-btn" data-close="overlayNate">CLOSE</button>
  <h1>NATE</h1>
  <div class="nate-container">
    <div class="nate-left">
      <canvas class="nate-character-canvas" id="nateCharCanvas" width="400" height="600"></canvas>
      <div class="nate-stats">
        <div class="stat-item">
          <div class="stat-label">AFFECTION</div>
          <div class="stat-value" id="nateAffection">0</div>
        </div>
        <div class="stat-item">
          <div class="stat-label">VIBE</div>
          <div class="stat-value" id="nateVibe">CHILL</div>
        </div>
      </div>
    </div>
    <div class="nate-right">
      <div class="nate-dialogue-box">
        <div class="nate-name">NATE</div>
        <div class="nate-emotion" id="nateEmotion">😊</div>
        <div class="nate-text" id="nateDialogueText">Loading...</div>
      </div>
      <div class="nate-choices" id="nateChoicesContainer"></div>
    </div>
  </div>
</div>

<div class="nate-scene-transition" id="nateTransition"></div>

<div class="nate-ending-screen" id="nateEndingScreen">
  <div class="nate-ending-title" id="nateEndingTitle">TRUE ENDING</div>
  <div class="nate-ending-text" id="nateEndingText">You and Nate became close friends...</div>
  <button class="nate-ending-btn" id="nateRestartBtn">PLAY AGAIN</button>
</div>

<div id="winLoseScreen">
  <h1 id="winLoseMessage">YOU WIN</h1>
  <button id="tryAgainBtn">TRY AGAIN</button>
</div>

<div id="snakeGameOver">
  <h1>GAME OVER</h1>
  <div class="score-text">FINAL SCORE: <span id="finalSnakeScore">0</span></div>
  <button id="snakePlayAgainBtn">PLAY AGAIN</button>
  <button id="snakeCloseBtn">CLOSE</button>
</div>

<div id="runnerGameOver">
  <h1>GAME OVER</h1>
  <div class="score-text">FINAL SCORE: <span id="finalRunnerScore">0</span></div>
  <button id="runnerPlayAgainBtn">PLAY AGAIN</button>
  <button id="runnerCloseBtn">CLOSE</button>
</div>

<script>
/* Utilities */
function rand(min,max){return Math.random()*(max-min)+min;}
function populateStamps(surface,text,count=30){
  surface.innerHTML='';
  for(let i=0;i<count;i++){
    const s=document.createElement('div');
    s.className='stamp';
    s.textContent=text;
    s.style.left=rand(-10,90)+'vw';
    s.style.top=rand(-10,90)+'vh';
    s.style.animationDelay=rand(0,1)+'s';
    s.style.animationDuration=rand(0.8,1.6)+'s';
    surface.appendChild(s);
  }
}

/* DOM Refs */
const main=document.getElementById('mainGooner');
const hiddenText=document.getElementById('hiddenText');
const overlayGonner=document.getElementById('overlayGonner');
const overlayWhy=document.getElementById('overlayWhy');
const surfaceGonner=document.getElementById('surfaceGonner');
const homeInput=document.getElementById('homeInput');

const overlayPong=document.getElementById('overlayPong');
const pongCanvas=document.getElementById('pongCanvas');
const ctx=pongCanvas.getContext('2d');
const scoreboard=document.getElementById('scoreboard');

const overlaySnake=document.getElementById('overlaySnake');
const snakeCanvas=document.getElementById('snakeCanvas');
const snakeCtx=snakeCanvas.getContext('2d');
const snakeScoreDisplay=document.getElementById('snakeScore');
const snakeGameOver=document.getElementById('snakeGameOver');
const finalSnakeScore=document.getElementById('finalSnakeScore');
const snakePlayAgainBtn=document.getElementById('snakePlayAgainBtn');
const snakeCloseBtn=document.getElementById('snakeCloseBtn');

const overlayRunner=document.getElementById('overlayRunner');
const runnerCanvas=document.getElementById('runnerCanvas');
const runnerCtx=runnerCanvas.getContext('2d');
const runnerScoreDisplay=document.getElementById('runnerScore');
const runnerGameOver=document.getElementById('runnerGameOver');
const finalRunnerScore=document.getElementById('finalRunnerScore');
const runnerPlayAgainBtn=document.getElementById('runnerPlayAgainBtn');
const runnerCloseBtn=document.getElementById('runnerCloseBtn');

const pongControls=document.getElementById('pongControls');
const snakeControls=document.getElementById('snakeControls');
const pongMobileHint=document.getElementById('pongMobileHint');
const snakeMobileHint=document.getElementById('snakeMobileHint');
const runnerMobileHint=document.getElementById('runnerMobileHint');

const overlayAI=document.getElementById('overlayAI');
const chatMessages=document.getElementById('chatMessages');
const chatInput=document.getElementById('chatInput');
const chatSendBtn=document.getElementById('chatSendBtn');

const winLoseScreen=document.getElementById('winLoseScreen');
const winLoseMessage=document.getElementById('winLoseMessage');
const tryAgainBtn=document.getElementById('tryAgainBtn');

const isMobile = 'ontouchstart' in window;

/* Basic UI handlers */
document.querySelectorAll('.close-btn').forEach(btn=>{
  btn.addEventListener('click',()=>{
    const targetId = btn.dataset.close;
    document.getElementById(targetId).classList.remove('active');
    stopPong();
    stopRunner();
    stopSnake();
    pongControls.classList.remove('active');
    snakeControls.classList.remove('active');
    pongMobileHint.classList.remove('active');
    snakeMobileHint.classList.remove('active');
    runnerMobileHint.classList.remove('active');
  });
});
document.querySelectorAll('.overlay').forEach(ov=>{
  ov.addEventListener('click',(e)=>{
    if(e.target===ov){
      ov.classList.remove('active');
      stopPong();
      stopRunner();
      stopSnake();
      pongControls.classList.remove('active');
      snakeControls.classList.remove('active');
      pongMobileHint.classList.remove('active');
      snakeMobileHint.classList.remove('active');
      runnerMobileHint.classList.remove('active');
    }
  });
});

/* Main hover */
let _hoverInterval;
main.addEventListener('mouseenter',()=>{
  if(window.matchMedia("(hover:hover)").matches){
    _hoverInterval=setInterval(()=>{ main.style.letterSpacing=(Math.random()>0.5?'6px':'2px'); },120);
  }
});
main.addEventListener('mouseleave',()=>{ clearInterval(_hoverInterval); main.style.letterSpacing='4px'; });
main.addEventListener('click',()=>{ overlayGonner.classList.add('active'); populateStamps(surfaceGonner,'GONNER',35); });
hiddenText.addEventListener('click',()=>overlayWhy.classList.add('active'));

/* Home input triggers */
homeInput.addEventListener('input',()=>{
  const value = homeInput.value.toLowerCase();
  if(value.includes('nate')){
    if(window.openNateGame) window.openNateGame();
    homeInput.value='';
    return;
  }
  if(value.includes('ai')){
    overlayAI.classList.add('active');
    chatInput.focus();
    homeInput.value='';
    return;
  }
  if(value.includes('redbull')){
    overlaySnake.classList.add('active');
    if(isMobile){ snakeControls.classList.add('active'); snakeMobileHint.classList.add('active'); }
    initSnakeGame();
    homeInput.value='';
    return;
  }
  if(value.includes('goodboy')){
    overlayRunner.classList.add('active');
    if(isMobile){ runnerMobileHint.classList.add('active'); }
    initRunnerGame();
    homeInput.value='';
    return;
  }
  if(value.includes('pong')){
    overlayPong.classList.add('active');
    if(isMobile){ pongControls.classList.add('active'); pongMobileHint.classList.add('active'); }
    startPong();
    homeInput.value='';
    return;
  }
});

/* PONG */
const paddle = { x:20, y: pongCanvas.height/2 - 40, w:10, h:80, dy:0 };
const ai = { x: pongCanvas.width - 30, y: pongCanvas.height/2 - 40, w:10, h:80 };
const ball = { x: pongCanvas.width/2, y: pongCanvas.height/2, r:8, dx:1, dy:1 };
let aiFactor = 0.07;
let playerScore = 0, aiScore = 0, ballSpeed = 8;
let _pongAnim = 0;

function drawPong(){
  ctx.clearRect(0,0,pongCanvas.width,pongCanvas.height);
  ctx.fillStyle = "#ff0606";
  ctx.fillRect(paddle.x, paddle.y, paddle.w, paddle.h);
  ctx.fillRect(ai.x, ai.y, ai.w, ai.h);
  ctx.beginPath();
  ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
  ctx.fill();
  ctx.closePath();
  ctx.fillRect(pongCanvas.width/2-2, 0, 4, pongCanvas.height);
  scoreboard.textContent = `${playerScore} : ${aiScore}`;
}

function resetBall(){
  ball.x = pongCanvas.width/2;
  ball.y = pongCanvas.height/2;
  ball.dx = (Math.random()>0.5?1:-1);
  ball.dy = (Math.random()>0.5?1:-1);
}

function checkWinLose(){
  if(playerScore >= 10){ winLoseMessage.textContent = "YOU WIN"; winLoseScreen.style.display = "flex"; stopPong(); return true; }
  if(aiScore >= 10){ winLoseMessage.textContent = "YOU LOSE"; winLoseScreen.style.display = "flex"; stopPong(); return true; }
  return false;
}

function updatePong(){
  paddle.y += paddle.dy;
  if(paddle.y < 0) paddle.y = 0;
  if(paddle.y + paddle.h > pongCanvas.height) paddle.y = pongCanvas.height - paddle.h;

  ball.x += ball.dx * ballSpeed / 4;
  ball.y += ball.dy * ballSpeed / 4;

  if(ball.y + ball.r > pongCanvas.height || ball.y - ball.r < 0) ball.dy *= -1;

  if(ball.x - ball.r < paddle.x + paddle.w && ball.y > paddle.y && ball.y < paddle.y + paddle.h) ball.dx *= -1;

  if(ball.x + ball.r > ai.x && ball.y > ai.y && ball.y < ai.y + ai.h) ball.dx *= -1;

  if(ball.x < 0){ aiScore++; resetBall(); }
  if(ball.x > pongCanvas.width){ playerScore++; resetBall(); }

  let target = ball.y - ai.h/2;
  ai.y += (target - ai.y) * aiFactor;
  if(ai.y < 0) ai.y = 0;
  if(ai.y + ai.h > pongCanvas.height) ai.y = pongCanvas.height - ai.h;

  drawPong();
  _pongAnim = requestAnimationFrame(updatePong);
  checkWinLose();
}

function startPong(){
  playerScore = 0; aiScore = 0; resetBall();
  cancelAnimationFrame(_pongAnim);
  updatePong();
}

function stopPong(){
  cancelAnimationFrame(_pongAnim);
  _pongAnim = 0;
}

document.addEventListener('keydown', (e) => {
  if(overlayPong.classList.contains('active')){
    const k = e.key.toLowerCase();
    if(k === 'arrowup' || e.key === 'ArrowUp') paddle.dy = -6;
    if(k === 'arrowdown' || e.key === 'ArrowDown') paddle.dy = 6;
    if(k === 'w') paddle.dy = -6;
    if(k === 's') paddle.dy = 6;
  }
});
document.addEventListener('keyup', (e) => {
  const k = e.key.toLowerCase();
  if(k === 'arrowup' || e.key === 'ArrowUp' || k === 'w') paddle.dy = 0;
  if(k === 'arrowdown' || e.key === 'ArrowDown' || k === 's') paddle.dy = 0;
});
document.querySelectorAll('[data-pong-dir]').forEach(btn=>{
  btn.addEventListener('touchstart',(e)=>{
    e.preventDefault();
    if(btn.dataset.pongDir === 'up') paddle.dy = -6;
    if(btn.dataset.pongDir === 'down') paddle.dy = 6;
  });
  btn.addEventListener('touchend',(e)=>{
    e.preventDefault();
    paddle.dy = 0;
  });
});

document.querySelectorAll('#overlayPong .difficulty-btn').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    aiFactor = parseFloat(btn.dataset.ai);
    ballSpeed = parseInt(btn.dataset.ball);
    playerScore = 0; aiScore = 0; resetBall();
    winLoseScreen.style.display = "none";
    stopPong();
    updatePong();
  });
});
tryAgainBtn.addEventListener('click', ()=>{
  playerScore = 0; aiScore = 0; resetBall();
  winLoseScreen.style.display = "none";
  stopPong();
  updatePong();
});

/* SNAKE */
let snake = [{x:5,y:5}], direction = 'RIGHT', food = null, snakeScore = 0, snakeRunning = false, _snakeTimer = 0;

function placeFood(){
  food = { x: Math.floor(Math.random()*30), y: Math.floor(Math.random()*20) };
}

function drawSnake(){
  snakeCtx.fillStyle = 'black';
  snakeCtx.fillRect(0,0,snakeCanvas.width,snakeCanvas.height);
  snakeCtx.fillStyle = '#ff0606';
  snake.forEach(segment => snakeCtx.fillRect(segment.x*20, segment.y*20, 20, 20));
  snakeCtx.fillStyle = '#ff0606';
  if(food) snakeCtx.fillRect(food.x*20, food.y*20, 20, 20);
}

function updateSnake(){
  if(!snakeRunning) return;
  const head = {...snake[0]};
  if(direction === 'RIGHT') head.x++;
  if(direction === 'LEFT') head.x--;
  if(direction === 'UP') head.y--;
  if(direction === 'DOWN') head.y++;

  if(head.x < 0 || head.x >= 30 || head.y < 0 || head.y >= 20 || snake.some(s => s.x === head.x && s.y === head.y)){
    snakeRunning = false;
    finalSnakeScore.textContent = snakeScore;
    snakeGameOver.style.display = 'flex';
    return;
  }

  snake.unshift(head);
  if(head.x === food.x && head.y === food.y){
    snakeScore++;
    snakeScoreDisplay.textContent = snakeScore;
    placeFood();
  } else {
    snake.pop();
  }
  drawSnake();
  _snakeTimer = setTimeout(updateSnake, 150);
}

function initSnakeGame(){
  snake = [{x:5,y:5}];
  direction = 'RIGHT';
  snakeScore = 0;
  snakeRunning = true;
  placeFood();
  snakeScoreDisplay.textContent = snakeScore;
  snakeGameOver.style.display = 'none';
  clearTimeout(_snakeTimer);
  drawSnake();
  _snakeTimer = setTimeout(updateSnake, 150);
}

document.addEventListener('keydown', (e) => {
  if(overlaySnake.classList.contains('active')){
    const k = e.key.toLowerCase();
    if((k === 'arrowup' || e.key === 'ArrowUp' || k === 'w') && direction !== 'DOWN') direction = 'UP';
    if((k === 'arrowdown' || e.key === 'ArrowDown' || k === 's') && direction !== 'UP') direction = 'DOWN';
    if((k === 'arrowleft' || e.key === 'ArrowLeft' || k === 'a') && direction !== 'RIGHT') direction = 'LEFT';
    if((k === 'arrowright' || e.key === 'ArrowRight' || k === 'd') && direction !== 'LEFT') direction = 'RIGHT';
  }
});
document.querySelectorAll('[data-snake-dir]').forEach(btn=>{
  btn.addEventListener('click', (e) => {
    e.preventDefault();
    const newDir = btn.dataset.snakeDir;
    if(newDir === 'UP' && direction !== 'DOWN') direction = 'UP';
    if(newDir === 'DOWN' && direction !== 'UP') direction = 'DOWN';
    if(newDir === 'LEFT' && direction !== 'RIGHT') direction = 'LEFT';
    if(newDir === 'RIGHT' && direction !== 'LEFT') direction = 'RIGHT';
  });
});

let snakeTouchStartX = 0, snakeTouchStartY = 0;
snakeCanvas.addEventListener('touchstart', (e) => {
  snakeTouchStartX = e.touches[0].clientX;
  snakeTouchStartY = e.touches[0].clientY;
});
snakeCanvas.addEventListener('touchend', (e) => {
  const touchEndX = e.changedTouches[0].clientX;
  const touchEndY = e.changedTouches[0].clientY;
  const diffX = touchEndX - snakeTouchStartX;
  const diffY = touchEndY - snakeTouchStartY;
  if(Math.abs(diffX) > Math.abs(diffY)){
    if(diffX > 30 && direction !== 'LEFT') direction = 'RIGHT';
    else if(diffX < -30 && direction !== 'RIGHT') direction = 'LEFT';
  } else {
    if(diffY > 30 && direction !== 'UP') direction = 'DOWN';
    else if(diffY < -30 && direction !== 'DOWN') direction = 'UP';
  }
});

snakePlayAgainBtn.addEventListener('click', (e) => { e.stopPropagation(); snakeGameOver.style.display = 'none'; initSnakeGame(); });
snakeCloseBtn.addEventListener('click', (e) => { e.stopPropagation(); snakeGameOver.style.display = 'none'; overlaySnake.classList.remove('active'); snakeControls.classList.remove('active'); snakeMobileHint.classList.remove('active'); clearTimeout(_snakeTimer); snakeRunning = false; });

function stopSnake(){
  clearTimeout(_snakeTimer);
  snakeRunning = false;
}

/* RUNNER */
let runnerAnimation = 0;
let runnerRunning = false;
let runnerScore = 0;
let runnerPlayer = null;
let runnerObstacles = [];
let runnerSpeed = 4;

function drawTrain(x,y,size,scale){
  const trainW=size*2.5;
  const trainH=size*1.2;
  runnerCtx.fillStyle='#cc0000';
  runnerCtx.fillRect(x-trainW/2,y-trainH,trainW,trainH);
  runnerCtx.fillStyle='#880000';
  runnerCtx.fillRect(x-trainW/2+size*0.2,y-trainH+size*0.2,size*0.4,size*0.5);
  runnerCtx.fillRect(x+trainW/2-size*0.6,y-trainH+size*0.2,size*0.4,size*0.5);
  runnerCtx.fillStyle='#ffff00';
  runnerCtx.fillRect(x-size*0.15,y-trainH,size*0.3,size*0.2);
  runnerCtx.fillStyle='#333';
  runnerCtx.fillRect(x-trainW/2,y-size*0.25,size*0.3,size*0.25);
  runnerCtx.fillRect(x-trainW/2+trainW*0.35,y-size*0.25,size*0.3,size*0.25);
  runnerCtx.fillRect(x+trainW/2-size*0.3,y-size*0.25,size*0.3,size*0.25);
  runnerCtx.strokeStyle='#ffffff';
  runnerCtx.lineWidth=2*scale;
  runnerCtx.strokeRect(x-trainW/2,y-trainH,trainW,trainH);
}
function drawBlockyPerson(x,y,size,animFrame,isJumping){
  const legSwing=isJumping?0:Math.sin(animFrame)*0.3;
  const armSwing=isJumping?-0.5:Math.cos(animFrame)*0.3;
  const legSpread=isJumping?0.2:0;
  runnerCtx.fillStyle='#ff0606';
  runnerCtx.fillRect(x-size*0.2,y-size*0.9,size*0.4,size*0.3);
  runnerCtx.fillStyle='#cc0000';
  runnerCtx.fillRect(x-size*0.25,y-size*0.6,size*0.5,size*0.4);
  runnerCtx.fillStyle='#ff0606';
  runnerCtx.fillRect(x-size*(0.15+legSpread),y-size*0.2,size*0.15,size*0.35+legSwing*size*0.1);
  runnerCtx.fillRect(x+size*(0.0+legSpread),y-size*0.2,size*0.15,size*0.35-legSwing*size*0.1);
  runnerCtx.fillStyle='#ff4444';
  runnerCtx.fillRect(x-size*0.35,y-size*(0.55-armSwing*0.1),size*0.15,size*0.3);
  runnerCtx.fillRect(x+size*0.2,y-size*(0.55+armSwing*0.1),size*0.15,size*0.3);
  runnerCtx.fillStyle='#000';
  runnerCtx.fillRect(x-size*0.12,y-size*0.85,size*0.08,size*0.08);
  runnerCtx.fillRect(x+size*0.04,y-size*0.85,size*0.08,size*0.08);
}

function drawRunner(){
  const w=runnerCanvas.width, h=runnerCanvas.height;
  runnerCtx.fillStyle='#1a0033';
  runnerCtx.fillRect(0,0,w,h);
  const vanishX=w/2, vanishY=h*0.3, groundY=h*0.85;
  runnerCtx.strokeStyle='#ff0606';
  runnerCtx.lineWidth=2;
  for(let i=0;i<10;i++){
    const z=i*10;
    const scale=1/(z*0.05+1);
    const y=vanishY+(groundY-vanishY)*scale;
    const laneW=w*0.6*scale;
    const x1=vanishX-laneW/2, x2=vanishX+laneW/2;
    runnerCtx.beginPath();
    runnerCtx.moveTo(x1,y);
    runnerCtx.lineTo(x2,y);
    runnerCtx.stroke();

    if(i<9){
      const nextZ=z+10;
      const nextScale=1/(nextZ*0.05+1);
      const nextY=vanishY+(groundY-vanishY)*nextScale;
      for(let lane=0;lane<=3;lane++){
        const lx=x1+(x2-x1)*(lane/3);
        const nextLW=w*0.6*nextScale;
        const nextX1=vanishX-nextLW/2;
        const nextLx=nextX1+(vanishX+nextLW/2-nextX1)*(lane/3);
        runnerCtx.beginPath();
        runnerCtx.moveTo(lx,y);
        runnerCtx.lineTo(nextLx,nextY);
        runnerCtx.stroke();
      }
    }
  }

  runnerObstacles.forEach(obs=>{
    const scale=1/(obs.z*0.05+1);
    const y=vanishY+(groundY-vanishY)*scale;
    const laneW=w*0.6*scale;
    const laneX=vanishX-laneW/2+(laneW/3)*(obs.lane+0.5);
    const size=60*scale;
    drawTrain(laneX,y,size,scale);
  });

  const playerZ=5;
  const playerScale=1/(playerZ*0.05+1);
  const smoothLane=runnerPlayer.lane + (runnerPlayer.targetLane - runnerPlayer.lane) * runnerPlayer.laneTransition;
  const playerY=vanishY+(groundY-vanishY)*playerScale - runnerPlayer.jumpHeight*playerScale;
  const playerLaneW=w*0.6*playerScale;
  const playerX=vanishX-playerLaneW/2+(playerLaneW/3)*(smoothLane+0.5);
  const playerSize=50*playerScale;
  drawBlockyPerson(playerX,playerY,playerSize,runnerPlayer.animFrame,runnerPlayer.jumpHeight>0);

  runnerCtx.fillStyle='#ff0606';
  runnerCtx.font='20px "Press Start 2P"';
  runnerCtx.fillText('LANE: '+(runnerPlayer.targetLane+1),20,40);
}

function spawnObstacle(){
  if(!runnerRunning) return;
  const lane = Math.floor(Math.random()*3);
  runnerObstacles.push({ z: 100, lane: lane, type: 'train' });
  setTimeout(spawnObstacle, 2000 + Math.random()*1500);
}

function updateRunner(){
  if(!runnerRunning) return;

  if(runnerPlayer.jumpHeight === 0) runnerPlayer.animFrame += 0.15;

  if(runnerPlayer.laneTransition < 1){
    runnerPlayer.laneTransition += 0.15;
    if(runnerPlayer.laneTransition >= 1){ runnerPlayer.laneTransition = 1; runnerPlayer.lane = runnerPlayer.targetLane; }
  }

  if(runnerPlayer.jumping){
    runnerPlayer.jumpHeight += 12;
    if(runnerPlayer.jumpHeight >= 140) { runnerPlayer.jumping = false; }
  } else if(runnerPlayer.jumpHeight > 0){
    runnerPlayer.jumpHeight -= 12;
    if(runnerPlayer.jumpHeight < 0) runnerPlayer.jumpHeight = 0;
  }

  for(let i=runnerObstacles.length-1;i>=0;i--){
    runnerObstacles[i].z -= runnerSpeed*0.15;
    if(runnerObstacles[i].z < -5){
      runnerObstacles.splice(i,1);
      runnerScore++;
      runnerScoreDisplay.textContent = 'SCORE: '+runnerScore;
      if(runnerSpeed < 12) runnerSpeed += 0.2;
    } else if(runnerObstacles[i].z < 6 && runnerObstacles[i].z > 4 && runnerObstacles[i].lane === runnerPlayer.lane && runnerPlayer.jumpHeight < 60){
      runnerRunning = false;
      finalRunnerScore.textContent = runnerScore;
      runnerGameOver.style.display = 'flex';
      return;
    }
  }

  if(runnerObstacles.length === 0 || runnerObstacles[runnerObstacles.length-1].z < 80) spawnObstacle();

  drawRunner();
  runnerAnimation = requestAnimationFrame(updateRunner);
}

function initRunnerGame(){
  runnerScore = 0;
  runnerSpeed = 4;
  runnerRunning = true;
  runnerPlayer = { x:0, y:0, lane:1, jumping:false, jumpHeight:0, animFrame:0, targetLane:1, laneTransition:0 };
  runnerObstacles = [];
  runnerGameOver.style.display = 'none';
  runnerScoreDisplay.textContent = 'SCORE: 0';
  spawnObstacle();
  updateRunner();
}

function stopRunner(){
  cancelAnimationFrame(runnerAnimation);
  runnerAnimation = 0;
  runnerRunning = false;
}

document.addEventListener('keydown', (e) => {
  if(overlayRunner.classList.contains('active') && runnerPlayer){
    const k = e.key.toLowerCase();
    if((k === ' ' || e.key === ' ') && !runnerPlayer.jumping && runnerPlayer.jumpHeight === 0){ runnerPlayer.jumping = true; }
    if(k === 'w' && !runnerPlayer.jumping && runnerPlayer.jumpHeight === 0){ runnerPlayer.jumping = true; }

    if((k === 'arrowleft' || e.key === 'ArrowLeft' || k === 'a') && runnerPlayer.targetLane > 0 && runnerPlayer.laneTransition >= 1){ runnerPlayer.targetLane--; runnerPlayer.laneTransition = 0; }
    if((k === 'arrowright' || e.key === 'ArrowRight' || k === 'd') && runnerPlayer.targetLane < 2 && runnerPlayer.laneTransition >= 1){ runnerPlayer.targetLane++; runnerPlayer.laneTransition = 0; }
  }
});
runnerCanvas.addEventListener('click', ()=>{
  if(overlayRunner.classList.contains('active') && runnerPlayer && !runnerPlayer.jumping && runnerPlayer.jumpHeight === 0) runnerPlayer.jumping = true;
});
let runnerTouchX = 0;
runnerCanvas.addEventListener('touchstart', (e)=>{ runnerTouchX = e.touches[0].clientX; });
runnerCanvas.addEventListener('touchend', (e)=>{
  const touchEndX = e.changedTouches[0].clientX;
  const diff = touchEndX - runnerTouchX;
  if(Math.abs(diff) < 30 && runnerPlayer && !runnerPlayer.jumping && runnerPlayer.jumpHeight === 0){ runnerPlayer.jumping = true; }
  else if(diff < -50 && runnerPlayer && runnerPlayer.targetLane > 0 && runnerPlayer.laneTransition >= 1){ runnerPlayer.targetLane--; runnerPlayer.laneTransition = 0; }
  else if(diff > 50 && runnerPlayer && runnerPlayer.targetLane < 2 && runnerPlayer.laneTransition >= 1){ runnerPlayer.targetLane++; runnerPlayer.laneTransition = 0; }
});

runnerPlayAgainBtn.addEventListener('click', (e)=>{ e.stopPropagation(); runnerGameOver.style.display = 'none'; initRunnerGame(); });
runnerCloseBtn.addEventListener('click', (e)=>{ e.stopPropagation(); runnerGameOver.style.display = 'none'; overlayRunner.classList.remove('active'); runnerMobileHint.classList.remove('active'); stopRunner(); });

/* AI Worker Chat */
const WORKER_URL = "https://aiworker.thefoxsss6969.workers.dev";

function addMessage(who, text, isHTML=false){
  const div=document.createElement('div');
  div.className='chat-message '+(who==='user'?'user':'ai');
  if(isHTML) div.innerHTML = text; else div.textContent = text;
  chatMessages.appendChild(div);
  chatMessages.scrollTop = chatMessages.scrollHeight;
}

function showTyping(){ const t=document.createElement('div'); t.className='typing-indicator'; t.id='typingIndicator'; t.textContent='thinking...'; chatMessages.appendChild(t); chatMessages.scrollTop = chatMessages.scrollHeight; }
function hideTyping(){ const t=document.getElementById('typingIndicator'); if(t) t.remove(); }

function buildMessages(userText){
  return [
    { role: "system", content: "You are a helpful assistant." },
    { role: "user", content: userText }
  ];
}

async function sendToWorker(userText){
  try{
    showTyping();
    const body = { messages: buildMessages(userText) };
    const resp = await fetch(WORKER_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body)
    });

    if(!resp.ok){
      hideTyping();
      const errText = await resp.text().catch(()=>`HTTP ${resp.status}`);
      addMessage('ai', `⚠️ Worker error: ${errText}`);
      return;
    }

    const data = await resp.json().catch(()=>null);
    hideTyping();
    if(!data){
      addMessage('ai','⚠️ Invalid response from worker.');
      return;
    }

    let reply = '';
    try{
      if(Array.isArray(data.choices) && data.choices.length){
        reply = data.choices[0].message?.content ?? data.choices[0].text ?? JSON.stringify(data.choices[0]);
      } else if(data.error){
        reply = `OpenAI error: ${data.error.message||JSON.stringify(data.error)}`;
      } else {
        reply = JSON.stringify(data);
      }
    }catch(e){ reply = JSON.stringify(data); }

    addMessage('ai', reply);
  }catch(err){
    hideTyping();
    console.error(err);
    addMessage('ai', '⚠️ Network error while contacting the worker.');
  }
}

chatSendBtn.addEventListener('click', async ()=>{
  const text = chatInput.value.trim();
  if(!text) return;
  addMessage('user', text);
  chatInput.value='';
  await sendToWorker(text);
});

chatInput.addEventListener('keydown', (e)=>{
  if(e.key==='Enter'){ e.preventDefault(); chatSendBtn.click(); }
});

document.addEventListener('keydown', (e)=>{
  if(e.ctrlKey && e.key.toLowerCase()==='k'){
    if(confirm('Clear localStorage? (no API key stored client-side)')){
      localStorage.clear();
      alert('Local storage cleared.');
    }
  }
});

document.addEventListener('click', (e)=>{
  if(overlayAI.classList.contains('active')) setTimeout(()=>chatInput.focus(),80);
});

/* ========================================
   NATE DATING SIM - FULL SCREEN GAME
   ======================================== */
(function(){
  const overlayNate = document.getElementById('overlayNate');
  const canvas = document.getElementById('nateCharCanvas');
  const ctx = canvas ? canvas.getContext('2d') : null;
  const affectionEl = document.getElementById('nateAffection');
  const vibeEl = document.getElementById('nateVibe');
  const emotionEl = document.getElementById('nateEmotion');
  const dialogueTextEl = document.getElementById('nateDialogueText');
  const choicesContainer = document.getElementById('nateChoicesContainer');
  const transitionEl = document.getElementById('nateTransition');
  const endingScreen = document.getElementById('nateEndingScreen');
  const endingTitle = document.getElementById('nateEndingTitle');
  const endingText = document.getElementById('nateEndingText');
  const restartBtn = document.getElementById('nateRestartBtn');

  let affection = 0;
  let currentScene = 'intro';
  let characterPose = 'neutral';
  let animFrame = 0;

  const scenes = {
    intro: {
      text: "yo... i'm nate. late nights, pixels, and vibes. you seem cool. wanna hang?",
      emotion: "😊",
      choices: [
        { text: "Yeah, you seem interesting", next: "getToKnow", affection: 2 },
        { text: "Sure, I guess", next: "casual", affection: 0 },
        { text: "What kind of vibes?", next: "vibes", affection: 1 }
      ]
    },
    getToKnow: {
      text: "aw, thanks. i like making pixel art and breaking synths. it's chaotic but therapeutic, y'know?",
      emotion: "😊",
      choices: [
        { text: "That sounds amazing!", next: "deeper", affection: 3, pose: 'happy' },
        { text: "Tell me more", next: "hobby", affection: 2 },
        { text: "Cool cool", next: "surface", affection: 0 }
      ]
    },
    casual: {
      text: "heh, fair. most people don't get my whole... aesthetic. fishnets and code, right?",
      emotion: "😏",
      choices: [
        { text: "Actually I think it's cool", next: "getToKnow", affection: 2 },
        { text: "You do you", next: "surface", affection: 0 }
      ]
    },
    vibes: {
      text: "like... lo-fi beats at 3am, neon lights, the smell of coffee. pixel perfection in an imperfect world.",
      emotion: "✨",
      choices: [
        { text: "That's poetic", next: "deeper", affection: 3, pose: 'happy' },
        { text: "Sounds chill", next: "hobby", affection: 1 }
      ]
    },
    deeper: {
      text: "i'm glad you get it. most people think i'm weird. but weird is good, yeah? wanna see my latest pixel piece?",
      emotion: "🥰",
      choices: [
        { text: "Absolutely!", next: "art", affection: 4, pose: 'excited' },
        { text: "Maybe later", next: "hang", affection: 1 }
      ]
    },
    hobby: {
      text: "i spend nights making 8-bit worlds. little characters with big stories. it's my escape, my therapy.",
      emotion: "😌",
      choices: [
        { text: "Can I see your work?", next: "art", affection: 3, pose: 'excited' },
        { text: "That's deep", next: "hang", affection: 2 }
      ]
    },
    surface: {
      text: "yeah... anyway, i should probably get back to coding. catch you around?",
      emotion: "😐",
      choices: [
        { text: "Wait, let's talk more", next: "getToKnow", affection: 1 },
        { text: "Yeah, see ya", next: "bad_ending", affection: -2 }
      ]
    },
    art: {
      text: "*shows you a glowing pixel portrait on his phone* this is my latest. took 40 hours. every pixel matters.",
      emotion: "✨",
      choices: [
        { text: "It's beautiful", next: "connection", affection: 5, pose: 'blush' },
        { text: "That's dedication", next: "admire", affection: 3 }
      ]
    },
    hang: {
      text: "wanna grab virtual bubble tea? i know this cool cyber cafe in the metaverse. kidding. unless...?",
      emotion: "😏",
      choices: [
        { text: "Let's go!", next: "date", affection: 4, pose: 'excited' },
        { text: "Maybe next time", next: "friend_ending", affection: 2 }
      ]
    },
    connection: {
      text: "*blushes in 8-bit* you really think so? i... i don't usually show people my art. you're special.",
      emotion: "😳",
      choices: [
        { text: "You're special too", next: "confession", affection: 7, pose: 'blush' },
        { text: "Thanks for sharing", next: "date", affection: 5 }
      ]
    },
    admire: {
      text: "thanks. it means a lot. art is how i express what words can't. maybe i'll make one of you someday?",
      emotion: "😊",
      choices: [
        { text: "I'd love that", next: "date", affection: 4, pose: 'happy' },
        { text: "That'd be cool", next: "hang", affection: 2 }
      ]
    },
    date: {
      text: "*the cyber cafe has retro arcade machines* this place is my sanctuary. wanna try co-op pixel fighter?",
      emotion: "🎮",
      choices: [
        { text: "Let's do it!", next: "gaming", affection: 6, pose: 'excited' },
        { text: "I'll watch you play", next: "watch", affection: 3 }
      ]
    },
    gaming: {
      text: "*you both dominate the game together* yo we're unstoppable! this is... this is really fun. with you.",
      emotion: "🥰",
      choices: [
        { text: "Best team ever", next: "confession", affection: 8, pose: 'blush' },
        { text: "We make a good team", next: "close", affection: 6 }
      ]
    },
    watch: {
      text: "*performs an insane combo* did you see that?! ...sorry, i get excited. you make me want to show off.",
      emotion: "😊",
      choices: [
        { text: "Show off more", next: "close", affection: 5, pose: 'happy' },
        { text: "You're cute when excited", next: "confession", affection: 7, pose: 'blush' }
      ]
    },
    close: {
      text: "*the arcade lights reflect in his eyes* hey... i'm really glad i met you. you make the pixels brighter.",
      emotion: "✨",
      choices: [
        { text: "I feel the same", next: "confession", affection: 8, pose: 'blush' },
        { text: "This has been great", next: "good_ending", affection: 6 }
      ]
    },
    confession: {
      text: "*takes your hand gently* i... i think i'm falling for you. is that too fast? too pixel-glitched?",
      emotion: "😳",
      choices: [
        { text: "I'm falling too", next: "true_ending", affection: 10, pose: 'love' },
        { text: "Let's take it slow", next: "good_ending", affection: 7 }
      ]
    },
    friend_ending: {
      text: "no worries. i'm glad we're friends. you're always welcome in my pixel world. stay cool. 💜",
      emotion: "😊",
      ending: true,
      endingType: "friend"
    },
    good_ending: {
      text: "*smiles warmly* whatever this becomes, i'm here for it. you and me, pixel by pixel. 🌟",
      emotion: "😊",
      ending: true,
      endingType: "good"
    },
    true_ending: {
      text: "*holds both your hands* then let's write our story together. one pixel at a time. forever. ❤️",
      emotion: "🥰",
      ending: true,
      endingType: "true"
    },
    bad_ending: {
      text: "*watches you leave* ...yeah. see ya. *goes back to coding alone*",
      emotion: "😔",
      ending: true,
      endingType: "bad"
    }
  };

  // NATE DATING SIM - Title Screen & Anime Portrait
  function drawCharacter() {
    if(!ctx) return;
    const W = 400, H = 600;
    ctx.clearRect(0, 0, W, H);
    
    // Kawaii gradient background
    const grad = ctx.createLinearGradient(0, 0, 0, H);
    grad.addColorStop(0, '#ff4d6d');
    grad.addColorStop(0.5, '#ff6b9d');
    grad.addColorStop(1, '#ffa8cf');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, W, H);

    // Check if we're on title screen (scene hasn't started yet)
    if(currentScene === 'intro' && !window.nateGameStarted) {
      drawTitleScreen();
      return;
    }

    // Otherwise draw the character
    drawAnimeCharacter();
  }

  function drawTitleScreen() {
    const W = 400, H = 600;
    
    // Sparkles background
    for(let i = 0; i < 30; i++) {
      const x = Math.random() * W;
      const y = Math.random() * H;
      const size = Math.random() * 3 + 1;
      const pulse = Math.sin(animFrame * 0.1 + i) * 0.5 + 0.5;
      ctx.fillStyle = `rgba(255, 255, 255, ${pulse * 0.8})`;
      ctx.fillRect(x, y, size, size);
    }

    // Title with kawaii style
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    // Shadow
    ctx.fillStyle = '#ff0066';
    ctx.font = 'bold 48px "Press Start 2P"';
    ctx.fillText('NATE', W/2 + 3, 150 + 3);
    
    // Main title
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 48px "Press Start 2P"';
    ctx.fillText('NATE', W/2, 150);
    
    // Subtitle - Dating Sim
    ctx.font = 'bold 20px "Press Start 2P"';
    ctx.fillStyle = '#ff0066';
    ctx.fillText('Dating Simulator', W/2 + 2, 200 + 2);
    ctx.fillStyle = '#ffffff';
    ctx.fillText('Dating Simulator', W/2, 200);
    
    // Kawaii hearts
    const hearts = [
      [80, 140], [320, 140], [60, 180], [340, 180],
      [100, 120], [300, 120]
    ];
    hearts.forEach(([x, y], i) => {
      const float = Math.sin(animFrame * 0.08 + i) * 8;
      ctx.fillStyle = '#ff0066';
      // Heart shape
      ctx.beginPath();
      ctx.moveTo(x, y + 5 + float);
      ctx.bezierCurveTo(x, y + float, x - 10, y - 10 + float, x, y - 15 + float);
      ctx.bezierCurveTo(x + 10, y - 10 + float, x, y + float, x, y + 5 + float);
      ctx.fill();
    });

    // Mini character preview
    drawMiniCharacter(W/2, 340);

    // Play button with pulse
    const pulse = Math.sin(animFrame * 0.1) * 10 + 190;
    ctx.fillStyle = '#ff0066';
    ctx.fillRect(W/2 - 102, 450 + 2, 204, 52);
    ctx.fillStyle = `rgb(255, ${pulse}, ${pulse})`;
    ctx.fillRect(W/2 - 100, 450, 200, 50);
    
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 20px "Press Start 2P"';
    ctx.fillText('PLAY', W/2, 475);

    // Instructions
    ctx.font = '12px "Press Start 2P"';
    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
    ctx.fillText('Click to Start!', W/2, 530);

    // Make button clickable
    canvas.style.cursor = 'pointer';
    canvas.onclick = function(e) {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      // Check if clicked on play button
      if(x > W/2 - 100 && x < W/2 + 100 && y > 450 && y < 500) {
        window.nateGameStarted = true;
        canvas.style.cursor = 'default';
        canvas.onclick = null;
      }
    };
  }

  function drawMiniCharacter(cx, cy) {
    // Small anime character preview
    ctx.save();
    ctx.translate(cx, cy);
    ctx.scale(0.6, 0.6);
    
    // Head
    ctx.fillStyle = '#FAD4C9';
    ctx.beginPath();
    ctx.ellipse(0, 0, 40, 50, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Hair
    ctx.fillStyle = '#8A3CCF';
    ctx.beginPath();
    ctx.arc(-15, -30, 35, 0, Math.PI * 2);
    ctx.arc(15, -30, 35, 0, Math.PI * 2);
    ctx.arc(0, -40, 30, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#FF4EB5';
    ctx.beginPath();
    ctx.arc(-20, -10, 25, 0, Math.PI * 2);
    ctx.arc(20, -10, 25, 0, Math.PI * 2);
    ctx.fill();
    
    // Eyes
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.ellipse(-15, 0, 8, 12, 0, 0, Math.PI * 2);
    ctx.ellipse(15, 0, 8, 12, 0, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#5C6FFF';
    ctx.beginPath();
    ctx.arc(-15, 2, 5, 0, Math.PI * 2);
    ctx.arc(15, 2, 5, 0, Math.PI * 2);
    ctx.fill();
    
    // Sparkle
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(-17, -2, 3, 3);
    ctx.fillRect(13, -2, 3, 3);
    
    // Blush
    ctx.fillStyle = 'rgba(255, 150, 180, 0.6)';
    ctx.beginPath();
    ctx.ellipse(-30, 8, 8, 5, 0, 0, Math.PI * 2);
    ctx.ellipse(30, 8, 8, 5, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Mouth
    ctx.strokeStyle = '#ff6b8a';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0, 15, 8, 0, Math.PI);
    ctx.stroke();
    
    ctx.restore();
  }

  function drawAnimeCharacter() {
    const W = 400, H = 600;
    const blush = characterPose === 'blush' || characterPose === 'love' ? 1 : 0;
    
    // Character center position
    const cx = W / 2;
    const cy = H / 2 + 50;

    ctx.save();
    ctx.translate(cx, cy);

    // SMOOTH ANIME STYLE (not pixel art!)
    
    // Long flowing hair - back layer
    ctx.fillStyle = '#8A3CCF';
    ctx.beginPath();
    ctx.ellipse(-60, -80, 50, 120, -0.3, 0, Math.PI * 2);
    ctx.ellipse(60, -80, 50, 120, 0.3, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#FF4EB5';
    ctx.beginPath();
    ctx.ellipse(-50, 20, 35, 80, -0.2, 0, Math.PI * 2);
    ctx.ellipse(50, 20, 35, 80, 0.2, 0, Math.PI * 2);
    ctx.fill();

    // Head
    ctx.fillStyle = '#FAD4C9';
    ctx.beginPath();
    ctx.ellipse(0, -20, 80, 100, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Neck
    ctx.fillStyle = '#f0c4b9';
    ctx.fillRect(-25, 60, 50, 40);

    // Shoulders
    ctx.fillStyle = '#FF2E97';
    ctx.beginPath();
    ctx.ellipse(-60, 100, 40, 30, 0, 0, Math.PI * 2);
    ctx.ellipse(60, 100, 40, 30, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillRect(-80, 85, 160, 50);

    // Top hair
    ctx.fillStyle = '#6A2DA8';
    ctx.beginPath();
    ctx.ellipse(-40, -100, 55, 40, -0.3, 0, Math.PI * 2);
    ctx.ellipse(40, -100, 55, 40, 0.3, 0, Math.PI * 2);
    ctx.ellipse(0, -110, 50, 35, 0, 0, Math.PI * 2);
    ctx.fill();

    // Front bangs
    ctx.fillStyle = '#8A3CCF';
    ctx.beginPath();
    ctx.ellipse(-30, -70, 25, 45, -0.2, 0, Math.PI * 2);
    ctx.ellipse(30, -70, 25, 45, 0.2, 0, Math.PI * 2);
    ctx.ellipse(0, -65, 30, 40, 0, 0, Math.PI * 2);
    ctx.fill();

    // Hair highlights
    ctx.fillStyle = 'rgba(255, 179, 230, 0.5)';
    ctx.beginPath();
    ctx.ellipse(-25, -75, 12, 25, -0.3, 0, Math.PI * 2);
    ctx.ellipse(25, -75, 12, 25, 0.3, 0, Math.PI * 2);
    ctx.fill();

    // LARGE ANIME EYES
    // White
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.ellipse(-30, -10, 18, 25, 0, 0, Math.PI * 2);
    ctx.ellipse(30, -10, 18, 25, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Blue iris
    ctx.fillStyle = '#5C6FFF';
    ctx.beginPath();
    ctx.ellipse(-30, -5, 12, 18, 0, 0, Math.PI * 2);
    ctx.ellipse(30, -5, 12, 18, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Pupil
    ctx.fillStyle = '#3A2E8A';
    ctx.beginPath();
    ctx.arc(-30, -2, 8, 0, Math.PI * 2);
    ctx.arc(30, -2, 8, 0, Math.PI * 2);
    ctx.fill();
    
    // Sparkles
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(-35, -18, 6, 6);
    ctx.fillRect(-26, -8, 4, 4);
    ctx.fillRect(25, -18, 6, 6);
    ctx.fillRect(34, -8, 4, 4);
    
    // Eyelashes
    ctx.strokeStyle = '#4B0033';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-48, -12);
    ctx.lineTo(-42, -15);
    ctx.moveTo(-15, -20);
    ctx.lineTo(-18, -25);
    ctx.moveTo(15, -20);
    ctx.lineTo(18, -25);
    ctx.moveTo(42, -15);
    ctx.lineTo(48, -12);
    ctx.stroke();

    // Eyebrows
    ctx.strokeStyle = '#4B0033';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(-45, -35);
    ctx.quadraticCurveTo(-30, -40, -15, -35);
    ctx.moveTo(15, -35);
    ctx.quadraticCurveTo(30, -40, 45, -35);
    ctx.stroke();

    // Blush
    const blushAlpha = blush ? 0.7 : 0.4;
    ctx.fillStyle = `rgba(255, 107, 138, ${blushAlpha})`;
    ctx.beginPath();
    ctx.ellipse(-55, 10, 18, 12, 0, 0, Math.PI * 2);
    ctx.ellipse(55, 10, 18, 12, 0, 0, Math.PI * 2);
    ctx.fill();

    // Nose
    ctx.fillStyle = '#e5b4a9';
    ctx.beginPath();
    ctx.ellipse(0, 20, 3, 5, 0, 0, Math.PI * 2);
    ctx.fill();

    // Mouth
    if(characterPose === 'happy' || characterPose === 'excited' || characterPose === 'love') {
      ctx.fillStyle = '#ff9db5';
      ctx.beginPath();
      ctx.ellipse(0, 38, 15, 10, 0, 0, Math.PI);
      ctx.fill();
      
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(-8, 35, 4, 6);
      ctx.fillRect(4, 35, 4, 6);
    } else {
      ctx.strokeStyle = '#ff9db5';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(0, 35, 8, 0, Math.PI);
      ctx.stroke();
    }

    ctx.restore();

    // Floating hearts
    if(characterPose === 'love') {
      const hearts = [
        [80, 150], [320, 170], [60, 200], [340, 220]
      ];
      
      hearts.forEach(([x, y], i) => {
        const float = Math.sin(animFrame * 0.08 + i) * 10;
        ctx.fillStyle = '#FF2E97';
        ctx.beginPath();
        ctx.moveTo(x, y + float);
        ctx.bezierCurveTo(x, y - 5 + float, x - 15, y - 15 + float, x, y - 22 + float);
        ctx.bezierCurveTo(x + 15, y - 15 + float, x, y - 5 + float, x, y + float);
        ctx.fill();
        
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.stroke();
      });
    }
  }

  function updateStats() {
    affectionEl.textContent = affection;
    if(affection <= 2) vibeEl.textContent = 'AWKWARD';
    else if(affection <= 5) vibeEl.textContent = 'CHILL';
    else if(affection <= 7) vibeEl.textContent = 'CLOSE';
    else vibeEl.textContent = 'LOVE';
  }

  function transition(callback) {
    transitionEl.classList.add('active');
    setTimeout(() => {
      callback();
      transitionEl.classList.remove('active');
    }, 500);
  }

  function showScene(sceneId) {
    transition(() => {
      currentScene = sceneId;
      const scene = scenes[sceneId];
      
      dialogueTextEl.textContent = scene.text;
      emotionEl.textContent = scene.emotion;
      
      choicesContainer.innerHTML = '';
      
      if(scene.ending) {
        showEnding(scene.endingType);
        return;
      }
      
      scene.choices.forEach(choice => {
        const btn = document.createElement('button');
        btn.className = 'nate-choice-btn';
        btn.textContent = choice.text;
        btn.addEventListener('click', () => {
          affection += choice.affection;
          updateStats();
          if(choice.pose) characterPose = choice.pose;
          showScene(choice.next);
        });
        choicesContainer.appendChild(btn);
      });
    });
  }

  function showEnding(type) {
    setTimeout(() => {
      overlayNate.classList.remove('active');
      endingScreen.classList.add('active');
      
      const endings = {
        bad: {
          title: 'ALONE ENDING',
          text: 'Sometimes connections fade before they begin. The pixels dim, but the code remains...'
        },
        friend: {
          title: 'FRIENDSHIP ENDING',
          text: 'You and Nate became close friends, sharing pixels and late-night vibes. A beautiful bond was formed. 💜'
        },
        good: {
          title: 'GOOD ENDING',
          text: 'Something special bloomed between you two. The future is unwritten, but full of pixelated possibilities. 🌟'
        },
        true: {
          title: 'TRUE LOVE ENDING',
          text: 'You found your pixel soulmate. Together you create beautiful art and even more beautiful memories. Two hearts, one canvas. ❤️✨'
        }
      };
      
      const ending = endings[type] || endings.friend;
      endingTitle.textContent = ending.title;
      endingText.textContent = ending.text;
    }, 800);
  }

  function startGame() {
    affection = 0;
    currentScene = 'intro';
    characterPose = 'neutral';
    updateStats();
    showScene('intro');
    
    // Animation loop
    function animate() {
      animFrame++;
      drawCharacter();
      if(overlayNate.classList.contains('active')) {
        requestAnimationFrame(animate);
      }
    }
    animate();
  }

  restartBtn.addEventListener('click', () => {
    endingScreen.classList.remove('active');
    overlayNate.classList.add('active');
    startGame();
  });

  window.openNateGame = function() {
    overlayNate.classList.add('active');
    startGame();
  };

  // Initial draw
  drawCharacter();
})();
</script>
</body>
</html>
